{"title":"black_magic","slug":"Black-magic","date":"2019-08-19T10:59:50.000Z","updated":"2019-09-03T14:23:09.995Z","comments":true,"path":"api/articles/Black-magic.json","photos":[],"link":"","excerpt":"别说了，听我的！php is the best language!我不允许你有别的想法！ 我要我觉得！不要你觉得！","covers":null,"content":"<p>别说了，听我的！php is the best language!我不允许你有别的想法！ </p>\n<p>我要我觉得！不要你觉得！</p>\n<a id=\"more\"></a>\n<h1 id=\"php-弱类型总结\"><a href=\"#php-弱类型总结\" class=\"headerlink\" title=\"php 弱类型总结\"></a>php 弱类型总结</h1><h2 id=\"字符与数字的比较\"><a href=\"#字符与数字的比较\" class=\"headerlink\" title=\"字符与数字的比较\"></a>字符与数字的比较</h2><pre><code>&lt;?php\n\n$a=1;\nif($a=TRUE)\n    echo &quot;1111\\n&quot;;\nif($a=&apos;a&apos;)\n    echo &quot;1111\\n&quot;;\n\n结果\n1111\n1111</code></pre><p>联想到之前P神的文章，<code>TRUE+TRUE=2</code></p>\n<pre><code>$_=(&apos;&gt;&apos;&gt;&apos;&lt;&apos;)+(&apos;&gt;&apos;&gt;&apos;&lt;&apos;);        //2\necho $_;\n$__=$_/$_;                    //1</code></pre><p>来构造数字1和2</p>\n<h2 id=\"md5比较\"><a href=\"#md5比较\" class=\"headerlink\" title=\"md5比较\"></a>md5比较</h2><pre><code>&lt;?php\nerror_reporting(0); \n$flag = &apos;233&apos;;\n//highlight_file(__FILE__);  \n\n$md51 = md5(&apos;QNKCDZO&apos;);  //0e830400451993494058024219903391\n//$a = $_GET[&apos;b&apos;]; \n$a = &apos;s878926199a&apos;;\n$md52 = md5($a); \nif(isset($a)){ \nif ($a != &apos;QNKCDZO&apos; &amp;&amp; $md51 == $md52) { \n    echo $flag; \n} else { \n    echo &quot;false!!!&quot;; \n    }\n}</code></pre><p>php在进行 <code>==</code> 比较的时候会认为该字符串是科学记数法表示的数字，<code>QNKCDZO</code> MD5值是<code>0e</code>开头，我们也找到一个MD5后<code>0e</code>开头的这样两个字符串都转换为数字0，这样就弱比较相等，但是如果是 <code>===</code> 就不行了。</p>\n<p> === 在进行比较的时候会判断两种字符串的类型是否相等再比较。</p>\n<p> == 在进行比较的时候会将字符串类型转换相同，再比较。如果比较一个数字和字符串或者涉及到数字内容的字符串，则字符串会被转换成数值并且比较按照数值来进行。</p>\n<pre><code>var_dump(&apos;admin&apos;==0);\nvar_dump(&apos;1admin&apos;==1);\nvar_dump(&quot;admin1&quot;==1);\nvar_dump(&quot;admin1&quot;==0);\nvar_dump(&quot;0e123345&quot;==&quot;0e3455436&quot;);\n\nbool(true)\nbool(true)\nbool(false)\nbool(true)\nbool(true)</code></pre><p>例如<br>        <?php\n        $a=$_GET['a'];\n        if ($a==0) {\n        echo \"1\";\n        }\n        if ($a) {\n        echo \"must\";\n        }\n        ?></p>\n<p>我们传入<code>?a=a1</code>即可</p>\n<p>一些MD5后0e开头的例子</p>\n<pre><code>s878926199a\n0e545993274517709034328855841020\ns155964671a\n0e342768416822451524974117254469\ns214587387a\n0e848240448830537924465865611904\ns214587387a\n0e848240448830537924465865611904</code></pre><p>json-decode</p>\n<pre><code>&lt;?php\nif (isset($_POST[&apos;message&apos;])) {\n    $message = json_decode($_POST[&apos;message&apos;]);\n    $key =&quot;*********&quot;;\n    if ($message-&gt;key == $key) {\n        echo &quot;flag&quot;;\n        } \n    else {\n        echo &quot;fail&quot;;\n        }\n     }\n     else{\n         echo &quot;~~~~&quot;;\n }</code></pre><p>我们利用 0 = admin 的特性传入 <code>$message = {&quot;key&quot;:0}</code></p>\n<h2 id=\"当MD5与SHA1碰上数组\"><a href=\"#当MD5与SHA1碰上数组\" class=\"headerlink\" title=\"当MD5与SHA1碰上数组\"></a>当MD5与SHA1碰上数组</h2><pre><code>$a = [1];\nvar_dump(MD5($a));\nvar_dump(sha1($a));\n\nNULL\nNULL</code></pre><p>他俩碰到数组就会转换成<code>NULL</code></p>\n<h2 id=\"intval\"><a href=\"#intval\" class=\"headerlink\" title=\"intval()\"></a>intval()</h2><pre><code>&lt;?php \nvar_dump(intval(&apos;2&apos;));            //2\nvar_dump(intval(&apos;3abcd&apos;));        //3    \nvar_dump(intval(&apos;abcd&apos;));        //0\nvar_dump(intval([]));            //0    \nvar_dump(intval([&apos;a&apos;]));        //1\n ?&gt;</code></pre><p>利用intval()进行进制转换(默认是10进制)碰到头开始直到遇到一个非数字的字符。即使出现无法转换的字符串也不会报错而是返回0.碰到空数组返回0，非空返回1.</p>\n<p>可返回的最大值却决于操作系统，32 位系统最大带符号的 <code>integer</code> 范围是 <code>-2147483648</code> 到 <code>2147483647</code>。</p>\n<pre><code>var_dump(intval(&apos;10000000000000000&apos;));   //int(2147483647)</code></pre><h2 id=\"strcmp\"><a href=\"#strcmp\" class=\"headerlink\" title=\"strcmp\"></a>strcmp</h2><blockquote>\n<p>strcmp — 二进制安全字符串比较<br>如果 str1 小于 str2 返回 &lt; 0；如果 str1 大于 str2 返回 &gt; 0；如果两者相等，返回 0。</p>\n</blockquote>\n<pre><code>$password=$_GET[&apos;password&apos;];\n\nif(strcmp(&apos;am0s&apos;,$password)){\n    echo &apos;false!&apos;;\n}else{\n    echo &apos;success!&apos;;\n}</code></pre><p>我们传入<code>password[]=1</code>来绕过。</p>\n<h2 id=\"is-numeric\"><a href=\"#is-numeric\" class=\"headerlink\" title=\"is_numeric\"></a>is_numeric</h2><p>当有两个<code>is_numeric</code>判断并用<code>and</code>连接时<code>and</code>后面的<code>is_numeric</code>可以绕过</p>\n<blockquote>\n<p>is_numeric — 检测变量是否为数字或数字字符串<br>如果 var 是数字和数字字符串则返回 TRUE，否则返回 FALSE</p>\n</blockquote>\n<pre><code>var_dump(is_numeric(&apos; 45&apos;));   //bool(true)\nvar_dump(is_numeric(&apos;45 &apos;));   //bool(false)</code></pre><p>忽略前面的空格，不忽略后面的空格。</p>\n<pre><code>$a=&apos; 1&apos;;\n$b=&apos;abc&apos;;\n$c=is_numeric($a) and is_numeric($b);\nvar_dump(is_numeric($a));            //bool(true)\nvar_dump(is_numeric($b));            //bool(false)\nvar_dump($c);  //$b可以不是数字，同样返回true\nvar_dump(is_numeric(&apos;123E123&apos;));    //bool(true) 小写也可以\nvar_dump(is_numeric(&apos;+123e123&apos;));    //bool(true)    </code></pre><h2 id=\"与false比较\"><a href=\"#与false比较\" class=\"headerlink\" title=\"与false比较\"></a>与false比较</h2><pre><code>var_dump(null==false);        //bool(true)\nvar_dump(0==false);            //bool(true)    \nvar_dump(&apos;0&apos;==false);        //bool(true)\n$a[] = array(&apos; &apos; =&gt; &apos;&apos;,);\nvar_dump($a[1] == false);        //bool(true)\n?&gt;</code></pre><h2 id=\"ereg\"><a href=\"#ereg\" class=\"headerlink\" title=\"ereg\"></a>ereg</h2><blockquote>\n<p>ereg — 正则表达式匹配<br>以区分大小写的方式在 string 中寻找与给定的正则表达式 pattern 所匹配的子串。 如果找到与 pattern 中圆括号内的子模式相匹配的子串并且函数调用给出了第三个参数 regs，则匹配项将被存入 regs 数组中。$regs[1] 包含第一个左圆括号开始的子串，$regs[2] 包含第二个子串，以此类推。$regs[0] 包含整个匹配的字符串。 </p>\n</blockquote>\n<p>字符串对比解析，ereg函数存在NULL截断漏洞，当ereg读取字符串string时,如果遇到了%00,后面的字符串就不会被解析。</p>\n<pre><code>$a = &quot;djasodja%0091&quot;;\n$b[] =  array(&apos;a&apos; =&gt; &apos;abcpd&apos;, );\nvar_dump(ereg(&apos;([1-9])&apos;, $a));            //int(1)\nvar_dump(ereg(&apos;pd&apos;, $b));                //NULL</code></pre><h2 id=\"switch\"><a href=\"#switch\" class=\"headerlink\" title=\"switch\"></a>switch</h2><blockquote>\n<p>switch 语句类似于具有同一个表达式的一系列 if 语句。很多场合下需要把同一个变量（或表达式）与很多不同的值比较，并根据它等于哪个值来执行不同的代码。这正是 switch 语句的<br>用途.<br> 注意和其它语言不同，continue 语句作用到 switch 上的作用类似于 break。如果在循环中有一个 switch 并希望 continue 到外层循环中的下一轮循环，用 continue 2。<br> switch 语句一行接一行地执行（实际上是语句接语句）。开始时没有代码被执行。仅当一个 case 语句中的值和 switch 表达式的值匹配时 PHP 才开始执行语句，直到 switch 的程序段结束或者遇到第一个 break 语句为止。如果不在 case 的语句段最后写上 break 的话，PHP 将继续执行下一个 case 中的语句段.</p>\n</blockquote>\n<pre><code>&lt;?php\nswitch (true) {    //弱类型\n    case 0:\n        echo &quot;0&quot;;\n        break;\n    case 1:\n        echo &quot;1&quot;;\n        break;\n    case 2:\n        echo &quot;2&quot;;\n        break;\n}\n//1\n?&gt;\n\n&lt;?php\nswitch (0) {\n    case 0:\n        echo &quot;i equals 0&quot;;\n    case 1:\n        echo &quot;i equals 1&quot;;\n    case 2:\n        echo &quot;i equals 2&quot;;\n}\n//i equals 0    i equals 1    i equals 2\n?&gt; \n\n&lt;?php\n\nswitch (&apos;a&apos;) {  // null、false\n    case 0:\n        echo &quot;0&quot;;\n        break;\n    case 1:\n        echo &quot;1&quot;;\n        break;\n    case 2:\n        echo &quot;2&quot;;\n        break;\n}\n//输出 0\n?&gt;</code></pre><h2 id=\"strpos\"><a href=\"#strpos\" class=\"headerlink\" title=\"strpos\"></a>strpos</h2><blockquote>\n<p>strpos — 查找字符串首次出现的位置</p>\n<p>int strpos( string $haystack, mixed $needle[, int $offset = 0] )<br>返回 needle 在 haystack 中首次出现的数字位置。</p>\n<p>haystack<br>在该字符串中进行查找。 </p>\n<p>needle<br>如果 needle 不是一个字符串，那么它将被转换为整型并被视为字符的顺序值。 </p>\n<p>offset<br>如果提供了此参数，搜索会从字符串该字符数的起始位置开始统计。如果是负数，搜索会从字符串结尾指定字符数开始。<br>返回 needle 存在于 haystack 字符串起始的位置(独立于 offset)。同时注意字符串位置是从0开始，而不是从1开始的。<br>如果没找到 needle，将返回 FALSE。 </p>\n<p>7.1.0 开始支持负数的 offset。  </p>\n</blockquote>\n<p>处理数组返回NULL</p>\n<h2 id=\"array-search\"><a href=\"#array-search\" class=\"headerlink\" title=\"array_search\"></a>array_search</h2><blockquote>\n<p>array_search — 在数组中搜索给定的值，如果成功则返回首个相应的键名</p>\n<p>mixed array_search( mixed $needle, array $haystack[, bool $strict = false] )</p>\n<p>大海捞针，在大海（haystack）中搜索针（ needle 参数）。</p>\n<p>needle<br>搜索的值。<br>Note:<br>如果 needle 是字符串，则比较以区分大小写的方式进行。</p>\n<p>haystack<br>这个数组。 </p>\n<p>strict<br>如果可选的第三个参数 strict 为 TRUE，则 array_search() 将在 haystack 中检查完全相同的元素。这意味着同样严格比较 haystack 里 needle 的 类型，并且对象需是同一个实例。<br>如果找到了 needle 则返回它的键，否则返回 FALSE。 </p>\n<p>如果 needle 在 haystack 中出现不止一次，则返回第一个匹配的键。要返回所有匹配值的键，应该用 array_keys() 加上可选参数 search_value 来代替。</p>\n</blockquote>\n<pre><code>&lt;?php\nif(!is_array($_GET[&apos;test&apos;])){exit();}\n$test=$_GET[&apos;test&apos;];\nfor($i=0;$i&lt;count($test);$i++){\n    if($test[$i]===&quot;admin&quot;){\n        echo &quot;error&quot;;\n        exit();\n    }\n    $test[$i]=intval($test[$i]);\n}\nif(array_search(&quot;admin&quot;,$test)===0){\n    echo &quot;flag&quot;;\n}\nelse{\n    echo &quot;false&quot;;\n}\n?&gt;</code></pre><p>我们使用<code>test[]=0</code>来绕过。如果第三个参数设置为<code>TRUE</code>，进行严格过滤就不能绕过。</p>\n","categories":[{"name":"ctf","slug":"ctf","count":24,"path":"api/categories/ctf.json"}],"tags":[{"name":"php","slug":"php","count":7,"path":"api/tags/php.json"},{"name":"弱类型","slug":"弱类型","count":1,"path":"api/tags/弱类型.json"}]}