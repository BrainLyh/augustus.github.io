{"name":"web","slug":"web","count":1,"postlist":[{"title":"flask-session","slug":"flask-session","date":"2019-11-06T12:43:45.000Z","updated":"2019-11-06T13:12:13.785Z","comments":true,"path":"api/articles/flask-session.json","excerpt":"","keywords":null,"cover":null,"content":"<h1 id=\"flask-session\"><a href=\"#flask-session\" class=\"headerlink\" title=\"flask-session\"></a>flask-session</h1><p>11/6/2019 8:43:45 PM </p>\n<p>搬运文章 <a href=\"https://cizixs.com/2017/03/08/flask-insight-session/\" target=\"_blank\" rel=\"noopener\">https://cizixs.com/2017/03/08/flask-insight-session/</a></p>\n<p><strong>session是如何使用的：</strong></p>\n<p>cookie和session结合使用：web开发发展至今，cookie和session的使用已经出现了一些非常成熟的方案。在如今的市场或者企业里，一般有两种存储方式：</p>\n<ul>\n<li><p>存储在服务端：通过cookie存储一个<code>session_id</code>，然后具体的数据则是保存在session中。如果用户已经登录，则服务器会在cookie中保存一个<code>session_id</code>，下次再次请求的时候，会把该<code>session_id</code>携带上来，服务器根据session_id在session库中获取用户的session数据。就能知道该用户到底是谁，以及之前保存的一些状态信息。这种专业术语叫做<code>server side session</code>。</p>\n</li>\n<li><p>将session数据加密，然后存储在cookie中。这种专业术语叫做<code>client side session</code>。flask采用的就是这种方式，但是也可以替换成其他形式。</p>\n</li>\n</ul>\n<p>在解析 session 的实现之前，我们先介绍一下 session 怎么使用。session 可以看做是在不同的请求之间保存数据的方法，因为 HTTP 是无状态的协议，但是在业务应用上我们希望知道不同请求是否是同一个人发起的。比如购物网站在用户点击进入购物车的时候，服务器需要知道是哪个用户执行了这个操作。</p>\n<p>在 flask 中使用 session 也很简单，只要使用 from flask import session 导入这个变量，在代码中就能直接通过读写它和 session 交互。</p>\n<pre><code>from flask import Flask, session, escape, request\n\napp = Flask(__name__)\napp.secret_key = &apos;please-generate-a-random-secret_key&apos;\n\n\n@app.route(&quot;/&quot;)\ndef index():\n    if &apos;username&apos; in session:\n        return &apos;hello, {}\\n&apos;.format(escape(session[&apos;username&apos;]))\n    return &apos;hello, stranger\\n&apos;\n\n\n@app.route(&quot;/login&quot;, methods=[&apos;POST&apos;])\ndef login():\n    session[&apos;username&apos;] = request.form[&apos;username&apos;]\n    return &apos;login success&apos;\n\n\nif __name__ == &apos;__main__&apos;:\n    app.run(host=&apos;0.0.0.0&apos;, port=5000, debug=True)</code></pre><p>上面这段代码模拟了一个非常简单的登陆逻辑，用户访问 <code>POST /login</code> 来登陆，后面访问页面的时候 <code>GET /</code>，会返回该用户的名字</p>\n<p>直接访问：</p>\n<pre><code>GET / HTTP/1.1\nAccept: */*\nAccept-Encoding: gzip, deflate\nHost: 127.0.0.1:5000\nUser-Agent: HTTPie/0.8.0\n\n\nHTTP/1.0 200 OK\nContent-Length: 14\nContent-Type: text/html; charset=utf-8\nDate: Wed, 01 Mar 2017 04:22:18 GMT\nServer: Werkzeug/0.11.2 Python/2.7.10\n\nhello stranger</code></pre><p>用户名cizixs 模拟登录：</p>\n<pre><code>POST /login HTTP/1.1\nAccept: */*\nAccept-Encoding: gzip, deflate\nContent-Length: 15\nContent-Type: application/x-www-form-urlencoded; charset=utf-8\nHost: 127.0.0.1:5000\nUser-Agent: HTTPie/0.8.0\n\nusername=cizixs\n\nHTTP/1.0 200 OK\nContent-Length: 13\nContent-Type: text/html; charset=utf-8\nDate: Wed, 01 Mar 2017 04:20:54 GMT\nServer: Werkzeug/0.11.2 Python/2.7.10\nSet-Cookie: session=eyJ1c2VybmFtZSI6ImNpeml4cyJ9.C5fdpg.fqm3FTv0kYE2TuOyGF1mx2RuYQ4; HttpOnly; Path=/\n\nlogin success</code></pre><p>最重要的是我们看到 response 中有 <code>Set-Cookie</code> 的头部，cookie 的键是 <code>session</code></p>\n<p>这次请求我们带上上次的 cookie 访问：</p>\n<pre><code>GET / HTTP/1.1\nAccept: */*\nAccept-Encoding: gzip, deflate\nCookie: session=eyJ1c2VybmFtZSI6ImNpeml4cyJ9.C5fevg.LE03yEZDWTUMQW-nNkTr1zBEhKk\nHost: 127.0.0.1:5000\nUser-Agent: HTTPie/0.8.0\n\n\nHTTP/1.0 200 OK\nContent-Length: 11\nContent-Type: text/html; charset=utf-8\nDate: Wed, 01 Mar 2017 04:25:46 GMT\nServer: Werkzeug/0.11.2 Python/2.7.10\nSet-Cookie: session=eyJ1c2VybmFtZSI6ImNpeml4cyJ9.C5feyg.sfFCDIqfef4i8cvxUClUUGQNcHA; HttpOnly; Path=/\n\nhellocizixs</code></pre><p>可以看到我们成功的不通过用户名登陆。</p>\n<p>总结一下：session 是通过在客户端设置 cookie 实现的，每次客户端发送请求的时候会附带着所有的 cookie，而里面保存着一些重要的信息（比如这里的用户信息），这样服务器端就能知道客户端的信息，然后根据这些数据做出对应的判断，就好像不同请求之间是有记忆的。</p>\n<p><strong>请求过程</strong></p>\n<ul>\n<li>请求过来的时候，flask 会根据 cookie 信息创建出 session 变量（如果 cookie 不存在，这个变量有可能为空），保存在该请求的上下文中</li>\n<li>视图函数可以获取 session 中的信息，实现自己的逻辑处理</li>\n<li>flask 会在发送 response 的时候，根据 session 的值，把它写回到 cookie 中</li>\n</ul>\n<p>注意：session 和 cookie 的转化过程中，应该考虑到安全性，不然直接使用伪造的 cookie 会是个很大的安全隐患。</p>\n<p><strong>加密session</strong></p>\n<p>搬运<a href=\"https://www.leavesongs.com/PENETRATION/client-session-security.html\" target=\"_blank\" rel=\"noopener\">https://www.leavesongs.com/PENETRATION/client-session-security.html</a></p>\n<p>flask 处理 session 安全性问题时在代码中新建了 <code>URLSafeTimedSerializer</code> 类 ，用它的dumps方法将类型为字典的 <code>session</code> 对象序列化成字符串，然后用 <code>response.set_cookie</code> 将最后的内容保存在cookie中。 </p>\n<p><code>URLSafeTimedSerializer</code> 做了什么？主要经过几步</p>\n<ul>\n<li>json.dumps 将对象转换成json字符串，作为数据</li>\n<li>如果数据压缩后长度更短，则用zlib库进行压缩</li>\n<li>将数据用base64编码</li>\n<li>通过hmac算法计算数据的签名，将签名附在数据后，用“.”分割</li>\n</ul>\n<p>第4步就解决了用户篡改session的问题，因为在不知道 <code>secret_key</code> 的情况下，是无法伪造签名的。注意到，在第4步中，flask仅仅对数据进行了签名。众所周知的是，签名的作用是防篡改，而无法防止被读取。而flask并没有提供加密操作，所以其 session 的全部内容都是可以在客户端读取的，这就可能造成一些安全问题。</p>\n<p><strong>解密session</strong></p>\n<p>有时候在开发或者调试的过程中，需要了解 cookie 中保存的到底是什么值，可以通过手动解析它的值。session 在 cookie 中的值，是一个字符串，由句号分割成三个部分。第一部分是 base64 加密的数据，第二部分是时间戳，第三部分是校验信息。</p>\n<p>前面两部分的内容可以通过下面的方式获取，代码也可直观，就不给出解释了：</p>\n<pre><code>In [1]: from itsdangerous import *\n\nIn [2]: s = &apos;eyJ1c2VybmFtZSI6ImNpeml4cyJ9.C5fdpg.fqm3FTv0kYE2TuOyGF1mx2RuYQ4&apos;\n\nIn [3]: data, timstamp, secret = s.split(&apos;.&apos;)\n\nIn [4]: base64_decode(data)\nOut[4]: &apos;{&quot;username&quot;:&quot;cizixs&quot;}&apos;\n\nIn [5]: bytes_to_int(base64_decode(timstamp))\nOut[5]: 194502054\n\nIn [7]: time.strftime(&apos;%Y-%m-%d %H:%I%S&apos;, time.localtime(194502054+EPOCH))\nOut[7]: &apos;2017-03-01 12:1254&apos;</code></pre><p><strong>session使用</strong></p>\n<p>上面看到 session 其实就像一个字典，我们使用的时候可以直接使用：</p>\n<pre><code>session[&apos;name&apos;] = name</code></pre>","text":"flask-session11/6/2019 8:43:45 PM 搬运文章 https://cizixs.com/2017/03/08/flask-insight-session/session是如何使用的：cookie和session结合使用：web开发发展至今，cookie","link":"","raw":null,"photos":[],"categories":[{"name":"web","slug":"web","count":1,"path":"api/categories/web.json"}],"tags":[{"name":"flask","slug":"flask","count":1,"path":"api/tags/flask.json"}]}]}