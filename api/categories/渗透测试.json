{"name":"渗透测试","slug":"渗透测试","count":5,"postlist":[{"title":"CSRF 简单认识","slug":"CSRF-简单学习","date":"2019-12-22T03:47:20.000Z","updated":"2019-12-22T04:22:38.699Z","comments":true,"path":"api/articles/CSRF-简单学习.json","excerpt":"","keywords":null,"cover":"https://wx3.sinaimg.cn/small/006boCb9ly1ga5drxec7uj30su014jr9.jpg","content":"<h1 id=\"CSRF-简单认识\"><a href=\"#CSRF-简单认识\" class=\"headerlink\" title=\"CSRF 简单认识\"></a>CSRF 简单认识</h1><p>12/22/2019 11:47:20 AM </p>\n<h2 id=\"什么是CSRF\"><a href=\"#什么是CSRF\" class=\"headerlink\" title=\"什么是CSRF\"></a>什么是CSRF</h2><p>跨站请求伪造-Cross Site Request Forgery，也被称作XSRF，简单来说就是 攻击者在不知道某个账户账号密码的情况下，利用目标站点已经登陆过的账户产生的身份凭证信息(cookie)来进行一系列操作，同时该站点认为攻击者所采取的动作都是合法的(因为攻击者盗用了认证通过的账户账号信息)。</p>\n<h2 id=\"漏洞利用\"><a href=\"#漏洞利用\" class=\"headerlink\" title=\"漏洞利用\"></a>漏洞利用</h2><p>如果对于某个网站的删除文章功能的代码是 </p>\n<pre><code>&lt;a href=&apos;/delete?id=3&apos;&gt;刪除&lt;/a&gt;</code></pre><p>然后在后端做校验，验证 requests 有没有带 session_id ,同时确认是不是这个文章的作者。此时，假如攻击者通过钓鱼，创建了一个有针对性的网页，里面的按钮的代码是：</p>\n<pre><code>&lt;a href=&apos;https://small-min.blog.com/delete?id=3&apos;&gt;開始測驗&lt;/a&gt;</code></pre><p>如果这时文章作者点击了按钮，那么由于浏览器的跨域请求机制(在浏览器进程的生命周期内，即使浏览器打开了新的Tab页，Session Cookie 也是有效的。Session Cookie 保存在浏览器内存空间内)会把作者的cookie一起带到GET请求中，服务端检查到确实是作者，于是文章被删除了。</p>\n<p>如果禁用了 <code>&lt;img&gt; 、 &lt;iframe&gt; 、 &lt;script&gt;</code> 等带 src 属性的标签，就可以禁止 CSRF 了？这类标签只能发起一次 GET 请求，而不能发起 POST 请求。但是 <code>form</code> 标签可以发送 POST request.</p>\n<pre><code>&lt;form action=&quot;https://small-min.blog.com/delete&quot; method=&quot;POST&quot;&gt;\n  &lt;input type=&quot;hidden&quot; name=&quot;id&quot; value=&quot;3&quot;/&gt;\n  &lt;input type=&quot;submit&quot; value=&quot;開始測驗&quot;/&gt;\n&lt;/form&gt;</code></pre><p>这样还是显式的，我们可以采用更隐蔽的方式</p>\n<pre><code>&lt;iframe style=&quot;display:none&quot; name=&quot;csrf-frame&quot;&gt;&lt;/iframe&gt;\n&lt;form method=&apos;POST&apos; action=&apos;https://small-min.blog.com/delete&apos; target=&quot;csrf-frame&quot; id=&quot;csrf-form&quot;&gt;\n  &lt;input type=&apos;hidden&apos; name=&apos;id&apos; value=&apos;3&apos;&gt;\n  &lt;input type=&apos;submit&apos; value=&apos;submit&apos;&gt;\n&lt;/form&gt;\n&lt;script&gt;document.getElementById(&quot;csrf-form&quot;).submit()&lt;/script&gt;</code></pre><p>在某些页面中可能进行了 referer 检查，但是我们也要检测是否存在逻辑问题：</p>\n<ol>\n<li>Referer 过滤不严谨</li>\n</ol>\n<p>比如我构造了一个表单 <strong>register</strong></p>\n<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;csrf test&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;form action=&quot;../csrf/server.php&quot; id= &quot;regesiter&quot; method=&quot;post&quot;&gt;\n    &lt;input type=&quot;text&quot; name=&quot;username&quot; value=&quot;&quot; /&gt;\n    &lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;submit&quot; /&gt;\n&lt;/form&gt;\n&lt;/body&gt;\n&lt;/html&gt;</code></pre><p>在 server.php 中我对 referer 进行了检测，如果含有 qq.com 我就可以认为是合法的，但是如果我采取以下的请求方式：</p>\n<p><img src=\"https://wx3.sinaimg.cn/small/006boCb9ly1ga5drxec7uj30su014jr9.jpg\" alt=\"构造请求\"></p>\n<p><img src=\"https://wx4.sinaimg.cn/small/006boCb9ly1ga5druqi6ej30df047glu.jpg\" alt=\"referer已经含有关键词\"></p>\n<ol start=\"2\">\n<li>空referer</li>\n</ol>\n<p>某些浏览器的防御部署是允许空 REFERER 的。</p>\n<p>还可以使用 burp 自带的 generate CSRF poc,选择测试 URL 右键选择生成 CSRF poc,将要替换的值然后保存访问即可。</p>\n<p>还可以使用 CSRFTester 软件来测试</p>\n<h2 id=\"漏洞检测\"><a href=\"#漏洞检测\" class=\"headerlink\" title=\"漏洞检测\"></a>漏洞检测</h2><ol>\n<li>GET</li>\n</ol>\n<p>如果带有 token 等验证参数，先去掉参数尝试能否正常请求，如果可以即存在 CSRF 漏洞。</p>\n<ol start=\"2\">\n<li>POST</li>\n</ol>\n<p>最简单的方法就是抓取一个正常请求的数据包，去掉 token 等验证参数后提交，如果正常访问，再去掉 Referer 后重新提交，如果提交还有效，那么基本可以认为存在 CSRF 漏洞，可以构造外部 form 表单来进行提交。如果去掉 referer 失败还可以验证对 referer 校验是否严格尝试绕过。也可能存在代码对请求类型判断不严格($_REQUEST[])，如果 post 失败了尝试改成 get 进行请求。 </p>\n<h2 id=\"防御\"><a href=\"#防御\" class=\"headerlink\" title=\"防御\"></a>防御</h2><h3 id=\"验证码\"><a href=\"#验证码\" class=\"headerlink\" title=\"验证码\"></a>验证码</h3><p>强制用户必须与应用完成交互，避免在不知情的情况下构造网络请求</p>\n<h3 id=\"Referer-Check\"><a href=\"#Referer-Check\" class=\"headerlink\" title=\"Referer Check\"></a>Referer Check</h3><p>检查请求是否来自合法的源，但是不足之处在于浏览器并非什么时候都能取到Referer.</p>\n<h3 id=\"Anti-CSRF-Token\"><a href=\"#Anti-CSRF-Token\" class=\"headerlink\" title=\"Anti CSRF Token\"></a>Anti CSRF Token</h3><p>将参数加密，或者使用一些真随机数，让攻击者无法猜测到参数值，达到“不可预测性原则”。可以新加一个参数 TOKEN ，同时放在表单和 session 中，服务端只需验证表单中的 TOKEN 和 session 中的 Token 是否一致，一致则认为是合法请求。 </p>\n","text":"CSRF 简单认识12/22/2019 11:47:20 AM 什么是CSRF跨站请求伪造-Cross Site Request Forgery，也被称作XSRF，简单来说就是 攻击者在不知道某个账户账号密码的情况下，利用目标站点已经登陆过的账户产生的身份凭证信息(cookie)","link":"","raw":null,"photos":[],"categories":[{"name":"渗透测试","slug":"渗透测试","count":5,"path":"api/categories/渗透测试.json"}],"tags":[{"name":"CSRF","slug":"CSRF","count":1,"path":"api/tags/CSRF.json"}]},{"title":"Nessus 使用指南","slug":"Nessus使用指南","date":"2018-02-23T07:13:47.000Z","updated":"2019-08-01T11:52:12.324Z","comments":true,"path":"api/articles/Nessus使用指南.json","excerpt":"<p>NESSUS 是目前全世界最多人使用的系统漏洞扫描与分析软件。总共有超过75,000个机构使用NESSUS 作为扫描该机构电脑系统的软件。</p>","keywords":null,"cover":"https://i.imgur.com/UKPKn8z.png","content":null,"text":"NESSUS 是目前全世界最多人使用的系统漏洞扫描与分析软件。总共有超过75,000个机构使用NESSUS 作为扫描该机构电脑系统的软件。Nessus 使用指南0x01创建策略进入主页面后点击policies [Figure] 结语Nessus是一款非常强大的漏洞扫描与分析软件，","link":"","raw":null,"photos":[],"categories":[{"name":"渗透测试","slug":"渗透测试","count":5,"path":"api/categories/渗透测试.json"}],"tags":[{"name":"工具","slug":"工具","count":1,"path":"api/tags/工具.json"},{"name":"渗透测试","slug":"渗透测试","count":3,"path":"api/tags/渗透测试.json"}]},{"title":"APP Penetration testing","slug":"Penetration-testing","date":"2019-12-25T12:56:41.000Z","updated":"2020-04-29T05:44:52.700Z","comments":true,"path":"api/articles/Penetration-testing.json","excerpt":"","keywords":null,"cover":"https://wx3.sinaimg.cn/mw690/006boCb9ly1ga98w5qqs0j30ne0j9abm.jpg","content":"<h1 id=\"记一次授权的APK渗透测试\"><a href=\"#记一次授权的APK渗透测试\" class=\"headerlink\" title=\"记一次授权的APK渗透测试\"></a>记一次授权的APK渗透测试</h1><p>作为一个渗透测试小白，本文的目的是希望能为那些和我一样的小白提供一些测试思路。</p>\n<p>涉及的内容可能比较基础，表哥们见谅。</p>\n<h2 id=\"APK-解包\"><a href=\"#APK-解包\" class=\"headerlink\" title=\"APK 解包\"></a>APK 解包</h2><p>拿到 apk 之后直接用 7-Zip 解压可以得到几个文件夹、一个 <strong>AndroidManifest.xml</strong> 文件、一个dex文件。使用 dex2jar <a href=\"https://sourceforge.net/projects/dex2jar/\" title=\"工具\" target=\"_blank\" rel=\"noopener\">https://sourceforge.net/projects/dex2jar/</a> 将这个dex文件解压会生成一个jar文件，然后使用jd-gui就可以查看java源代码了。</p>\n<p>当然可以从源码里找代码的漏洞，但是一般会有混淆，在这也不做深入讨论。</p>\n<p>上边提到的 xml 文件一定不能发放过，里边涉及到许多重要的配置项，比如：</p>\n<ul>\n<li>AndroidManifest.xml文件中android:debuggable为true。app 可被任意调试</li>\n<li>AndroidManifest.xml文件中android: allowBackup为true。app 数据可以被备份导出。</li>\n<li>等等…</li>\n</ul>\n<p>还有一点在实际测试过程中可能会用到：在对 apk 解压之后可以尝试在 powershell 里边搜一下 <code>db</code> 文件，说不定有敏感信息(为什么这么说，因为我碰到过一次…)</p>\n<pre><code>for /r F:\\source-code %i in (*.db) do echo %i </code></pre><h2 id=\"登陆页面\"><a href=\"#登陆页面\" class=\"headerlink\" title=\"登陆页面\"></a>登陆页面</h2><h3 id=\"用户名可枚举\"><a href=\"#用户名可枚举\" class=\"headerlink\" title=\"用户名可枚举\"></a>用户名可枚举</h3><p>输入用户名之后响应用户名不存在，这就是最简单的枚举用户名的情形了。</p>\n<p>这次碰到的是登陆不需要密码，但是要输入已经注册过的用户名，之后会根据用户名发送验证码到对应手机，同时设置了 120s 内不能重新发送，并且验证码 120s 内有效。</p>\n<p>这时候看起来我们没办法通过验证码做什么事，但是在实际测试过程中发现</p>\n<ol>\n<li><p>当我们输入存在的账号之后提示发送成功；</p>\n</li>\n<li><p>重复发送，会响应 120s 内不能重复发送；</p>\n</li>\n<li><p>输入不存在用户会提示发送失败。</p>\n</li>\n</ol>\n<p>所以这个时间限制对用户名枚举其实没什么影响，我们可以通过爆破用户名根据返回的信息来查看用户名是否存在。</p>\n<p><img src=\"https://wx3.sinaimg.cn/mw690/006boCb9ly1ga98w5qqs0j30ne0j9abm.jpg\" alt=\"枚举用户\"></p>\n<p>等等，既然咱都不知道手机号，也不让输密码登陆，就算得到用户名生成社工字典也没法用啊，那拿到了用户名有什么用？</p>\n<p>当然有用，不过要看具体场景，比如下面这个案例</p>\n<h3 id=\"任意验证码绕过\"><a href=\"#任意验证码绕过\" class=\"headerlink\" title=\"任意验证码绕过\"></a>任意验证码绕过</h3><p>当我们登陆时服务端给账号绑定的手机号发送短信验证码，我们输入一个上一步得到的账号，验证码随便输，点击登陆后抓包，登陆失败，发现响应中有两个 code 字段</p>\n<p><img src=\"https://wx3.sinaimg.cn/mw690/006boCb9ly1ga98w9rlloj30l2070aaa.jpg\" alt></p>\n<p>改改试试：</p>\n<p><img src=\"https://wx1.sinaimg.cn/mw690/006boCb9ly1ga98wgjh7kj30is057mx6.jpg\" alt></p>\n<p><strong>It works!</strong></p>\n<h2 id=\"功能页面\"><a href=\"#功能页面\" class=\"headerlink\" title=\"功能页面\"></a>功能页面</h2><p>成功登录之后，各个功能都点点看看，在个人信息页面有一个查询实时在线人数功能，那一栏只显示了人数，旁边并没有箭头</p>\n<p><img src=\"https://wx3.sinaimg.cn/mw690/006boCb9ly1ga98wd0il6j307n04bdfo.jpg\" alt></p>\n<p>我一度以为那里不能点击(事实上因为数据量太大，加载了好长时间，我直接点返回了，给我的感觉就是这里没有东西)，进去之后就可以看到所有登陆人员的信息了。</p>\n<p><img src=\"https://wx3.sinaimg.cn/mw690/006boCb9ly1ga98voejstj30qf09pdh7.jpg\" alt=\"图打码水平实在不够\"></p>\n<p>在我尝试了不同用户之后，发现这里的用户信息并没有权限限制，也就是说对所有人都是可见的，明显的权限配置不当。</p>\n<p>除此之外，应用存在几处查询功能，通过BURP 看到返回的数据包都是 JSON 类型</p>\n<p><img src=\"https://wx3.sinaimg.cn/mw690/006boCb9ly1ga98wmervqj30m404vt90.jpg\" alt></p>\n<p>因为没什么经验，所以就多尝试吗，在 json 那里注入，xxe 都来一遍，没啥用。</p>\n<p>前面还有一个参数，试试？</p>\n<p><img src=\"https://wx4.sinaimg.cn/mw690/006boCb9ly1ga98x8llxwj30q203f74b.jpg\" alt></p>\n<p>有戏！</p>\n<p>试试 xss 吧</p>\n<p><img src=\"https://wx2.sinaimg.cn/mw690/006boCb9ly1ga98xbyv4fj30q002q74d.jpg\" alt></p>\n<p>放到浏览器成功弹窗！</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>平时做测试还是要细心，多总结，每一个能输入的地方都不能放过，多试试总是好的。</p>\n","text":"记一次授权的APK渗透测试作为一个渗透测试小白，本文的目的是希望能为那些和我一样的小白提供一些测试思路。涉及的内容可能比较基础，表哥们见谅。APK 解包拿到 apk 之后直接用 7-Zip 解压可以得到几个文件夹、一个 AndroidManifest.xml 文件、一个dex文件","link":"","raw":null,"photos":[],"categories":[{"name":"渗透测试","slug":"渗透测试","count":5,"path":"api/categories/渗透测试.json"}],"tags":[{"name":"APK","slug":"APK","count":1,"path":"api/tags/APK.json"}]},{"title":"渗透测试-信息收集","slug":"渗透测试-信息收集","date":"2018-03-23T07:13:47.000Z","updated":"2019-08-01T11:47:56.375Z","comments":true,"path":"api/articles/渗透测试-信息收集.json","excerpt":"<p>Google-hacking</p>","keywords":null,"cover":null,"content":null,"text":"Google-hacking渗透测试-信息收集0x0 Google-hacking常用GoogleHacking语法intext:(only google)把网页中的正文内容中的某个字符作为搜索条件intitle:把网页标题中的某个字符作为搜索的条件cache：搜索搜索引擎里关于","link":"","raw":null,"photos":[],"categories":[{"name":"渗透测试","slug":"渗透测试","count":5,"path":"api/categories/渗透测试.json"}],"tags":[{"name":"渗透测试","slug":"渗透测试","count":3,"path":"api/tags/渗透测试.json"}]},{"title":"snort 安全防御","slug":"snort-安全防御","date":"2019-11-24T14:57:59.000Z","updated":"2019-12-01T12:57:42.268Z","comments":true,"path":"api/articles/snort-安全防御.json","excerpt":"","keywords":null,"cover":null,"content":"<h1 id=\"安全防御-snort\"><a href=\"#安全防御-snort\" class=\"headerlink\" title=\"安全防御-snort\"></a>安全防御-snort</h1><p>Snort IDS（入侵检测系统）是一个强大的网络入侵检测系统。它具有实时数据流量分析和记录IP网络数据包的能力，能够进行协议分析，对网络数据包内容进行搜索/匹配。它能够检测各种不同的攻击方式，对攻击进行实时报警。此外，Snort是开源的入侵检测系统，并具有很好的扩展性和可移植性。</p>\n<h2 id=\"Snort-简介\"><a href=\"#Snort-简介\" class=\"headerlink\" title=\"Snort 简介\"></a>Snort 简介</h2><h3 id=\"snort体系结构\"><a href=\"#snort体系结构\" class=\"headerlink\" title=\"snort体系结构\"></a>snort体系结构</h3><p>Snort的结构由4大软件模块组成，它们分别是：</p>\n<ol>\n<li>数据包嗅探模块——负责监听网络数据包，对网络进行分；</li>\n<li>预处理模块——该模块用相应的插件来检查原始数据包，从中发现原始数据的“行为”，如端口扫描，IP碎片等，数据包经过预处理后才传到检测引擎；</li>\n<li>检测模块——该模块是Snort的核心模块。当数据包从预处理器送过来后，检测引擎依据预先设置的规则检查数据包，一旦发现数据包中的内容和某条规则相匹配，就通知报警模块；</li>\n<li>报警/日志模块——经检测引擎检查后的Snort数据需要以某种方式输出。如果检测引擎中的某条规则被匹配，则会触发一条报警，这条报警信息会通过网络、UNIXsocket、WindowsPopu(SMB)、SNMP协议的trap命令传送给日志文件，甚至可以将报警传送给第三方插件（如SnortSam），另外报警信息也可以记入SQL数据库。</li>\n</ol>\n<h3 id=\"snort三种工作方式\"><a href=\"#snort三种工作方式\" class=\"headerlink\" title=\"snort三种工作方式\"></a>snort三种工作方式</h3><p>Snort拥有三大基本功能：嗅探器、数据包记录器和入侵检测。</p>\n<ol>\n<li>嗅探器模式仅从网络上读取数据包并作为连续不断的流显示在终端上，常用命令snort -v。使用这个命令将使snort只输出IP/TCP/UDP/ICMP的包头信息</li>\n<li>数据包记录器模式是把数据包记录到硬盘上，常用命令snort –l 指定一个目录。这会将所有的包记录到硬盘上。</li>\n<li>网络入侵检测模式是最复杂的，而且是可配置的。我们可以让Snort分析网络数据流以匹配用户定义的一些规则，并根据检测结果采取一定的动作。</li>\n</ol>\n<h2 id=\"如何使用0x01\"><a href=\"#如何使用0x01\" class=\"headerlink\" title=\"如何使用0x01\"></a>如何使用0x01</h2><h3 id=\"snort-规则定义\"><a href=\"#snort-规则定义\" class=\"headerlink\" title=\"snort 规则定义\"></a>snort 规则定义</h3><p>Snort使用一种简单的规则描述语言，这种描述语言易于扩展，功能也比较强大。<br>Snort规则是基于文本的，规则文件按照不同的组进行分类，比如，文件<code>ftp.rules</code>包含了FTP攻击内容。<br>「注」Snort的每条规则必须在一行中，它的规则解释器无法对跨行的规则进行解析。Snort的每条规则都可以分成逻辑上的两个部分：<strong>规则头和规则体</strong>。</p>\n<p>规则头包括4个部分：<strong>规则行为；协议；源信息；目的信息</strong>。</p>\n<p>snort规则头Snort预置的规则动作有5种：</p>\n<ol>\n<li>pass—动作选项pass将忽略当前的包，后继捕获的包将被继续分析。</li>\n<li>log—动作选项log将按照自己配置的格式记录包。</li>\n<li>alert—动作选项alert将按照自己配置的格式记录包，然后进行报警。它的功能强大，但是必须恰当的用，因为如果报警记录过多，从中攫取有效信息的工作量增大，反而会使安全防护工作变得低效。</li>\n<li>dynamic—动作选项dynamic是比较独特的一种，它保持在一种潜伏状态，直到activate类型的规则将其触发，之后它将像log动作一样记录数据包。</li>\n<li>activate—动作选项activate功能强大，当被规则触发时生成报警，并启动相关的dynamic类型规则。在检测复杂的攻击，或对数据进行归类时，该动作选项相当有用。除了以上5种预置的规则动作类型，用户还可以定制自己的类型。</li>\n</ol>\n<p>规则体的作用是在规则头信息的基础上进一步分析，有了它才能确认复杂的攻击(Snort的规则定义中可以没有规则体)。规则体由若干个被分别隔开的片断组成，每个片断定义了一个选项和相应的选项值。一部分选项是对各种协议的详细说明，包括IP、ICMP和TCP协议，其余的选项是：规则触发时提供给管理员的参考信息，被搜索的关键字，Snort规则的标识和大小写不敏感选项。下面是一个规则实例。</p>\n<pre><code>alert tcp !192.168.43.0/24 any -&gt;any 21 (content:&quot;USER&quot;;msg: &quot;FTP Login&quot;;)</code></pre><ol>\n<li><code>alert</code>表示规则动作为报警。                                         </li>\n<li><code>tcp</code>表示协议类型为TCP协议。 </li>\n<li><code>!192.168.0.1/24</code>表示源IP地址不是192.168.0.1/24。 </li>\n<li>第一个<code>any</code>表示源端口为任意端口。                            </li>\n<li><code>-&gt;</code>表示发送方向操作符，方向操作符左边的ip地址和端口号被认为是流来自的源主机</li>\n<li>第二个any表示目的IP地址为任意IP地址。</li>\n<li>21表示目的端口为21。 </li>\n<li><code>content:&quot;USER&quot;</code>表示匹配的字符串为“USER”。      </li>\n<li><code>msg:&quot;FTPLogin&quot;</code>表示报警信息为“FTPLogin”</li>\n</ol>\n<p>预处理器在调用检测引擎之前，在数据包被解码之后运行。通过这种机制，Snort可以以一种<code>out of band</code>的方式对数据包进行修改或者分析。<br>预处理器可以使用<code>preprocessor</code>关键词来加载和配置，常用到的预处理器如下:</p>\n<ol>\n<li><code>HTTPdecode</code>预处器HTTP解码预处理模块用来处理HTTPURL字符串，把它们转换为清晰的ASCII字符串。</li>\n<li>端口扫描器<code>portscan</code>端口扫描器会把由单个源IP地址发起的端口扫描从开始到结束的全过程记录到标准日志。</li>\n<li><code>stream</code>处理器stream处理器为snort提供了TCP数据包重组的功能。在配置的端口上，stream处理器能够对TCP数据包的细小片段进行重组，使之成为完整的TCP数据包，然后snort可以对其可疑行为进行检查。</li>\n<li><code>frag2</code>处理器frag2预处理器为snort提供了IP分片重组的功能。frag2预处理器能够对分片包进行重组来定位分片攻击，它的工作原理是将所有的分片重组构造成一个包含完整信息的数据包，再将这个包传给检测引擎。</li>\n</ol>\n<h3 id=\"编写规则\"><a href=\"#编写规则\" class=\"headerlink\" title=\"编写规则\"></a>编写规则</h3><p>我们在使用开始前一定要注意选择好网卡，在snort.exe文件所在目录用<code>snort -W</code>查看系统可用网络接口。记住需要监视的网卡的编号，比如为2，那么在以后的使用中，用<code>-i 2</code>就可以选择对应的网卡。</p>\n<p>我们先新建规则</p>\n<pre><code>alert icmp any any -&gt; 192.168.43.137 any (msg:＂ICMP PING＂;sid:10000)</code></pre><p>ip地址是我的主机ip。这条规则的意思就是 对来自任何地址的<code>icmp</code>数据包发出警告信息.</p>\n<p>执行命令：</p>\n<pre><code>snort -i 2 -c ../etc/snort.conf -l ./log</code></pre><p>我们将编写的规则写入<code>snort.conf</code>中，在这里我们需要 <code>-c</code> 来指定我们用的规则，并将日志记录到 log 文件加中。</p>\n<p>日志是二进制保存的，对于查看日志文件我们需要执行</p>\n<pre><code>snort -dvr snort.log.xxxx</code></pre><h2 id=\"如何使用0x02\"><a href=\"#如何使用0x02\" class=\"headerlink\" title=\"如何使用0x02\"></a>如何使用0x02</h2><h3 id=\"使用-snort-检测局域网内-sqlmap-行为\"><a href=\"#使用-snort-检测局域网内-sqlmap-行为\" class=\"headerlink\" title=\"使用 snort 检测局域网内 sqlmap 行为\"></a>使用 snort 检测局域网内 sqlmap 行为</h3><p>先编写规则</p>\n<pre><code>alert any any -&gt; any any (msg:&quot;webscan sqlmap&quot;;content:&quot;sqlmap&quot;;sid=10000;classtype:webscan;rev=1)</code></pre><p>在 <code>classification.conf</code> 中添加 webscan 类型的规则</p>\n<pre><code>config classfiction 描述，描述，危险等级\nconfig classification:shortname,short description,priority\nconfig classification: webscan,webscan sqlmap,1</code></pre><p>在 <code>sid-msg.map</code> 中添加预定义描述</p>\n<pre><code>10000 || webscan sqlmap detected || mcafee,98775</code></pre><p>本地起 dvwa 之后使用 low 级别的 sql注入 ，将payload放入sqlmap，随后打开snort进行监听发现了sqlmap行为。</p>\n<p>但是这里存在问题，snort 在UA头里检测到了 sqlmap 字符串，然后打印了警告信息，这样的检测不够严谨，因为我们如果在 sql 注入的地方填入sqlmap它同样会触发 snort 警告。</p>\n<p>我们修改原来的规则为</p>\n<pre><code>alert any any -&gt; any any (msg:&quot;webscan sqlmap&quot;;content:&quot;User-Agent: sqlmap/&quot;;sid=10000;classtype:webscan;rev=2)</code></pre><p>此时我们就能针对 UA 头进行监测(rev也加一，跟之前的记录进行区分)。</p>\n<p>但是 sqlmap 其实可以绕过 UA 头的检测，我们在 sqlmap 中添加 <code>random-agent</code> 参数，就可以使用不同的 UA 。</p>\n<p>另外，在使用规则时我们也可以通过添加多个 content 来进行检测：</p>\n<pre><code>alert any any -&gt; any any (msg:&quot;webscan sqlmap&quot;;content:&quot;and&quot;;content:&quot;=&quot;;sid=10001;classtype:webscan;rev=2)</code></pre><p>这样在匹配到两个关键词时就会触发警告。</p>\n<p>对于其他的攻击，我们可以通过访问日志来抓取不同的请求，然后添加到对应的规则里。</p>\n<p>除此之外，我们还可以制定一个依据访问频率的规则：</p>\n<pre><code>alert any any -&gt; any any (msg:&quot;too many access&quot;;content:&quot;192.168.10.132/login.php&quot;;detection_filter:count 3, second 300,track by_src;sid=10002;classtype:webscan;rev=1)</code></pre><p>这样5分钟内发出三次请求就会被检测到。</p>\n","text":"安全防御-snortSnort IDS（入侵检测系统）是一个强大的网络入侵检测系统。它具有实时数据流量分析和记录IP网络数据包的能力，能够进行协议分析，对网络数据包内容进行搜索/匹配。它能够检测各种不同的攻击方式，对攻击进行实时报警。此外，Snort是开源的入侵检测系统，并具有很","link":"","raw":null,"photos":[],"categories":[{"name":"渗透测试","slug":"渗透测试","count":5,"path":"api/categories/渗透测试.json"}],"tags":[{"name":"渗透测试","slug":"渗透测试","count":3,"path":"api/tags/渗透测试.json"}]}]}