{"name":"CSRF","slug":"CSRF","count":1,"postlist":[{"title":"CSRF 简单认识","slug":"CSRF-简单学习","date":"2019-12-22T03:47:20.000Z","updated":"2019-12-22T04:22:38.699Z","comments":true,"path":"api/articles/CSRF-简单学习.json","excerpt":"","keywords":null,"cover":"https://wx3.sinaimg.cn/small/006boCb9ly1ga5drxec7uj30su014jr9.jpg","content":"<h1 id=\"CSRF-简单认识\"><a href=\"#CSRF-简单认识\" class=\"headerlink\" title=\"CSRF 简单认识\"></a>CSRF 简单认识</h1><p>12/22/2019 11:47:20 AM </p>\n<h2 id=\"什么是CSRF\"><a href=\"#什么是CSRF\" class=\"headerlink\" title=\"什么是CSRF\"></a>什么是CSRF</h2><p>跨站请求伪造-Cross Site Request Forgery，也被称作XSRF，简单来说就是 攻击者在不知道某个账户账号密码的情况下，利用目标站点已经登陆过的账户产生的身份凭证信息(cookie)来进行一系列操作，同时该站点认为攻击者所采取的动作都是合法的(因为攻击者盗用了认证通过的账户账号信息)。</p>\n<h2 id=\"漏洞利用\"><a href=\"#漏洞利用\" class=\"headerlink\" title=\"漏洞利用\"></a>漏洞利用</h2><p>如果对于某个网站的删除文章功能的代码是 </p>\n<pre><code>&lt;a href=&apos;/delete?id=3&apos;&gt;刪除&lt;/a&gt;</code></pre><p>然后在后端做校验，验证 requests 有没有带 session_id ,同时确认是不是这个文章的作者。此时，假如攻击者通过钓鱼，创建了一个有针对性的网页，里面的按钮的代码是：</p>\n<pre><code>&lt;a href=&apos;https://small-min.blog.com/delete?id=3&apos;&gt;開始測驗&lt;/a&gt;</code></pre><p>如果这时文章作者点击了按钮，那么由于浏览器的跨域请求机制(在浏览器进程的生命周期内，即使浏览器打开了新的Tab页，Session Cookie 也是有效的。Session Cookie 保存在浏览器内存空间内)会把作者的cookie一起带到GET请求中，服务端检查到确实是作者，于是文章被删除了。</p>\n<p>如果禁用了 <code>&lt;img&gt; 、 &lt;iframe&gt; 、 &lt;script&gt;</code> 等带 src 属性的标签，就可以禁止 CSRF 了？这类标签只能发起一次 GET 请求，而不能发起 POST 请求。但是 <code>form</code> 标签可以发送 POST request.</p>\n<pre><code>&lt;form action=&quot;https://small-min.blog.com/delete&quot; method=&quot;POST&quot;&gt;\n  &lt;input type=&quot;hidden&quot; name=&quot;id&quot; value=&quot;3&quot;/&gt;\n  &lt;input type=&quot;submit&quot; value=&quot;開始測驗&quot;/&gt;\n&lt;/form&gt;</code></pre><p>这样还是显式的，我们可以采用更隐蔽的方式</p>\n<pre><code>&lt;iframe style=&quot;display:none&quot; name=&quot;csrf-frame&quot;&gt;&lt;/iframe&gt;\n&lt;form method=&apos;POST&apos; action=&apos;https://small-min.blog.com/delete&apos; target=&quot;csrf-frame&quot; id=&quot;csrf-form&quot;&gt;\n  &lt;input type=&apos;hidden&apos; name=&apos;id&apos; value=&apos;3&apos;&gt;\n  &lt;input type=&apos;submit&apos; value=&apos;submit&apos;&gt;\n&lt;/form&gt;\n&lt;script&gt;document.getElementById(&quot;csrf-form&quot;).submit()&lt;/script&gt;</code></pre><p>在某些页面中可能进行了 referer 检查，但是我们也要检测是否存在逻辑问题：</p>\n<ol>\n<li>Referer 过滤不严谨</li>\n</ol>\n<p>比如我构造了一个表单 <strong>register</strong></p>\n<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;csrf test&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;form action=&quot;../csrf/server.php&quot; id= &quot;regesiter&quot; method=&quot;post&quot;&gt;\n    &lt;input type=&quot;text&quot; name=&quot;username&quot; value=&quot;&quot; /&gt;\n    &lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;submit&quot; /&gt;\n&lt;/form&gt;\n&lt;/body&gt;\n&lt;/html&gt;</code></pre><p>在 server.php 中我对 referer 进行了检测，如果含有 qq.com 我就可以认为是合法的，但是如果我采取以下的请求方式：</p>\n<p><img src=\"https://wx3.sinaimg.cn/small/006boCb9ly1ga5drxec7uj30su014jr9.jpg\" alt=\"构造请求\"></p>\n<p><img src=\"https://wx4.sinaimg.cn/small/006boCb9ly1ga5druqi6ej30df047glu.jpg\" alt=\"referer已经含有关键词\"></p>\n<ol start=\"2\">\n<li>空referer</li>\n</ol>\n<p>某些浏览器的防御部署是允许空 REFERER 的。</p>\n<p>还可以使用 burp 自带的 generate CSRF poc,选择测试 URL 右键选择生成 CSRF poc,将要替换的值然后保存访问即可。</p>\n<p>还可以使用 CSRFTester 软件来测试</p>\n<h2 id=\"漏洞检测\"><a href=\"#漏洞检测\" class=\"headerlink\" title=\"漏洞检测\"></a>漏洞检测</h2><ol>\n<li>GET</li>\n</ol>\n<p>如果带有 token 等验证参数，先去掉参数尝试能否正常请求，如果可以即存在 CSRF 漏洞。</p>\n<ol start=\"2\">\n<li>POST</li>\n</ol>\n<p>最简单的方法就是抓取一个正常请求的数据包，去掉 token 等验证参数后提交，如果正常访问，再去掉 Referer 后重新提交，如果提交还有效，那么基本可以认为存在 CSRF 漏洞，可以构造外部 form 表单来进行提交。如果去掉 referer 失败还可以验证对 referer 校验是否严格尝试绕过。也可能存在代码对请求类型判断不严格($_REQUEST[])，如果 post 失败了尝试改成 get 进行请求。 </p>\n<h2 id=\"防御\"><a href=\"#防御\" class=\"headerlink\" title=\"防御\"></a>防御</h2><h3 id=\"验证码\"><a href=\"#验证码\" class=\"headerlink\" title=\"验证码\"></a>验证码</h3><p>强制用户必须与应用完成交互，避免在不知情的情况下构造网络请求</p>\n<h3 id=\"Referer-Check\"><a href=\"#Referer-Check\" class=\"headerlink\" title=\"Referer Check\"></a>Referer Check</h3><p>检查请求是否来自合法的源，但是不足之处在于浏览器并非什么时候都能取到Referer.</p>\n<h3 id=\"Anti-CSRF-Token\"><a href=\"#Anti-CSRF-Token\" class=\"headerlink\" title=\"Anti CSRF Token\"></a>Anti CSRF Token</h3><p>将参数加密，或者使用一些真随机数，让攻击者无法猜测到参数值，达到“不可预测性原则”。可以新加一个参数 TOKEN ，同时放在表单和 session 中，服务端只需验证表单中的 TOKEN 和 session 中的 Token 是否一致，一致则认为是合法请求。 </p>\n","text":"CSRF 简单认识12/22/2019 11:47:20 AM 什么是CSRF跨站请求伪造-Cross Site Request Forgery，也被称作XSRF，简单来说就是 攻击者在不知道某个账户账号密码的情况下，利用目标站点已经登陆过的账户产生的身份凭证信息(cookie)","link":"","raw":null,"photos":[],"categories":[{"name":"渗透测试","slug":"渗透测试","count":5,"path":"api/categories/渗透测试.json"}],"tags":[{"name":"CSRF","slug":"CSRF","count":1,"path":"api/tags/CSRF.json"}]}]}